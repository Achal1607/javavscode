diff --git a/java/api.java/apichanges.xml b/java/api.java/apichanges.xml
index 6144317f592b..c87921b2ff1d 100644
--- a/java/api.java/apichanges.xml
+++ b/java/api.java/apichanges.xml
@@ -52,6 +52,21 @@
 <!-- ACTUAL CHANGES BEGIN HERE: -->
 
 <changes>
+        <change id="ParseLineArgFile">
+            <api name="queries"/>
+            <summary>Result.parseLine permits parsing of argfiles based on current working directory.</summary>
+            <version major="1" minor="91"/>
+            <date day="4" month="6" year="2024"/>
+            <author login="jlahoda"/>
+            <compatibility semantic="compatible" source="compatible" binary="compatible"/>
+            <description>
+                <p>
+                    CompilerOptionsQueryImplementation.Result.parseLine is enhanced with the ability to parse
+                    argfiles, based on a specified current working directory
+                </p>
+            </description>
+            <class package="org.netbeans.spi.java.queries" name="CompilerOptionsQueryImplementation"/>
+        </change>
         <change id="SourceAttacher.Definer2">
             <api name="queries"/>
             <summary>Allows <code>SourceJavadocAttacherImplementation.Definer</code> to reject a binary root.</summary>
diff --git a/java/api.java/manifest.mf b/java/api.java/manifest.mf
index 56d512e79aa2..1c9b76387829 100644
--- a/java/api.java/manifest.mf
+++ b/java/api.java/manifest.mf
@@ -1,6 +1,6 @@
 Manifest-Version: 1.0
 OpenIDE-Module: org.netbeans.api.java/1
-OpenIDE-Module-Specification-Version: 1.90
+OpenIDE-Module-Specification-Version: 1.91
 OpenIDE-Module-Localizing-Bundle: org/netbeans/api/java/queries/Bundle.properties
 AutoUpdate-Show-In-Client: false
 
diff --git a/java/api.java/src/org/netbeans/spi/java/queries/CompilerOptionsQueryImplementation.java b/java/api.java/src/org/netbeans/spi/java/queries/CompilerOptionsQueryImplementation.java
index bc35eec9cda7..6f678a8c0658 100644
--- a/java/api.java/src/org/netbeans/spi/java/queries/CompilerOptionsQueryImplementation.java
+++ b/java/api.java/src/org/netbeans/spi/java/queries/CompilerOptionsQueryImplementation.java
@@ -18,13 +18,20 @@
  */
 package org.netbeans.spi.java.queries;
 
+import java.io.IOException;
+import java.net.URI;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
+import java.util.function.Consumer;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 import javax.swing.event.ChangeListener;
 import org.netbeans.api.annotations.common.CheckForNull;
 import org.netbeans.api.annotations.common.NonNull;
+import org.netbeans.api.annotations.common.NullAllowed;
 import org.openide.filesystems.FileObject;
+import org.openide.filesystems.URLMapper;
 
 /**
  * Permits providers to return explicit compiler options for Java source file.
@@ -47,6 +54,8 @@ public interface CompilerOptionsQueryImplementation {
      * ability to listen to it.
      */
     public abstract static class Result {
+        private static final Logger LOG = Logger.getLogger(CompilerOptionsQueryImplementation.class.getName());
+
         /**
          * Gets the explicit compiler options.
          * @return the list of the compiler options
@@ -72,9 +81,29 @@ public abstract static class Result {
          * @return a list of command line arguments
          */
         protected final List<String> parseLine(@NonNull final String commandLine) {
+            return doParseLine(commandLine, null);
+        }
+
+        /**
+         * Utility method the tokenize the command line into individual arguments.
+         * @param commandLine the command line to be tokenized
+         * @param workingDirectory if set to null, argument files will not be supported;
+         *                         if non-null, argument file names will be resolved relative to this directory
+         * @return a list of command line arguments
+         * @since 1.92
+         */
+        protected final List<String> parseLine(@NonNull final String commandLine,
+                                               @NullAllowed URI workingDirectory) {
+            return doParseLine(commandLine, workingDirectory);
+        }
+
+        static List<String> doParseLine(@NonNull final String commandLine,
+                                        @NullAllowed URI workingDirectory) {
             final List<String> result = new ArrayList<>();
             StringBuilder current = new StringBuilder();
             boolean escape = false, doubleQuote = false, quote = false;
+            Consumer<String> defaultHandleOption = result::add;
+            Consumer<String> handleOption = defaultHandleOption;
             for (int i = 0; i < commandLine.length(); i++) {
                 final char c = commandLine.charAt(i);
                 switch (c) {
@@ -99,7 +128,8 @@ protected final List<String> parseLine(@NonNull final String commandLine) {
                     case '\t':  //NOI18N
                         if (!escape && !quote && !doubleQuote) {
                             if (current.length() > 0) {
-                                result.add(current.toString());
+                                handleOption.accept(current.toString());
+                                handleOption = defaultHandleOption;
                                 current = new StringBuilder();
                             }
                         } else {
@@ -107,6 +137,27 @@ protected final List<String> parseLine(@NonNull final String commandLine) {
                         }
                         escape = false;
                         break;
+                    case '@':
+                        if (workingDirectory != null && i + 1 < commandLine.length() && commandLine.charAt(i + 1) != '@' && current.length() == 0) {
+                            handleOption = path -> {
+                                try {
+                                    URI resolved = workingDirectory.resolve(path);
+                                    FileObject file = URLMapper.findFileObject(resolved.toURL());
+                                    if (file == null) {
+                                        LOG.log(Level.FINE, "URI {0}, resolved to {1}, did not yield an existing file", new Object[] {path, resolved.toString()});
+                                        result.add("@" + path);
+                                        return ;
+                                    }
+                                    for (String line : file.asLines()) {
+                                        result.addAll(doParseLine(line, null));
+                                    }
+                                } catch (IOException ex) {
+                                    LOG.log(Level.FINE, null, ex);
+                                }
+                            };
+                            break;
+                        }
+                        //fall-through
                     default:
                         current.append(c);
                         escape = false;
@@ -114,7 +165,7 @@ protected final List<String> parseLine(@NonNull final String commandLine) {
                 }
             }
             if (current.length() > 0) {
-                result.add(current.toString());
+                handleOption.accept(current.toString());
             }
             return Collections.unmodifiableList(result);
         }
diff --git a/java/api.java/test/unit/src/org/netbeans/spi/java/queries/CompilerOptionsQueryImplementationTest.java b/java/api.java/test/unit/src/org/netbeans/spi/java/queries/CompilerOptionsQueryImplementationTest.java
new file mode 100644
index 000000000000..29fff1485d40
--- /dev/null
+++ b/java/api.java/test/unit/src/org/netbeans/spi/java/queries/CompilerOptionsQueryImplementationTest.java
@@ -0,0 +1,60 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.netbeans.spi.java.queries;
+
+import java.io.OutputStream;
+import java.nio.charset.StandardCharsets;
+import java.util.Arrays;
+import org.junit.Test;
+import org.netbeans.junit.NbTestCase;
+import org.netbeans.spi.java.queries.CompilerOptionsQueryImplementation.Result;
+import org.openide.filesystems.FileObject;
+import org.openide.filesystems.FileUtil;
+
+public class CompilerOptionsQueryImplementationTest extends NbTestCase {
+
+    public CompilerOptionsQueryImplementationTest(String name) {
+        super(name);
+    }
+
+    @Test
+    public void testArgumentFiles() throws Exception {
+        FileObject wd = FileUtil.toFileObject(getWorkDir());
+        FileObject argfile = FileUtil.createData(wd, "argfile");
+        try (OutputStream out = argfile.getOutputStream()) {
+            out.write("test \t\t \"quoted1\"   'quoted2'\n   \t\n   @argfile\n".getBytes(StandardCharsets.UTF_8));
+        }
+
+        assertEquals(Arrays.asList("test", "quoted1", "quoted2", "@argfile"),
+                     Result.doParseLine("@argfile", wd.toURI()));
+        assertEquals(Arrays.asList("@argfile"),
+                     Result.doParseLine("@argfile", null));
+        assertEquals(Arrays.asList("prefix@argfile"),
+                     Result.doParseLine("prefix@argfile", wd.toURI()));
+        assertEquals(Arrays.asList("@@"),
+                     Result.doParseLine("@@", wd.toURI()));
+        assertEquals(Arrays.asList("@"),
+                     Result.doParseLine("@", wd.toURI()));
+        assertEquals(Arrays.asList("test", "quoted1", "quoted2", "@argfile"),
+                     Result.doParseLine("@" + FileUtil.toFile(argfile).getAbsolutePath(), wd.toURI()));
+        assertEquals(Arrays.asList("@nonexistent"),
+                     Result.doParseLine("@nonexistent", wd.toURI()));
+    }
+
+}
diff --git a/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/AttributeBasedSingleFileOptions.java b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/AttributeBasedSingleFileOptions.java
index cfa6c4d209aa..65e6cd433a03 100644
--- a/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/AttributeBasedSingleFileOptions.java
+++ b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/AttributeBasedSingleFileOptions.java
@@ -18,6 +18,7 @@
  */
 package org.netbeans.modules.java.file.launcher;
 
+import java.net.URI;
 import javax.swing.event.ChangeListener;
 import org.netbeans.modules.java.file.launcher.queries.MultiSourceRootProvider;
 import org.netbeans.modules.java.file.launcher.spi.SingleFileOptionsQueryImplementation;
@@ -94,6 +95,11 @@ public String getOptions() {
             return vmOptionsObj != null ? (String) vmOptionsObj : "";
         }
 
+        @Override
+        public URI getWorkDirectory() {
+            return root != null ? root.toURI() : source.getParent().toURI();
+        }
+
         @Override
         public void addChangeListener(ChangeListener listener) {
             cs.addChangeListener(listener);
diff --git a/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/SingleSourceFileUtil.java b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/SingleSourceFileUtil.java
index c3404b86cf8a..8ca36068a060 100644
--- a/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/SingleSourceFileUtil.java
+++ b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/SingleSourceFileUtil.java
@@ -20,23 +20,26 @@
 
 import java.io.File;
 import java.io.IOException;
+import java.net.URI;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.logging.Level;
 import java.util.logging.Logger;
+import javax.swing.event.ChangeEvent;
 import javax.swing.event.ChangeListener;
 import org.netbeans.api.java.platform.JavaPlatformManager;
 import org.netbeans.api.project.FileOwnerQuery;
-import org.netbeans.api.project.Project;
 import org.netbeans.modules.java.file.launcher.queries.MultiSourceRootProvider;
 import org.netbeans.modules.java.file.launcher.spi.SingleFileOptionsQueryImplementation;
-import org.netbeans.modules.java.file.launcher.spi.SingleFileOptionsQueryImplementation.Result;
 import org.netbeans.spi.java.queries.CompilerOptionsQueryImplementation;
 import org.openide.filesystems.FileObject;
 import org.openide.filesystems.FileStateInvalidException;
 import org.openide.filesystems.FileUtil;
 import org.openide.loaders.DataObject;
+import org.openide.util.ChangeSupport;
 import org.openide.util.Lookup;
 
 /**
@@ -127,30 +130,31 @@ public static boolean hasClassSibling(FileObject fo) {
         return fo.getParent().getFileObject(fo.getName(), "class") != null;
     }
 
-    public static Result getOptionsFor(FileObject file) {
+    public static ParsedFileOptions getOptionsFor(FileObject file) {
         if (MultiSourceRootProvider.DISABLE_MULTI_SOURCE_ROOT) {
             return null;
         }
 
         for (SingleFileOptionsQueryImplementation  i : Lookup.getDefault().lookupAll(SingleFileOptionsQueryImplementation.class)) {
-            Result r = i.optionsFor(file);
+            SingleFileOptionsQueryImplementation.Result r = i.optionsFor(file);
 
             if (r != null) {
-                return r;
+                return new ParsedFileOptions(r);
             }
         }
+
         return null;
     }
 
-    public static List<String> parseLine(String line) {
-        return PARSER.doParse(line);
+    public static List<String> parseLine(String line, URI workingDirectory) {
+        return PARSER.doParse(line, workingDirectory);
     }
 
     private static final LineParser PARSER = new LineParser();
 
     private static class LineParser extends CompilerOptionsQueryImplementation.Result {
-        public List<String> doParse(String line) {
-            return parseLine(line);
+        public List<String> doParse(String line, URI workingDirectory) {
+            return parseLine(line, workingDirectory);
         }
 
         @Override
@@ -165,4 +169,69 @@ public void addChangeListener(ChangeListener listener) {}
         public void removeChangeListener(ChangeListener listener) {}
     }
 
+    public static final class ParsedFileOptions extends CompilerOptionsQueryImplementation.Result implements ChangeListener {
+
+        private final ChangeSupport cs;
+        private final SingleFileOptionsQueryImplementation.Result delegate;
+        private final AtomicInteger updateCount = new AtomicInteger(0);
+        private List<? extends String> arguments;
+
+        private ParsedFileOptions(SingleFileOptionsQueryImplementation.Result delegate) {
+            this.cs = new ChangeSupport(this);
+            this.delegate = delegate;
+            this.delegate.addChangeListener(this);
+        }
+
+        @Override
+        public List<? extends String> getArguments() {
+            int update;
+            synchronized (this) {
+                if (arguments != null) {
+                    return arguments;
+                }
+
+                update = updateCount.get();
+            }
+
+            while (true) {
+                List<String> newArguments =
+                        Collections.unmodifiableList(parseLine(delegate.getOptions(),
+                                                               delegate.getWorkDirectory()));
+
+                synchronized (this) {
+                    if (update == updateCount.get()) {
+                        arguments = newArguments;
+                        return newArguments;
+                    }
+
+                    //changed in the mean time, try again:
+                    update = updateCount.get();
+                }
+            }
+        }
+
+        public URI getWorkDirectory() {
+            return delegate.getWorkDirectory();
+        }
+
+        @Override
+        public void addChangeListener(ChangeListener listener) {
+            cs.addChangeListener(listener);
+        }
+
+        @Override
+        public void removeChangeListener(ChangeListener listener) {
+            cs.removeChangeListener(listener);
+        }
+
+        @Override
+        public void stateChanged(ChangeEvent ce) {
+            synchronized (this) {
+                arguments = null;
+                updateCount.incrementAndGet();
+            }
+
+            cs.fireChange();
+        }
+    }
 }
diff --git a/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/actions/LaunchProcess.java b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/actions/LaunchProcess.java
index 7646ab59554d..51e6b9182f5a 100644
--- a/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/actions/LaunchProcess.java
+++ b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/actions/LaunchProcess.java
@@ -20,6 +20,7 @@
 
 import java.io.File;
 import java.io.IOException;
+import java.net.URI;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -31,6 +32,7 @@
 import org.openide.filesystems.FileObject;
 import org.openide.filesystems.FileUtil;
 import org.openide.util.BaseUtilities;
+import org.openide.util.Utilities;
 
 final class LaunchProcess implements Callable<Process> {
 
@@ -69,12 +71,14 @@ private Process setupProcess(String port) throws InterruptedException {
             FileObject java = JavaPlatformManager.getDefault().getDefaultPlatform().findTool("java"); //NOI18N
             File javaFile = FileUtil.toFile(java);
             String javaPath = javaFile.getAbsolutePath();
+            URI cwd = SingleSourceFileUtil.getOptionsFor(fileObject).getWorkDirectory();
+            File workDir = Utilities.toFile(cwd);
 
             ExplicitProcessParameters paramsFromAttributes =
                     ExplicitProcessParameters.builder()
                                              .args(readArgumentsFromAttribute(fileObject, SingleSourceFileUtil.FILE_ARGUMENTS))
                                              .launcherArgs(readArgumentsFromAttribute(fileObject, SingleSourceFileUtil.FILE_VM_OPTIONS))
-                                             .workingDirectory(FileUtil.toFile(fileObject.getParent()))
+                                             .workingDirectory(workDir)
                                              .build();
 
             ExplicitProcessParameters realParameters =
@@ -97,7 +101,7 @@ private Process setupProcess(String port) throws InterruptedException {
                 commandsList.add(FileUtil.toFile(fileObject.getParent()).toString());
                 commandsList.add(fileObject.getName());
             } else {
-                commandsList.add(fileObject.getNameExt());
+                commandsList.add(FileUtil.toFile(fileObject).getAbsolutePath());
             }
 
             if (realParameters.getArguments() != null) {
diff --git a/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/api/SourceLauncher.java b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/api/SourceLauncher.java
index 8603ed6b899b..c09b89592561 100644
--- a/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/api/SourceLauncher.java
+++ b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/api/SourceLauncher.java
@@ -59,7 +59,7 @@ public static String joinCommandLines(Iterable<? extends String> inputLines) {
         Map<String, String> joinedOptions = new HashMap<>();
 
         for (String value : inputLines) {
-            List<String> args = SingleSourceFileUtil.parseLine(value);
+            List<String> args = SingleSourceFileUtil.parseLine(value, null);
 
             for (int i = 0; i < args.size(); i++) {
                 switch (args.get(i)) {
diff --git a/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/queries/LauncherSourceLevelQueryImpl.java b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/queries/LauncherSourceLevelQueryImpl.java
index f84258ecce93..2d0452e3f679 100644
--- a/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/queries/LauncherSourceLevelQueryImpl.java
+++ b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/queries/LauncherSourceLevelQueryImpl.java
@@ -24,7 +24,7 @@
 import javax.swing.event.ChangeListener;
 import org.netbeans.api.java.platform.JavaPlatformManager;
 import org.netbeans.modules.java.file.launcher.SingleSourceFileUtil;
-import org.netbeans.modules.java.file.launcher.spi.SingleFileOptionsQueryImplementation;
+import org.netbeans.modules.java.file.launcher.SingleSourceFileUtil.ParsedFileOptions;
 import org.netbeans.spi.java.queries.SourceLevelQueryImplementation2;
 import org.openide.filesystems.FileObject;
 import org.openide.util.ChangeSupport;
@@ -39,7 +39,7 @@ public class LauncherSourceLevelQueryImpl implements SourceLevelQueryImplementat
 
     @Override
     public Result getSourceLevel(FileObject javaFile) {
-        SingleFileOptionsQueryImplementation.Result delegate = SingleSourceFileUtil.getOptionsFor(javaFile);
+        ParsedFileOptions delegate = SingleSourceFileUtil.getOptionsFor(javaFile);
 
         if (delegate != null) {
             return new ResultImpl(delegate);
@@ -54,17 +54,17 @@ private static final class ResultImpl implements ChangeListener, Result {
                 JavaPlatformManager.getDefault().getDefaultPlatform().getSpecification().getVersion().toString();
 
         private final ChangeSupport cs = new ChangeSupport(this);
-        private final SingleFileOptionsQueryImplementation.Result delegate;
+        private final ParsedFileOptions delegate;
         private String sourceLevel;
 
-        public ResultImpl(SingleFileOptionsQueryImplementation.Result delegate) {
+        public ResultImpl(ParsedFileOptions delegate) {
             this.delegate = delegate;
             this.delegate.addChangeListener(this);
             updateDelegate();
         }
 
         private void updateDelegate() {
-            List<String> parsed = SingleSourceFileUtil.parseLine(delegate.getOptions());
+            List<? extends String> parsed = delegate.getArguments();
             String sourceLevel = DEFAULT_SOURCE_LEVEL;
 
             for (int i = 0; i < parsed.size(); i++) {
diff --git a/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/queries/MultiSourceRootProvider.java b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/queries/MultiSourceRootProvider.java
index e5ed4166dc2d..7793d0663d79 100644
--- a/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/queries/MultiSourceRootProvider.java
+++ b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/queries/MultiSourceRootProvider.java
@@ -20,6 +20,7 @@
 
 import java.beans.PropertyChangeListener;
 import java.beans.PropertyChangeSupport;
+import java.io.File;
 import java.io.IOException;
 import java.net.URL;
 import java.util.ArrayList;
@@ -47,7 +48,7 @@
 import org.netbeans.api.project.FileOwnerQuery;
 import org.netbeans.api.queries.FileEncodingQuery;
 import org.netbeans.modules.java.file.launcher.SingleSourceFileUtil;
-import org.netbeans.modules.java.file.launcher.spi.SingleFileOptionsQueryImplementation;
+import org.netbeans.modules.java.file.launcher.SingleSourceFileUtil.ParsedFileOptions;
 import org.netbeans.spi.java.classpath.ClassPathFactory;
 import org.netbeans.spi.java.classpath.ClassPathImplementation;
 
@@ -57,10 +58,16 @@
 import org.netbeans.spi.java.classpath.FilteringPathResourceImplementation;
 import org.netbeans.spi.java.classpath.PathResourceImplementation;
 import org.netbeans.spi.java.classpath.support.ClassPathSupport;
+import org.openide.filesystems.FileChangeAdapter;
+import org.openide.filesystems.FileEvent;
 import org.openide.filesystems.FileObject;
+import org.openide.filesystems.FileRenameEvent;
 import org.openide.filesystems.FileUtil;
 import org.openide.filesystems.URLMapper;
 import org.openide.util.NbBundle.Messages;
+import org.openide.util.RequestProcessor;
+import org.openide.util.RequestProcessor.Task;
+import org.openide.util.Utilities;
 import org.openide.util.lookup.ServiceProvider;
 import org.openide.util.lookup.ServiceProviders;
 
@@ -70,9 +77,15 @@
 })
 public class MultiSourceRootProvider implements ClassPathProvider {
 
+    private static final RequestProcessor WORKER = new RequestProcessor(MultiSourceRootProvider.class.getName(), 1, false, false);
     private static final Logger LOG = Logger.getLogger(MultiSourceRootProvider.class.getName());
 
     public static boolean DISABLE_MULTI_SOURCE_ROOT = Boolean.getBoolean("java.disable.multi.source.root");
+    public static boolean SYNCHRONOUS_UPDATES = false;
+
+    private static final Set<String> MODULAR_DIRECTORY_OPTIONS = new HashSet<>(Arrays.asList(
+        "--module-path", "-p"
+    ));
 
     //TODO: the cache will probably be never cleared, as the ClassPath/value refers to the key(?)
     private Map<FileObject, ClassPath> file2SourceCP = new WeakHashMap<>();
@@ -234,7 +247,7 @@ private ClassPath attributeBasedPath(FileObject file, Map<FileObject, ClassPath>
 
         synchronized (this) {
         return file2ClassPath.computeIfAbsent(file, f -> {
-            SingleFileOptionsQueryImplementation.Result delegate = SingleSourceFileUtil.getOptionsFor(f);
+            ParsedFileOptions delegate = SingleSourceFileUtil.getOptionsFor(f);
 
             if (delegate == null) {
                 return null;
@@ -253,14 +266,16 @@ private static boolean registerRoot(FileObject root) {
         return "true".equals(Bundle.SETTING_AutoRegisterAsRoot());
     }
 
-    private static final class AttributeBasedClassPathImplementation implements ChangeListener, ClassPathImplementation {
+    private static final class AttributeBasedClassPathImplementation extends FileChangeAdapter implements ChangeListener, ClassPathImplementation {
         private final PropertyChangeSupport pcs = new PropertyChangeSupport(this);
-        private final SingleFileOptionsQueryImplementation.Result delegate;
+        private final Task updateDelegatesTask = WORKER.create(this::doUpdateDelegates);
+        private final Set<String> directoriesWithListener = new HashSet<>();
+        private final ParsedFileOptions delegate;
         private final Set<String> optionKeys;
         private Set<URL> currentURLs;
         private List<? extends PathResourceImplementation> delegates = Collections.emptyList();
 
-        public AttributeBasedClassPathImplementation(SingleFileOptionsQueryImplementation.Result delegate, String... optionKeys) {
+        public AttributeBasedClassPathImplementation(ParsedFileOptions delegate, String... optionKeys) {
             this.delegate = delegate;
             this.optionKeys = new HashSet<>(Arrays.asList(optionKeys));
             delegate.addChangeListener(this);
@@ -273,29 +288,84 @@ public void stateChanged(ChangeEvent ce) {
         }
 
         private void updateDelegates() {
+            if (SYNCHRONOUS_UPDATES) {
+                doUpdateDelegates();
+            } else {
+                updateDelegatesTask.schedule(0);
+            }
+        }
+
+        private void doUpdateDelegates() {
             Set<URL> newURLs = new HashSet<>();
             List<PathResourceImplementation> newDelegates = new ArrayList<>();
-            List<String> parsed = SingleSourceFileUtil.parseLine(delegate.getOptions());
-
-            for (int i = 0; i < parsed.size(); i++) {
-                if (optionKeys.contains(parsed.get(i)) && i + 1 < parsed.size()) {
-                    ClassPathSupport.createClassPath(parsed.get(i + 1))
-                        .entries()
-                        .stream()
-                        .map(e -> e.getURL())
-                        .forEach(u -> {
+            List<? extends String> parsed = delegate.getArguments();
+            File workDirectory = Utilities.toFile(delegate.getWorkDirectory());
+            Set<String> toRemoveFSListeners = new HashSet<>();
+            Set<String> addedFSListeners = new HashSet<>();
+
+            synchronized (this) {
+                toRemoveFSListeners.addAll(directoriesWithListener);
+            }
+
+            for (int i = 0; i < parsed.size() - 1; i++) {
+                String currentOption = parsed.get(i);
+
+                if (optionKeys.contains(currentOption)) {
+                    for (String piece : parsed.get(i + 1).split(File.pathSeparator)) {
+                        File pieceFile = new File(piece);
+
+                        if (!pieceFile.isAbsolute()) {
+                            pieceFile = new File(workDirectory, piece);
+                        }
+
+                        File f = FileUtil.normalizeFile(pieceFile);
+                        Iterable<File> expandedPaths;
+
+                        if (MODULAR_DIRECTORY_OPTIONS.contains(currentOption)) {
+                            if (!toRemoveFSListeners.remove(f.getAbsolutePath()) &&
+                                addedFSListeners.add(f.getAbsolutePath())) {
+                                FileUtil.addFileChangeListener(this, f);
+                            }
+                        }
+
+                        if (MODULAR_DIRECTORY_OPTIONS.contains(currentOption) &&
+                            f.isDirectory() &&
+                            !new File(f, "module-info.class").exists()) {
+                            File[] children = f.listFiles();
+
+                            if (children != null) {
+                                expandedPaths = Arrays.asList(children);
+                            } else {
+                                expandedPaths = Collections.emptyList();
+                            }
+                        } else {
+                            expandedPaths = Arrays.asList(f);
+                        }
+
+                        for (File expanded : expandedPaths) {
+                            URL u = FileUtil.urlForArchiveOrDir(expanded);
+                            if (u == null) {
+                                throw new IllegalArgumentException("Path entry looks to be invalid: " + piece); // NOI18N
+                            }
                             newURLs.add(u);
                             newDelegates.add(ClassPathSupport.createResource(u));
-                        });
+                        }
+                    }
                 }
             }
 
+            for (String removeFSListener : toRemoveFSListeners) {
+                FileUtil.removeFileChangeListener(this, new File(removeFSListener));
+            }
+
             synchronized (this) {
                 if (Objects.equals(currentURLs, newURLs)) {
                     return ;
                 }
                 this.currentURLs = newURLs;
                 this.delegates = newDelegates;
+                this.directoriesWithListener.removeAll(toRemoveFSListeners);
+                this.directoriesWithListener.addAll(addedFSListeners);
             }
 
             pcs.firePropertyChange(PROP_RESOURCES, null, null);
@@ -316,6 +386,26 @@ public void removePropertyChangeListener(PropertyChangeListener listener) {
             pcs.removePropertyChangeListener(listener);
         }
 
+        @Override
+        public void fileDataCreated(FileEvent fe) {
+            updateDelegates();
+        }
+
+        @Override
+        public void fileDeleted(FileEvent fe) {
+            updateDelegates();
+        }
+
+        @Override
+        public void fileFolderCreated(FileEvent fe) {
+            updateDelegates();
+        }
+
+        @Override
+        public void fileRenamed(FileRenameEvent fe) {
+            updateDelegates();
+        }
+
     }
 
     private static final class RootPathResourceImplementation implements FilteringPathResourceImplementation {
diff --git a/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/queries/SingleSourceCompilerOptQueryImpl.java b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/queries/SingleSourceCompilerOptQueryImpl.java
index 28d08d914e16..c6e9b64bb69e 100644
--- a/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/queries/SingleSourceCompilerOptQueryImpl.java
+++ b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/queries/SingleSourceCompilerOptQueryImpl.java
@@ -18,14 +18,9 @@
  */
 package org.netbeans.modules.java.file.launcher.queries;
 
-import java.util.List;
-import javax.swing.event.ChangeEvent;
-import javax.swing.event.ChangeListener;
 import org.netbeans.modules.java.file.launcher.SingleSourceFileUtil;
-import org.netbeans.modules.java.file.launcher.spi.SingleFileOptionsQueryImplementation;
 import org.netbeans.spi.java.queries.CompilerOptionsQueryImplementation;
 import org.openide.filesystems.FileObject;
-import org.openide.util.ChangeSupport;
 import org.openide.util.lookup.ServiceProvider;
 
 /**
@@ -35,46 +30,11 @@
 @ServiceProvider(service = CompilerOptionsQueryImplementation.class, position = 100)
 public class SingleSourceCompilerOptQueryImpl implements CompilerOptionsQueryImplementation {
 
+    public static final SingleSourceCompilerOptQueryImpl INSTANCE = new SingleSourceCompilerOptQueryImpl();
+
     @Override
     public CompilerOptionsQueryImplementation.Result getOptions(FileObject file) {
-        SingleFileOptionsQueryImplementation.Result delegate = SingleSourceFileUtil.getOptionsFor(file);
-
-        if (delegate != null) {
-            return new ResultImpl(delegate);
-        } else {
-            return null;
-        }
+        return SingleSourceFileUtil.getOptionsFor(file);
     }
 
-    private static final class ResultImpl extends CompilerOptionsQueryImplementation.Result implements ChangeListener {
-
-        private final ChangeSupport cs;
-        private final SingleFileOptionsQueryImplementation.Result delegate;
-
-        ResultImpl(SingleFileOptionsQueryImplementation.Result delegate) {
-            this.cs = new ChangeSupport(this);
-            this.delegate = delegate;
-            this.delegate.addChangeListener(this);
-        }
-
-        @Override
-        public List<? extends String> getArguments() {
-            return parseLine(delegate.getOptions());
-        }
-
-        @Override
-        public void addChangeListener(ChangeListener listener) {
-            cs.addChangeListener(listener);
-        }
-
-        @Override
-        public void removeChangeListener(ChangeListener listener) {
-            cs.removeChangeListener(listener);
-        }
-
-        @Override
-        public void stateChanged(ChangeEvent ce) {
-            cs.fireChange();
-        }
-    }
 }
diff --git a/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/spi/SingleFileOptionsQueryImplementation.java b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/spi/SingleFileOptionsQueryImplementation.java
index ed29d610d89d..216706463c3b 100644
--- a/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/spi/SingleFileOptionsQueryImplementation.java
+++ b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/spi/SingleFileOptionsQueryImplementation.java
@@ -18,7 +18,9 @@
  */
 package org.netbeans.modules.java.file.launcher.spi;
 
+import java.net.URI;
 import javax.swing.event.ChangeListener;
+import org.netbeans.api.annotations.common.NonNull;
 import org.openide.filesystems.FileObject;
 
 public interface SingleFileOptionsQueryImplementation {
@@ -27,6 +29,9 @@ public interface SingleFileOptionsQueryImplementation {
 
     public interface Result {
         public String getOptions();
+        public default @NonNull URI getWorkDirectory() {
+            throw new UnsupportedOperationException();
+        }
         public void addChangeListener(ChangeListener l);
         public void removeChangeListener(ChangeListener l);
     }
diff --git a/java/java.file.launcher/test/unit/src/org/netbeans/modules/java/file/launcher/queries/MultiSourceRootProviderTest.java b/java/java.file.launcher/test/unit/src/org/netbeans/modules/java/file/launcher/queries/MultiSourceRootProviderTest.java
index 48083a04b762..61694bb7845a 100644
--- a/java/java.file.launcher/test/unit/src/org/netbeans/modules/java/file/launcher/queries/MultiSourceRootProviderTest.java
+++ b/java/java.file.launcher/test/unit/src/org/netbeans/modules/java/file/launcher/queries/MultiSourceRootProviderTest.java
@@ -18,11 +18,24 @@
  */
 package org.netbeans.modules.java.file.launcher.queries;
 
+import java.net.URI;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
+import javax.swing.event.ChangeListener;
 import org.netbeans.api.java.classpath.ClassPath;
+import org.netbeans.api.java.classpath.JavaClassPathConstants;
 import org.netbeans.api.java.source.TestUtilities;
 import org.netbeans.junit.NbTestCase;
+import org.netbeans.modules.java.file.launcher.spi.SingleFileOptionsQueryImplementation;
+import org.netbeans.modules.java.file.launcher.spi.SingleFileOptionsQueryImplementation.Result;
 import org.openide.filesystems.FileObject;
 import org.openide.filesystems.FileUtil;
+import org.openide.util.ChangeSupport;
+import org.openide.util.Lookup;
+import org.openide.util.lookup.Lookups;
+import org.openide.util.lookup.ProxyLookup;
 
 /**
  *
@@ -30,6 +43,8 @@
  */
 public class MultiSourceRootProviderTest extends NbTestCase {
 
+    private final TestResultImpl testResult = new TestResultImpl();
+
     public MultiSourceRootProviderTest(String name) {
         super(name);
     }
@@ -40,8 +55,6 @@ public void testFindPackage() {
     }
 
     public void testSourcePathFiltering() throws Exception {
-        clearWorkDir();
-
         FileObject wd = FileUtil.toFileObject(getWorkDir());
         FileObject validTest = FileUtil.createData(wd, "valid/pack/Test1.java");
         FileObject invalidTest1 = FileUtil.createData(wd, "valid/pack/Test2.java");
@@ -61,4 +74,243 @@ public void testSourcePathFiltering() throws Exception {
         assertNull(provider.findClassPath(invalidTest1, ClassPath.SOURCE));
         assertNull(provider.findClassPath(invalidTest2, ClassPath.SOURCE));
     }
+
+    public void testRelativePaths() throws Exception {
+        FileObject wd = FileUtil.toFileObject(getWorkDir());
+        FileObject test = FileUtil.createData(wd, "src/pack/Test1.java");
+        FileObject libJar = FileUtil.createData(wd, "libs/lib.jar");
+        FileObject other = FileUtil.createFolder(wd, "other");
+        FileObject otherLibJar = FileUtil.createData(other, "libs/lib.jar");
+        FileObject otherLib2Jar = FileUtil.createData(other, "libs/lib2.jar");
+
+        TestUtilities.copyStringToFile(test, "package pack;");
+
+        testResult.setOptions("--class-path libs/lib.jar");
+        testResult.setWorkDirectory(wd.toURI());
+
+        MultiSourceRootProvider provider = new MultiSourceRootProvider();
+        ClassPath compileCP = provider.findClassPath(test, ClassPath.COMPILE);
+        AtomicInteger changeCount = new AtomicInteger();
+
+        compileCP.addPropertyChangeListener(evt -> {
+            if (ClassPath.PROP_ENTRIES.equals(evt.getPropertyName())) {
+                changeCount.incrementAndGet();
+            }
+        });
+        assertEquals(FileUtil.toFile(libJar).getAbsolutePath(), compileCP.toString());
+
+        testResult.setWorkDirectory(other.toURI());
+
+        assertEquals(1, changeCount.get());
+
+        assertEquals(FileUtil.toFile(otherLibJar).getAbsolutePath(), compileCP.toString());
+
+        testResult.setOptions("--class-path libs/lib2.jar");
+
+        assertEquals(2, changeCount.get());
+
+        assertEquals(FileUtil.toFile(otherLib2Jar).getAbsolutePath(), compileCP.toString());
+    }
+
+    public void testExpandModularDir() throws Exception {
+        FileObject wd = FileUtil.toFileObject(getWorkDir());
+        FileObject test = FileUtil.createData(wd, "src/pack/Test1.java");
+        FileObject libsDir = FileUtil.createFolder(wd, "libs");
+        FileObject lib1Jar = FileUtil.createData(libsDir, "lib1.jar");
+        FileObject lib2Jar = FileUtil.createData(libsDir, "lib2.jar");
+        FileObject lib3Dir = FileUtil.createFolder(libsDir, "lib3");
+
+        FileUtil.createData(lib3Dir, "module-info.class");
+
+        TestUtilities.copyStringToFile(test, "package pack;");
+
+        testResult.setOptions("--module-path " + FileUtil.toFile(libsDir).getAbsolutePath());
+        testResult.setWorkDirectory(FileUtil.toFileObject(getWorkDir()).toURI());
+
+        MultiSourceRootProvider provider = new MultiSourceRootProvider();
+        ClassPath moduleCP = provider.findClassPath(test, JavaClassPathConstants.MODULE_COMPILE_PATH);
+        ClassPath compileCP = provider.findClassPath(test, ClassPath.COMPILE);
+
+        assertEquals(new HashSet<>(Arrays.asList(FileUtil.getArchiveRoot(lib1Jar),
+                                                 FileUtil.getArchiveRoot(lib2Jar),
+                                                 lib3Dir)),
+                     new HashSet<>(Arrays.asList(moduleCP.getRoots())));
+
+        assertEquals(new HashSet<>(Arrays.asList(FileUtil.getArchiveRoot(lib1Jar),
+                                                 FileUtil.getArchiveRoot(lib2Jar),
+                                                 lib3Dir)),
+                     new HashSet<>(Arrays.asList(compileCP.getRoots())));
+
+        FileObject lib4Jar = FileUtil.createData(libsDir, "lib4.jar");
+
+        assertEquals(new HashSet<>(Arrays.asList(FileUtil.getArchiveRoot(lib1Jar),
+                                                 FileUtil.getArchiveRoot(lib2Jar),
+                                                 lib3Dir,
+                                                 FileUtil.getArchiveRoot(lib4Jar))),
+                     new HashSet<>(Arrays.asList(moduleCP.getRoots())));
+
+        assertEquals(new HashSet<>(Arrays.asList(FileUtil.getArchiveRoot(lib1Jar),
+                                                 FileUtil.getArchiveRoot(lib2Jar),
+                                                 lib3Dir,
+                                                 FileUtil.getArchiveRoot(lib4Jar))),
+                     new HashSet<>(Arrays.asList(compileCP.getRoots())));
+
+        testResult.setOptions("--module-path " + FileUtil.toFile(lib1Jar).getAbsolutePath());
+
+        assertEquals(new HashSet<>(Arrays.asList(FileUtil.getArchiveRoot(lib1Jar))),
+                     new HashSet<>(Arrays.asList(moduleCP.getRoots())));
+        assertEquals(new HashSet<>(Arrays.asList(FileUtil.getArchiveRoot(lib1Jar))),
+                     new HashSet<>(Arrays.asList(compileCP.getRoots())));
+
+        testResult.setOptions("--module-path " + FileUtil.toFile(lib3Dir).getAbsolutePath());
+
+        assertEquals(new HashSet<>(Arrays.asList(lib3Dir)),
+                     new HashSet<>(Arrays.asList(moduleCP.getRoots())));
+        assertEquals(new HashSet<>(Arrays.asList(lib3Dir)),
+                     new HashSet<>(Arrays.asList(compileCP.getRoots())));
+
+        testResult.setOptions("--module-path " + FileUtil.toFile(libsDir).getAbsolutePath());
+
+        assertEquals(new HashSet<>(Arrays.asList(FileUtil.getArchiveRoot(lib1Jar),
+                                                 FileUtil.getArchiveRoot(lib2Jar),
+                                                 lib3Dir,
+                                                 FileUtil.getArchiveRoot(lib4Jar))),
+                     new HashSet<>(Arrays.asList(moduleCP.getRoots())));
+
+        assertEquals(new HashSet<>(Arrays.asList(FileUtil.getArchiveRoot(lib1Jar),
+                                                 FileUtil.getArchiveRoot(lib2Jar),
+                                                 lib3Dir,
+                                                 FileUtil.getArchiveRoot(lib4Jar))),
+                     new HashSet<>(Arrays.asList(compileCP.getRoots())));
+
+        FileObject lib5Dir = FileUtil.createFolder(libsDir, "lib5Dir");
+
+        assertEquals(new HashSet<>(Arrays.asList(FileUtil.getArchiveRoot(lib1Jar),
+                                                 FileUtil.getArchiveRoot(lib2Jar),
+                                                 lib3Dir,
+                                                 FileUtil.getArchiveRoot(lib4Jar),
+                                                 lib5Dir)),
+                     new HashSet<>(Arrays.asList(moduleCP.getRoots())));
+
+        assertEquals(new HashSet<>(Arrays.asList(FileUtil.getArchiveRoot(lib1Jar),
+                                                 FileUtil.getArchiveRoot(lib2Jar),
+                                                 lib3Dir,
+                                                 FileUtil.getArchiveRoot(lib4Jar),
+                                                 lib5Dir)),
+                     new HashSet<>(Arrays.asList(compileCP.getRoots())));
+
+        lib5Dir.delete();
+
+        assertEquals(new HashSet<>(Arrays.asList(FileUtil.getArchiveRoot(lib1Jar),
+                                                 FileUtil.getArchiveRoot(lib2Jar),
+                                                 lib3Dir,
+                                                 FileUtil.getArchiveRoot(lib4Jar))),
+                     new HashSet<>(Arrays.asList(moduleCP.getRoots())));
+
+        assertEquals(new HashSet<>(Arrays.asList(FileUtil.getArchiveRoot(lib1Jar),
+                                                 FileUtil.getArchiveRoot(lib2Jar),
+                                                 lib3Dir,
+                                                 FileUtil.getArchiveRoot(lib4Jar))),
+                     new HashSet<>(Arrays.asList(compileCP.getRoots())));
+
+        lib4Jar.delete();
+
+        assertEquals(new HashSet<>(Arrays.asList(FileUtil.getArchiveRoot(lib1Jar),
+                                                 FileUtil.getArchiveRoot(lib2Jar),
+                                                 lib3Dir)),
+                     new HashSet<>(Arrays.asList(moduleCP.getRoots())));
+
+        assertEquals(new HashSet<>(Arrays.asList(FileUtil.getArchiveRoot(lib1Jar),
+                                                 FileUtil.getArchiveRoot(lib2Jar),
+                                                 lib3Dir)),
+                     new HashSet<>(Arrays.asList(compileCP.getRoots())));
+
+        FileUtil.createData(libsDir, "module-info.class");
+
+        assertEquals(new HashSet<>(Arrays.asList(libsDir)),
+                     new HashSet<>(Arrays.asList(moduleCP.getRoots())));
+        assertEquals(new HashSet<>(Arrays.asList(libsDir)),
+                     new HashSet<>(Arrays.asList(compileCP.getRoots())));
+    }
+
+    public void testBrokenOptions() throws Exception {
+        FileObject wd = FileUtil.toFileObject(getWorkDir());
+        FileObject test = FileUtil.createData(wd, "src/pack/Test1.java");
+
+        testResult.setOptions("--module-path");
+        testResult.setWorkDirectory(FileUtil.toFileObject(getWorkDir()).toURI());
+
+        MultiSourceRootProvider provider = new MultiSourceRootProvider();
+
+        provider.findClassPath(test, JavaClassPathConstants.MODULE_COMPILE_PATH);
+    }
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        clearWorkDir();
+    }
+
+    @Override
+    protected void runTest() throws Throwable {
+        SingleFileOptionsQueryImplementation queryImpl = file -> testResult;
+        ProxyLookup newQueryLookup = new ProxyLookup(Lookups.fixed(queryImpl),
+                                                     Lookups.exclude(Lookup.getDefault(),
+                                                                     SingleFileOptionsQueryImplementation.class));
+        Lookups.executeWith(newQueryLookup, () -> {
+            try {
+                super.runTest();
+            } catch (Error err) {
+                throw err;
+            } catch (RuntimeException ex) {
+                throw ex;
+            } catch (Throwable ex) {
+                throw new IllegalStateException(ex);
+            }
+        });
+    }
+
+    private static class TestResultImpl implements Result {
+
+        private final ChangeSupport cs = new ChangeSupport(this);
+        private final AtomicReference<String> options = new AtomicReference<>();
+        private final AtomicReference<URI> workdir = new AtomicReference<>();
+
+        public TestResultImpl() {
+        }
+
+        @Override
+        public String getOptions() {
+            return options.get();
+        }
+
+        public void setOptions(String options) {
+            this.options.set(options);
+            cs.fireChange();
+        }
+
+        @Override
+        public URI getWorkDirectory() {
+            return workdir.get();
+        }
+
+        public void setWorkDirectory(URI workdir) {
+            this.workdir.set(workdir);
+            cs.fireChange();
+        }
+
+        @Override
+        public void addChangeListener(ChangeListener l) {
+            cs.addChangeListener(l);
+        }
+
+        @Override
+        public void removeChangeListener(ChangeListener l) {
+            cs.removeChangeListener(l);
+        }
+    }
+
+    static {
+        MultiSourceRootProvider.SYNCHRONOUS_UPDATES = true;
+    }
 }
diff --git a/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/Server.java b/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/Server.java
index ea7db731562e..06411f66497d 100644
--- a/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/Server.java
+++ b/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/Server.java
@@ -1108,6 +1108,7 @@ protected LanguageClient client() {
             sessionServices.add(new WorkspaceUIContext(client));
             sessionServices.add(treeService.getNodeRegistry());
             sessionServices.add(inputService.getRegistry());
+            sessionServices.add(workspaceService.getWorkspace());
             ((LanguageClientAware) getTextDocumentService()).connect(client);
             ((LanguageClientAware) getWorkspaceService()).connect(client);
             ((LanguageClientAware) treeService).connect(client);
diff --git a/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/Workspace.java b/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/Workspace.java
new file mode 100644
index 000000000000..0ed7ae25386a
--- /dev/null
+++ b/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/Workspace.java
@@ -0,0 +1,29 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.netbeans.modules.java.lsp.server.protocol;
+
+import java.util.List;
+import org.openide.filesystems.FileObject;
+
+/**
+ * One workspace opened in the UI.
+ */
+public interface Workspace {
+    public List<FileObject> getClientWorkspaceFolders();
+}
diff --git a/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/WorkspaceServiceImpl.java b/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/WorkspaceServiceImpl.java
index 7060c264a420..9cb5bde33036 100644
--- a/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/WorkspaceServiceImpl.java
+++ b/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/WorkspaceServiceImpl.java
@@ -169,6 +169,12 @@ public final class WorkspaceServiceImpl implements WorkspaceService, LanguageCli
 
     private final Gson gson = new Gson();
     private final LspServerState server;
+    private final Workspace workspace = new Workspace() {
+        @Override
+        public List<FileObject> getClientWorkspaceFolders() {
+            return WorkspaceServiceImpl.this.getClientWorkspaceFolders();
+        }
+    };
     private NbCodeLanguageClient client;
 
     /**
@@ -1342,15 +1348,18 @@ public void didChangeConfiguration(DidChangeConfigurationParams params) {
         String altConfigPrefix = fullAltConfigPrefix.substring(0, fullAltConfigPrefix.length() - 1);
         boolean modified = false;
         String newVMOptions = "";
+        String newWorkingDirectory = null;
         JsonObject javaPlus = ((JsonObject) params.getSettings()).getAsJsonObject(altConfigPrefix);
         if (javaPlus != null) {
             JsonObject runConfig = javaPlus.getAsJsonObject("runConfig");
             if (runConfig != null) {
                 newVMOptions = runConfig.getAsJsonPrimitive("vmOptions").getAsString();
+                JsonPrimitive cwd = runConfig.getAsJsonPrimitive("cwd");
+                newWorkingDirectory = cwd != null ? cwd.getAsString() : null;
             }
         }
         for (SingleFileOptionsQueryImpl query : Lookup.getDefault().lookupAll(SingleFileOptionsQueryImpl.class)) {
-            modified |= query.setConfiguration(client, newVMOptions);
+            modified |= query.setConfiguration(workspace, newVMOptions, newWorkingDirectory);
         }
         if (modified) {
             ((TextDocumentServiceImpl)server.getTextDocumentService()).reRunDiagnostics();
@@ -1484,6 +1493,10 @@ public void connect(LanguageClient client) {
         this.client = (NbCodeLanguageClient)client;
     }
 
+    public Workspace getWorkspace() {
+        return workspace;
+    }
+
     private static final class CommandProgress extends ActionProgress {
 
         private final CompletableFuture<Object> commandFinished = new CompletableFuture<>();
diff --git a/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/singlesourcefile/SingleFileOptionsQueryImpl.java b/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/singlesourcefile/SingleFileOptionsQueryImpl.java
index c2e70cc1027c..da4898786f11 100644
--- a/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/singlesourcefile/SingleFileOptionsQueryImpl.java
+++ b/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/singlesourcefile/SingleFileOptionsQueryImpl.java
@@ -18,59 +18,115 @@
  */
 package org.netbeans.modules.java.lsp.server.singlesourcefile;
 
-import java.util.ArrayList;
-import java.util.List;
+import java.io.File;
+import java.net.URI;
+import java.util.HashMap;
 import java.util.Map;
 import java.util.Objects;
+import java.util.Set;
 import java.util.WeakHashMap;
+import javax.swing.event.ChangeEvent;
 import javax.swing.event.ChangeListener;
 import org.netbeans.api.project.FileOwnerQuery;
 import org.netbeans.api.project.Project;
 import org.netbeans.modules.java.file.launcher.api.SourceLauncher;
 import org.netbeans.modules.java.file.launcher.spi.SingleFileOptionsQueryImplementation;
-import org.netbeans.modules.java.lsp.server.protocol.NbCodeLanguageClient;
+import org.netbeans.modules.java.lsp.server.protocol.Workspace;
+import org.openide.filesystems.FileChangeAdapter;
+import org.openide.filesystems.FileEvent;
 import org.openide.filesystems.FileObject;
+import org.openide.filesystems.FileUtil;
 import org.openide.util.ChangeSupport;
 import org.openide.util.Lookup;
+import org.openide.util.Parameters;
 
 public abstract class SingleFileOptionsQueryImpl implements SingleFileOptionsQueryImplementation {
 
-    private final Map<NbCodeLanguageClient, ResultImpl> client2Options = new WeakHashMap<>();
-    private final GlobalResultImpl globalOptions = new GlobalResultImpl();
+    private final Map<Workspace, WorkspaceSettings> workspace2Settings = new WeakHashMap<>();
+    private final Map<Workspace, Map<FileObject, ResultImpl>> workspace2Folder2Options = new WeakHashMap<>();
 
     @Override
     public Result optionsFor(FileObject file) {
         if (isSingleSourceFile(file)) {
-            NbCodeLanguageClient client = Lookup.getDefault().lookup(NbCodeLanguageClient.class);
+            Workspace workspace = Lookup.getDefault().lookup(Workspace.class);
+            FileObject workspaceFolder = workspace != null ? findWorkspaceFolder(workspace, file) : null;
 
-            if (client != null) {
-                return getResult(client);
+            if (workspaceFolder != null) {
+                return getResult(workspace, workspaceFolder);
             } else {
-                return globalOptions;
+                Set<Workspace> workspaces;
+
+                synchronized (this) {
+                    workspaces = workspace2Settings.keySet();
+                }
+
+                for (Workspace w : workspaces) {
+                    FileObject folder = findWorkspaceFolder(w, file);
+                    if (folder != null) {
+                        return getResult(w, folder);
+                    }
+                }
+
+                return null;
+            }
+        }
+        return null;
+    }
+
+    private synchronized Result getResult(Workspace workspace, FileObject workspaceFolder) {
+        Map<FileObject, ResultImpl> folder2Result =
+                workspace2Folder2Options.computeIfAbsent(workspace, w -> new HashMap<>());
+        return folder2Result.computeIfAbsent(workspaceFolder, f -> new ResultImpl(folder2Result,
+                workspaceFolder,
+                getWorkspaceSettings(workspace)));
+    }
+
+    static FileObject findWorkspaceFolder(Workspace workspace, FileObject file) {
+        for (FileObject workspaceFolder : workspace.getClientWorkspaceFolders()) {
+            if (FileUtil.isParentOf(workspaceFolder, file) || workspaceFolder == file) {
+                return workspaceFolder;
             }
         }
+
+        //in case file is a source root, and the workspace folder is nested inside the root:
+        for (FileObject workspaceFolder : workspace.getClientWorkspaceFolders()) {
+            if (FileUtil.isParentOf(file, workspaceFolder)) {
+                return workspaceFolder;
+            }
+        }
+
         return null;
     }
 
-    private static final class ResultImpl implements Result {
+    private static final class ResultImpl extends FileChangeAdapter implements Result, ChangeListener {
 
         private final ChangeSupport cs = new ChangeSupport(this);
-        private String options = "";
+        private final Map<FileObject, ResultImpl> workspaceFolders2Results;
+        private final FileObject workspaceFolder;
+        private final WorkspaceSettings workspaceSettings;
+
+        public ResultImpl(Map<FileObject, ResultImpl> workspaceFolders2Results,
+                          FileObject workspaceFolder,
+                          WorkspaceSettings workspaceSettings) {
+            this.workspaceFolders2Results = workspaceFolders2Results;
+            this.workspaceFolder = workspaceFolder;
+            this.workspaceSettings = workspaceSettings;
+
+            workspaceSettings.addChangeListener(this);
+            workspaceFolder.addFileChangeListener(this);
+        }
 
         @Override
-        public synchronized String getOptions() {
-            return options;
+        public String getOptions() {
+            return workspaceSettings.getOptions();
         }
 
-        public boolean setOptions(String options) {
-            synchronized (this) {
-                if (Objects.equals(this.options, options)) {
-                    return false;
-                }
-                this.options = options;
-            }
-            cs.fireChange();
-            return true;
+        @Override
+        public URI getWorkDirectory() {
+            String cwd = workspaceSettings.getWorkDirectory();
+            FileObject workDir = cwd != null ? FileUtil.toFileObject(new File(cwd))
+                                             : workspaceFolder;
+            return workDir.toURI();
         }
 
         @Override
@@ -83,48 +139,69 @@ public void removeChangeListener(ChangeListener l) {
             cs.removeChangeListener(l);
         }
 
+        @Override
+        public void stateChanged(ChangeEvent ce) {
+            cs.fireChange();
+        }
+
+        @Override
+        public void fileDeleted(FileEvent fe) {
+            workspaceFolders2Results.remove(workspaceFolder);
+        }
+
     }
 
-    private final class GlobalResultImpl implements Result {
+    private final class WorkspaceSettings {
 
         private final ChangeSupport cs = new ChangeSupport(this);
 
-        @Override
-        public String getOptions() {
-            List<String> options = new ArrayList<>();
+        private String options;
+        private String workdirDirectory;
 
-            synchronized (SingleFileOptionsQueryImpl.this) {
-                for (ResultImpl r : client2Options.values()) {
-                    options.add(r.getOptions());
+        public synchronized String getOptions() {
+            return options;
+        }
+
+        public synchronized String getWorkDirectory() {
+            return workdirDirectory;
+        }
+
+        public boolean setOptions(String options, String workingDirectory) {
+            boolean modified = false;
+            synchronized (this) {
+                if (!Objects.equals(this.options, options)) {
+                    this.options = options;
+                    modified = true;
+                }
+                if (!Objects.equals(this.workdirDirectory, workingDirectory)) {
+                    this.workdirDirectory = workingDirectory;
+                    modified = true;
                 }
             }
-
-            return SourceLauncher.joinCommandLines(options);
+            if (modified) {
+                cs.fireChange();
+            }
+            return modified;
         }
 
-        @Override
         public void addChangeListener(ChangeListener l) {
             cs.addChangeListener(l);
         }
 
-        @Override
         public void removeChangeListener(ChangeListener l) {
             cs.removeChangeListener(l);
         }
 
     }
 
-    public boolean setConfiguration(NbCodeLanguageClient client, String vmOptions) {
-        if (getResult(client).setOptions(vmOptions)) {
-            globalOptions.cs.fireChange();
-            return true;
-        }
-        return false;
+    public boolean setConfiguration(Workspace workspace, String vmOptions, String workDirectory) {
+        return getWorkspaceSettings(workspace).setOptions(vmOptions, workDirectory);
     }
 
-    private synchronized ResultImpl getResult(NbCodeLanguageClient client) {
-        return client2Options.computeIfAbsent(client, cl -> {
-            return new ResultImpl();
+    private synchronized WorkspaceSettings getWorkspaceSettings(Workspace workspace) {
+        Parameters.notNull("workspace", workspace);
+        return workspace2Settings.computeIfAbsent(workspace, w -> {
+            return new WorkspaceSettings();
         });
     }
 
diff --git a/java/java.lsp.server/test/unit/src/org/netbeans/modules/java/lsp/server/singlesourcefile/SingleFileOptionsQueryImplTest.java b/java/java.lsp.server/test/unit/src/org/netbeans/modules/java/lsp/server/singlesourcefile/SingleFileOptionsQueryImplTest.java
new file mode 100644
index 000000000000..4c6d3c812f3a
--- /dev/null
+++ b/java/java.lsp.server/test/unit/src/org/netbeans/modules/java/lsp/server/singlesourcefile/SingleFileOptionsQueryImplTest.java
@@ -0,0 +1,169 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.netbeans.modules.java.lsp.server.singlesourcefile;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
+import org.netbeans.junit.NbTestCase;
+import org.netbeans.modules.java.lsp.server.protocol.Workspace;
+import org.openide.filesystems.FileObject;
+import org.openide.filesystems.FileUtil;
+import org.openide.util.Lookup;
+import org.openide.util.lookup.Lookups;
+import org.openide.util.lookup.ProxyLookup;
+
+public class SingleFileOptionsQueryImplTest extends NbTestCase {
+
+    public SingleFileOptionsQueryImplTest(String name) {
+        super(name);
+    }
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+
+        clearWorkDir();
+    }
+
+    public void testFindWorkspaceFolder() throws Exception {
+        FileObject wd = FileUtil.toFileObject(getWorkDir());
+        FileObject workspace1 = FileUtil.createFolder(wd, "workspace1");
+        FileObject source1 = FileUtil.createData(workspace1, "test/Test.java");
+        FileObject prjRoot = FileUtil.createFolder(wd, "prjRoot");
+        FileObject workspace2 = FileUtil.createFolder(prjRoot, "test2");
+        FileObject source2 = FileUtil.createData(workspace2, "Test.java");
+
+        Workspace workspace = new WorkspaceImpl(Arrays.asList(workspace1, workspace2));
+
+        assertEquals(workspace1, SingleFileOptionsQueryImpl.findWorkspaceFolder(workspace, source1));
+        assertEquals(workspace1, SingleFileOptionsQueryImpl.findWorkspaceFolder(workspace, source1.getParent()));
+        assertEquals(workspace1, SingleFileOptionsQueryImpl.findWorkspaceFolder(workspace, workspace1));
+        assertEquals(workspace2, SingleFileOptionsQueryImpl.findWorkspaceFolder(workspace, source2));
+        assertEquals(workspace2, SingleFileOptionsQueryImpl.findWorkspaceFolder(workspace, source2.getParent()));
+        assertEquals(workspace2, SingleFileOptionsQueryImpl.findWorkspaceFolder(workspace, source2.getParent().getParent()));
+    }
+
+    public void testWorkspaceOptions() throws Exception {
+        FileObject wd = FileUtil.toFileObject(getWorkDir());
+        FileObject workspace1 = FileUtil.createFolder(wd, "workspace1");
+        FileObject source1 = FileUtil.createData(workspace1, "test1/Test.java");
+        FileObject workspace2 = FileUtil.createFolder(wd, "workspace2");
+        FileObject source2 = FileUtil.createData(workspace2, "test2/Test.java");
+        FileObject source3 = FileUtil.createData(wd, "test3/Test.java");
+
+        SingleFileOptionsQueryImpl query = new SingleFileOptionsQueryImpl() {};
+        Workspace workspace = new WorkspaceImpl(Arrays.asList(workspace1, workspace2));
+
+        query.setConfiguration(workspace, "-Dtest=test", null);
+
+        Lookups.executeWith(new ProxyLookup(Lookups.fixed(workspace), Lookup.getDefault()), () -> {
+            assertEquals("-Dtest=test", query.optionsFor(source1).getOptions());
+            assertEquals(workspace1.toURI(), query.optionsFor(source1).getWorkDirectory());
+            assertEquals("-Dtest=test", query.optionsFor(source1.getParent()).getOptions());
+            assertEquals(workspace1.toURI(), query.optionsFor(source1.getParent()).getWorkDirectory());
+
+            assertEquals("-Dtest=test", query.optionsFor(source2).getOptions());
+            assertEquals(workspace2.toURI(), query.optionsFor(source2).getWorkDirectory());
+            assertEquals("-Dtest=test", query.optionsFor(source2.getParent()).getOptions());
+            assertEquals(workspace2.toURI(), query.optionsFor(source2.getParent()).getWorkDirectory());
+
+            AtomicInteger changeCount = new AtomicInteger();
+
+            query.optionsFor(source1).addChangeListener(evt -> changeCount.incrementAndGet());
+
+            query.setConfiguration(workspace, "-Dtest=test", null);
+
+            assertEquals(0, changeCount.get());
+
+            FileObject newWD = source1.getParent();
+
+            query.setConfiguration(workspace, "-Dtest=test", FileUtil.toFile(newWD).getAbsolutePath());
+
+            assertEquals(1, changeCount.get());
+
+            assertEquals("-Dtest=test", query.optionsFor(source1).getOptions());
+            assertEquals(newWD.toURI(), query.optionsFor(source1).getWorkDirectory());
+            assertEquals("-Dtest=test", query.optionsFor(source1.getParent()).getOptions());
+            assertEquals(newWD.toURI(), query.optionsFor(source1.getParent()).getWorkDirectory());
+
+            assertEquals("-Dtest=test", query.optionsFor(source2).getOptions());
+            assertEquals(newWD.toURI(), query.optionsFor(source2).getWorkDirectory());
+            assertEquals("-Dtest=test", query.optionsFor(source2.getParent()).getOptions());
+            assertEquals(newWD.toURI(), query.optionsFor(source2.getParent()).getWorkDirectory());
+
+            query.setConfiguration(workspace, "-Dtest=test2", FileUtil.toFile(newWD).getAbsolutePath());
+
+            assertEquals(2, changeCount.get());
+
+            assertEquals("-Dtest=test2", query.optionsFor(source1).getOptions());
+            assertEquals(newWD.toURI(), query.optionsFor(source1).getWorkDirectory());
+            assertEquals("-Dtest=test2", query.optionsFor(source1.getParent()).getOptions());
+            assertEquals(newWD.toURI(), query.optionsFor(source1.getParent()).getWorkDirectory());
+
+            assertEquals("-Dtest=test2", query.optionsFor(source2).getOptions());
+            assertEquals(newWD.toURI(), query.optionsFor(source2).getWorkDirectory());
+            assertEquals("-Dtest=test2", query.optionsFor(source2.getParent()).getOptions());
+            assertEquals(newWD.toURI(), query.optionsFor(source2.getParent()).getWorkDirectory());
+
+            query.setConfiguration(workspace, "-Dtest=test2", null);
+
+            assertEquals(3, changeCount.get());
+
+            assertEquals("-Dtest=test2", query.optionsFor(source1).getOptions());
+            assertEquals(workspace1.toURI(), query.optionsFor(source1).getWorkDirectory());
+            assertEquals("-Dtest=test2", query.optionsFor(source1.getParent()).getOptions());
+            assertEquals(workspace1.toURI(), query.optionsFor(source1.getParent()).getWorkDirectory());
+
+            assertEquals("-Dtest=test2", query.optionsFor(source2).getOptions());
+            assertEquals(workspace2.toURI(), query.optionsFor(source2).getWorkDirectory());
+            assertEquals("-Dtest=test2", query.optionsFor(source2.getParent()).getOptions());
+            assertEquals(workspace2.toURI(), query.optionsFor(source2.getParent()).getWorkDirectory());
+        });
+
+
+        //with no workspace context:
+        assertEquals("-Dtest=test2", query.optionsFor(source1).getOptions());
+        assertEquals(workspace1.toURI(), query.optionsFor(source1).getWorkDirectory());
+        assertEquals("-Dtest=test2", query.optionsFor(source1.getParent()).getOptions());
+        assertEquals(workspace1.toURI(), query.optionsFor(source1.getParent()).getWorkDirectory());
+
+        assertEquals("-Dtest=test2", query.optionsFor(source2).getOptions());
+        assertEquals(workspace2.toURI(), query.optionsFor(source2).getWorkDirectory());
+        assertEquals("-Dtest=test2", query.optionsFor(source2.getParent()).getOptions());
+        assertEquals(workspace2.toURI(), query.optionsFor(source2.getParent()).getWorkDirectory());
+
+        assertNull(query.optionsFor(source3));
+        assertNull(query.optionsFor(source3.getParent()));
+    }
+
+    private static final class WorkspaceImpl implements Workspace {
+        private final List<FileObject> workspaceFolders;
+
+        public WorkspaceImpl(List<FileObject> workspaceFolders) {
+            this.workspaceFolders = workspaceFolders;
+        }
+
+        @Override
+        public List<FileObject> getClientWorkspaceFolders() {
+            return workspaceFolders;
+        }
+
+    }
+}
diff --git a/java/java.lsp.server/vscode/src/extension.ts b/java/java.lsp.server/vscode/src/extension.ts
index a4fdf4b1e59d..426d2e457e38 100644
--- a/java/java.lsp.server/vscode/src/extension.ts
+++ b/java/java.lsp.server/vscode/src/extension.ts
@@ -1071,7 +1071,8 @@ function doActivateWithJDK(specifiedJDK: string | null, context: ExtensionContex
                 'netbeans.hints',
                 'netbeans.format',
                 'netbeans.java.imports',
-                'java+.runConfig.vmOptions'
+                'java+.runConfig.vmOptions',
+                'java+.runConfig.cwd'
             ],
             fileEvents: [
                 workspace.createFileSystemWatcher('**/*.java')
diff --git a/java/java.source.base/src/org/netbeans/modules/java/source/indexing/APTUtils.java b/java/java.source.base/src/org/netbeans/modules/java/source/indexing/APTUtils.java
index 2aa6f9657cb3..54ec330cbe36 100644
--- a/java/java.source.base/src/org/netbeans/modules/java/source/indexing/APTUtils.java
+++ b/java/java.source.base/src/org/netbeans/modules/java/source/indexing/APTUtils.java
@@ -135,9 +135,6 @@ private APTUtils(@NonNull final FileObject root) {
         this.root = root;
         bootPath = ClassPath.getClassPath(root, ClassPath.BOOT);
         compilePath = ClassPath.getClassPath(root, ClassPath.COMPILE);
-        if (compilePath != null) {
-            compilePath.addPropertyChangeListener(this);
-        }
         processorPath = new AtomicReference<>(ClassPath.getClassPath(root, JavaClassPathConstants.PROCESSOR_PATH));
         processorModulePath = new AtomicReference<>(ClassPath.getClassPath(root, JavaClassPathConstants.MODULE_PROCESSOR_PATH));
         aptOptions = AnnotationProcessingQuery.getAnnotationProcessingOptions(root);
@@ -150,6 +147,9 @@ private APTUtils(@NonNull final FileObject root) {
                     false);
         });
         usedRoots = new UsedRoots(root.toURL());
+        if (compilePath != null) {
+            compilePath.addPropertyChangeListener(this);
+        }
     }
 
     @CheckForNull
