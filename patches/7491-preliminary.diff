diff --git a/java/java.completion/src/org/netbeans/modules/java/completion/BaseTask.java b/java/java.completion/src/org/netbeans/modules/java/completion/BaseTask.java
index 78fdd4caa3..95ae5235c6 100644
--- a/java/java.completion/src/org/netbeans/modules/java/completion/BaseTask.java
+++ b/java/java.completion/src/org/netbeans/modules/java/completion/BaseTask.java
@@ -176,6 +176,7 @@ abstract class BaseTask extends UserTask {
                 case LINE_COMMENT:
                 case BLOCK_COMMENT:
                 case JAVADOC_COMMENT:
+                case JAVADOC_COMMENT_LINE_RUN:
                     break;
                 default:
                     return ts;
@@ -206,6 +207,7 @@ abstract class BaseTask extends UserTask {
                 case LINE_COMMENT:
                 case BLOCK_COMMENT:
                 case JAVADOC_COMMENT:
+                case JAVADOC_COMMENT_LINE_RUN:
                     break;
                 default:
                     return ts;
@@ -427,6 +429,7 @@ abstract class BaseTask extends UserTask {
                                     case LINE_COMMENT:
                                     case BLOCK_COMMENT:
                                     case JAVADOC_COMMENT:
+                                    case JAVADOC_COMMENT_LINE_RUN:
                                         break;
                                     case ARROW:
                                         scope = controller.getTrees().getScope(blockPath);
@@ -456,6 +459,7 @@ abstract class BaseTask extends UserTask {
                             case LINE_COMMENT:
                             case BLOCK_COMMENT:
                             case JAVADOC_COMMENT:
+                            case JAVADOC_COMMENT_LINE_RUN:
                                 break;
                             case ARROW:
                                 return new Env(offset, prefix, controller, path, sourcePositions, scope);
diff --git a/java/java.completion/src/org/netbeans/modules/java/completion/JavaCompletionTask.java b/java/java.completion/src/org/netbeans/modules/java/completion/JavaCompletionTask.java
index 9a2d8de483..2cf8691813 100644
--- a/java/java.completion/src/org/netbeans/modules/java/completion/JavaCompletionTask.java
+++ b/java/java.completion/src/org/netbeans/modules/java/completion/JavaCompletionTask.java
@@ -1611,6 +1611,7 @@ public final class JavaCompletionTask<T> extends BaseTask {
                 case LINE_COMMENT:
                 case BLOCK_COMMENT:
                 case JAVADOC_COMMENT:
+                case JAVADOC_COMMENT_LINE_RUN:
                     break;
                 default:
                     lastNonWhitespaceTokenId = ts.token().id();
diff --git a/java/java.editor.base/src/org/netbeans/modules/java/editor/base/javadoc/JavadocCompletionUtils.java b/java/java.editor.base/src/org/netbeans/modules/java/editor/base/javadoc/JavadocCompletionUtils.java
index a0682653d7..c6f54e77b8 100644
--- a/java/java.editor.base/src/org/netbeans/modules/java/editor/base/javadoc/JavadocCompletionUtils.java
+++ b/java/java.editor.base/src/org/netbeans/modules/java/editor/base/javadoc/JavadocCompletionUtils.java
@@ -51,7 +51,7 @@ import org.netbeans.api.lexer.TokenSequence;
  */
 public final class JavadocCompletionUtils {
     
-    static final Pattern JAVADOC_LINE_BREAK = Pattern.compile("\\n[ \\t]*\\**[ \\t]*\\z"); // NOI18N
+    static final Pattern JAVADOC_LINE_BREAK = Pattern.compile("(\\n[ \\t]*\\**[ \\t]*\\z)|(\\n[ \\t]*///[ \\t]*\\z)"); // NOI18N
     static final Pattern JAVADOC_WHITE_SPACE = Pattern.compile("[^ \\t]"); // NOI18N
     /**
      * javadoc parser considers whatever number of spaces or standalone newline
@@ -62,7 +62,7 @@ public final class JavadocCompletionUtils {
     static final Pattern JAVADOC_EMPTY = Pattern.compile("(\\s*\\**\\s*\n)*\\s*\\**\\s*\\**"); // NOI18N
     static final Pattern JAVADOC_FIRST_WHITE_SPACE = Pattern.compile("[ \\t]*\\**[ \\t]*"); // NOI18N
     private static Set<JavaTokenId> IGNORE_TOKES = EnumSet.of(
-            JavaTokenId.WHITESPACE, JavaTokenId.BLOCK_COMMENT, JavaTokenId.LINE_COMMENT);
+            JavaTokenId.WHITESPACE, JavaTokenId.BLOCK_COMMENT, JavaTokenId.LINE_COMMENT, JavaTokenId.JAVADOC_COMMENT_LINE_RUN);
     private static final Logger LOGGER = Logger.getLogger(JavadocCompletionUtils.class.getName());
     
     /**
@@ -196,6 +196,7 @@ public final class JavadocCompletionUtils {
                         break;
                     }
                 case JAVADOC_COMMENT:
+                case JAVADOC_COMMENT_LINE_RUN:
                     if (token.partType() == PartType.COMPLETE) {
                         return javac.getElements().getDocComment(e) == null
                                 ? null : s.embedded(JavadocTokenId.language());
@@ -246,36 +247,39 @@ public final class JavadocCompletionUtils {
     
     /**
      * Is javadoc line break?
-     * @param token token to test
+     * @param ts a token sequence positioned to the token to test
      * @return {@code true} in case the token is something like {@code "\n\t*"}
      */
-    public static boolean isLineBreak(Token<JavadocTokenId> token) {
-        return isLineBreak(token, token.length());
+    public static boolean isLineBreak(TokenSequence<JavadocTokenId> ts) {
+        return isLineBreak(ts, ts.token().length());
     }
     
     /**
      * Tests if the token part before {@code pos} is a javadoc line break.
-     * @param token a token to test
+     * @param ts a token sequence positioned to the token to test
      * @param pos position in the token
      * @return {@code true} in case the token is something like {@code "\n\t* |\n\t*"}
      */
-    public static boolean isLineBreak(Token<JavadocTokenId> token, int pos) {
+    public static boolean isLineBreak(TokenSequence<JavadocTokenId> ts, int pos) {
+        Token<JavadocTokenId> token = ts.token();
+
         if (token == null || token.id() != JavadocTokenId.OTHER_TEXT) {
-            return false;
+            return ts.isEmpty() || ts.index() == 0;
         }
         try {
             CharSequence text = token.text();
             if (pos < token.length())
                 text = text.subSequence(0, pos);
-            boolean result = pos > 0
+            boolean result = (pos > 0
                     && JAVADOC_LINE_BREAK.matcher(text).find()
-                    && (pos == token.length() || !isInsideIndent(token, pos));
+                    && (pos == token.length() || !isInsideIndent(token, pos))
+                    ) || ts.index() == 0;
             return result;
         } catch (IndexOutOfBoundsException e) {
             throw (IndexOutOfBoundsException) new IndexOutOfBoundsException("pos: " + pos + ", token.length: " + token.length() + ", token text: " + token.text()).initCause(e);
         }
     }
-    
+
     public static boolean isWhiteSpace(CharSequence text) {
         return text != null && text.length() > 0 && !JAVADOC_WHITE_SPACE.matcher(text).find();
     }
@@ -437,7 +441,8 @@ public final class JavadocCompletionUtils {
             return false;
         }
         
-        if (ts.token().id() != JavaTokenId.JAVADOC_COMMENT) {
+        if (ts.token().id() != JavaTokenId.JAVADOC_COMMENT &&
+            ts.token().id() != JavaTokenId.JAVADOC_COMMENT_LINE_RUN) {
             return false;
         }
         
@@ -456,6 +461,11 @@ public final class JavadocCompletionUtils {
             // check special case /**|*/
             return offset == 3 && "/***/".contentEquals(text); //NOI18N
         }
+        if (token != null && token.id() == JavaTokenId.JAVADOC_COMMENT_LINE_RUN) {
+            CharSequence text = token.text();
+            // check special case ///|\n
+            return offset == 3 && "///\n".contentEquals(text); //NOI18N
+        }
         return false;
     }
 
diff --git a/java/java.editor.base/src/org/netbeans/modules/java/editor/base/javadoc/JavadocImports.java b/java/java.editor.base/src/org/netbeans/modules/java/editor/base/javadoc/JavadocImports.java
index 07ccd639c0..2d91d7065f 100644
--- a/java/java.editor.base/src/org/netbeans/modules/java/editor/base/javadoc/JavadocImports.java
+++ b/java/java.editor.base/src/org/netbeans/modules/java/editor/base/javadoc/JavadocImports.java
@@ -641,7 +641,7 @@ public final class JavadocImports {
                         }
                     case OTHER_TEXT:
                         isBeforeWS |= JavadocCompletionUtils.isWhiteSpace(jdt);
-                        isBeforeWS |= JavadocCompletionUtils.isLineBreak(jdt);
+                        isBeforeWS |= JavadocCompletionUtils.isLineBreak(jdts);
                         if (isBeforeWS) {
                             continue;
                         } else {
@@ -690,7 +690,9 @@ public final class JavadocImports {
         TokenSequence<JavadocTokenId> javadoc = null;
         TokenSequence<JavaTokenId> ts = SourceUtils.getJavaTokenSequence(javac.getTokenHierarchy(), start);
 
-        if (ts.moveNext() && ts.token().id() == JavaTokenId.JAVADOC_COMMENT) {
+        if (ts.moveNext() &&
+            (ts.token().id() == JavaTokenId.JAVADOC_COMMENT ||
+             ts.token().id() == JavaTokenId.JAVADOC_COMMENT_LINE_RUN)) {
             javadoc = ts.embedded(JavadocTokenId.language());
         }
         
@@ -893,14 +895,14 @@ public final class JavadocImports {
             cs = pos < cs.length() ? cs.subSequence(0, pos) : cs;
 
             if (JavadocCompletionUtils.isWhiteSpace(cs)
-                    || JavadocCompletionUtils.isLineBreak(jdts.token(), pos)) {
+                    || JavadocCompletionUtils.isLineBreak(jdts, pos)) {
                 noPrefix = true;
             } else {
                 // broken syntax
                 return;
             }
         } else if (!(JavadocCompletionUtils.isWhiteSpace(jdts.token())
-                || JavadocCompletionUtils.isLineBreak(jdts.token()))) {
+                || JavadocCompletionUtils.isLineBreak(jdts))) {
             // not java reference
             return;
         } else if (jdts.moveNext()) {
diff --git a/java/java.editor.base/test/unit/src/org/netbeans/modules/java/editor/base/javadoc/JavadocCompletionUtilsTest.java b/java/java.editor.base/test/unit/src/org/netbeans/modules/java/editor/base/javadoc/JavadocCompletionUtilsTest.java
index add1ca7dc2..33926dc0b4 100644
--- a/java/java.editor.base/test/unit/src/org/netbeans/modules/java/editor/base/javadoc/JavadocCompletionUtilsTest.java
+++ b/java/java.editor.base/test/unit/src/org/netbeans/modules/java/editor/base/javadoc/JavadocCompletionUtilsTest.java
@@ -270,32 +270,32 @@ public class JavadocCompletionUtilsTest extends JavadocTestSupport {
         TokenSequence<JavadocTokenId> jdts = JavadocCompletionUtils.findJavadocTokenSequence(info, offset);
         assertTrue(jdts.moveNext());
         assertTrue(insertPointer(code, offset),
-                JavadocCompletionUtils.isLineBreak(jdts.token()));
+                JavadocCompletionUtils.isLineBreak(jdts));
         offset += 1;
         jdts = JavadocCompletionUtils.findJavadocTokenSequence(info, offset);
         assertTrue(jdts.moveNext());
         // token is INDENT
         assertFalse(insertPointer(code, offset),
-                JavadocCompletionUtils.isLineBreak(jdts.token()));
+                JavadocCompletionUtils.isLineBreak(jdts));
         
         what = "  \n";
         offset = code.indexOf(what);
         jdts = JavadocCompletionUtils.findJavadocTokenSequence(info, offset);
         assertTrue(jdts.moveNext());
         assertTrue(insertPointer(code, offset),
-                JavadocCompletionUtils.isLineBreak(jdts.token(), offset - jdts.offset()));
+                JavadocCompletionUtils.isLineBreak(jdts, offset - jdts.offset()));
         
         what = "  * {*i";
         offset = code.indexOf(what) + what.length() - 3;
         jdts = JavadocCompletionUtils.findJavadocTokenSequence(info, offset);
         assertTrue(jdts.moveNext());
         assertFalse(insertPointer(code, offset),
-                JavadocCompletionUtils.isLineBreak(jdts.token()));
+                JavadocCompletionUtils.isLineBreak(jdts));
         assertTrue(insertPointer(code, offset),
-                JavadocCompletionUtils.isLineBreak(jdts.token(), offset - jdts.offset()));
+                JavadocCompletionUtils.isLineBreak(jdts, offset - jdts.offset()));
         offset = code.indexOf(what);
         assertFalse(insertPointer(code, offset),
-                JavadocCompletionUtils.isLineBreak(jdts.token(), offset - jdts.offset()));
+                JavadocCompletionUtils.isLineBreak(jdts, offset - jdts.offset()));
     }
     
     public void testIsLineBreak2() throws Exception {
@@ -319,10 +319,10 @@ public class JavadocCompletionUtilsTest extends JavadocTestSupport {
         assertTrue(jdts.moveNext());
         assertTrue(jdts.token().id() == JavadocTokenId.OTHER_TEXT);
         assertFalse(insertPointer(code, jdts.offset() + jdts.token().length()),
-                JavadocCompletionUtils.isLineBreak(jdts.token()));
+                JavadocCompletionUtils.isLineBreak(jdts));
         // test OTHER_TEXT('     * |{')
         assertTrue(insertPointer(code, jdts.offset() + jdts.token().length() - 1),
-                JavadocCompletionUtils.isLineBreak(jdts.token(), jdts.token().length() - 1));
+                JavadocCompletionUtils.isLineBreak(jdts, jdts.token().length() - 1));
     }
     
     public void testIsWhiteSpace() throws Exception {
diff --git a/java/java.editor.base/test/unit/src/org/netbeans/modules/java/editor/base/javadoc/JavadocImportsTest.java b/java/java.editor.base/test/unit/src/org/netbeans/modules/java/editor/base/javadoc/JavadocImportsTest.java
index e64ec4698b..88443c53d7 100644
--- a/java/java.editor.base/test/unit/src/org/netbeans/modules/java/editor/base/javadoc/JavadocImportsTest.java
+++ b/java/java.editor.base/test/unit/src/org/netbeans/modules/java/editor/base/javadoc/JavadocImportsTest.java
@@ -207,6 +207,122 @@ public class JavadocImportsTest extends JavadocTestSupport {
         assertEquals(exp, sortedResult);
     }
     
+    public void testComputeReferencedElementsMarkdown() throws Exception {
+        String code =
+                "package p;\n" +
+                "import java.io.IOException;\n" +
+                "import java.util.Collections;\n" +
+                "import java.util.List;\n" +
+                "class C {\n" +
+                "   ///link1 {@link Runnable}\n" +
+                "   ///link3 {@linkplain Collections#binarySearch(java.util.List, Object) search}\n" +
+                "   ///{@link java. uncomplete reference}\n" +
+//                "   ///unclosed link {@value Math#PI\n" + //TODO: does not work
+                "   ///unclosed link {@value Math#PI}\n" +
+                "   ///@see List\n" +
+                "   ///@throws IOException\n" +
+                "   void m() throws java.io.IOException {\n" +
+                "   }\n" +
+                "   ///\n" +
+                "   ///{@link Collections}\n" +
+                "   ///\n" +
+                "   int field;\n" +
+                "   /// {@link IOException\n" +
+                "   interface InnerInterface {}\n" +
+                "   /// {@link Collections}\n" +
+                "   @interface InnerAnnotationType {}\n" +
+                "}\n" +
+                "/// {@link Collections}\n" +
+                "enum TopLevelEnum {\n" +
+                "   /** {@link Collections} */" +
+                "   E1\n" +
+                "}\n";
+        prepareTest(code);
+
+        // C.m()
+        TreePath member = findPath(code, "m() throws");
+        assertNotNull(member);
+        List <TypeElement> exp = Arrays.asList(
+                info.getElements().getTypeElement("java.lang.Runnable"),
+                info.getElements().getTypeElement("java.lang.Math"),
+                info.getElements().getTypeElement("java.lang.Object"),
+                info.getElements().getTypeElement("java.util.Collections"),
+                info.getElements().getTypeElement("java.util.List"),
+                info.getElements().getTypeElement("java.io.IOException")
+                );
+        Collections.<TypeElement>sort(exp, new ElementComparator());
+        Set<TypeElement> result = JavadocImports.computeReferencedElements(info, member);
+        assertNotNull(result);
+        List<TypeElement> sortedResult = new ArrayList<TypeElement>(result);
+        sortedResult.sort(new ElementComparator());
+        assertEquals(exp, sortedResult);
+
+        // C.field
+        member = findPath(code, "field;");
+        assertNotNull(member);
+        exp = Arrays.asList(
+                info.getElements().getTypeElement("java.util.Collections")
+                );
+        Collections.<TypeElement>sort(exp, new ElementComparator());
+        result = JavadocImports.computeReferencedElements(info, member);
+        assertNotNull(result);
+        sortedResult = new ArrayList<TypeElement>(result);
+        sortedResult.sort(new ElementComparator());
+        assertEquals(exp, sortedResult);
+
+        // C.InnerInterface
+        member = findPath(code, "InnerInterface {");
+        assertNotNull(member);
+        exp = Arrays.asList(
+                info.getElements().getTypeElement("java.io.IOException")
+                );
+        Collections.<TypeElement>sort(exp, new ElementComparator());
+        result = JavadocImports.computeReferencedElements(info, member);
+        assertNotNull(result);
+        sortedResult = new ArrayList<TypeElement>(result);
+        sortedResult.sort(new ElementComparator());
+        assertEquals(exp, sortedResult);
+
+        // C.InnerAnnotationType
+        member = findPath(code, "InnerAnnotationType {");
+        assertNotNull(member);
+        exp = Arrays.asList(
+                info.getElements().getTypeElement("java.util.Collections")
+                );
+        Collections.<TypeElement>sort(exp, new ElementComparator());
+        result = JavadocImports.computeReferencedElements(info, member);
+        assertNotNull(result);
+        sortedResult = new ArrayList<TypeElement>(result);
+        sortedResult.sort(new ElementComparator());
+        assertEquals(exp, sortedResult);
+
+        // TopLevelEnum
+        member = findPath(code, "TopLevelEnum {");
+        assertNotNull(member);
+        exp = Arrays.asList(
+                info.getElements().getTypeElement("java.util.Collections")
+                );
+        Collections.<TypeElement>sort(exp, new ElementComparator());
+        result = JavadocImports.computeReferencedElements(info, member);
+        assertNotNull(result);
+        sortedResult = new ArrayList<TypeElement>(result);
+        sortedResult.sort(new ElementComparator());
+        assertEquals(exp, sortedResult);
+
+        // TopLevelEnum.E1
+        member = findPath(code, "E1\n");
+        assertNotNull(member);
+        exp = Arrays.asList(
+                info.getElements().getTypeElement("java.util.Collections")
+                );
+        Collections.<TypeElement>sort(exp, new ElementComparator());
+        result = JavadocImports.computeReferencedElements(info, member);
+        assertNotNull(result);
+        sortedResult = new ArrayList<TypeElement>(result);
+        sortedResult.sort(new ElementComparator());
+        assertEquals(exp, sortedResult);
+    }
+
     public void testComputeTokensOfReferencedElements() throws Exception {
         String code = 
                 "package p;\n" +
@@ -286,6 +402,85 @@ public class JavadocImportsTest extends JavadocTestSupport {
 //        assertEquals(toFind.toString(), exp, tokens);
     }
 
+    public void testComputeTokensOfReferencedElementsMarkdown() throws Exception {
+        String code =
+                "package p;\n" +
+                "import java.util.Collections;\n" +
+                "class C {\n" +
+                "   ///link1 {@link Runnable}\n" +
+                "   ///link2 {@link Collections#binarySearch(java.util.List, java.lang.Object) search}\n" +
+                "   ///{@link java. uncomplete reference}" +
+//                "   ///unclosed link {@value Math#PI\n" + //TODO: does not work
+                "   ///unclosed link {@value Math#PI}\n" +
+                "   ///@see java.util.Collections\n" +
+                "   ///@throws ThrowsUnresolved\n" +
+                "   ///\n" +
+                "   void m() throws java.io.IOException {\n" +
+                "       Collections.<String>binarySearch(Collections.<String>emptyList(), \"\");\n" +
+                "       double pi = Math.PI;\n" +
+                "   }\n" +
+                "}\n";
+        prepareTest(code);
+
+        TreePath where = findPath(code, "m() throws");
+        assertNotNull(where);
+        TokenSequence<JavadocTokenId> jdts = JavadocCompletionUtils.findJavadocTokenSequence(info, null, info.getTrees().getElement(where));
+        assertNotNull(jdts);
+        List<Token> exp;
+
+        // toFind java.lang.Runnable
+        Element toFind = info.getElements().getTypeElement("java.lang.Runnable");
+        assertNotNull(toFind);
+        List<Token> tokens = JavadocImports.computeTokensOfReferencedElements(info, where, toFind);
+        assertNotNull(toFind.toString(), tokens);
+        jdts.move(code.indexOf("Runnable", code.indexOf("link1")));
+        assertTrue(jdts.moveNext());
+        exp = Arrays.<Token>asList(jdts.token());
+        assertEquals(toFind.toString(), exp, tokens);
+
+        // toFind java.util.Collections
+        toFind = info.getElements().getTypeElement("java.util.Collections");
+        assertNotNull(toFind);
+        tokens = JavadocImports.computeTokensOfReferencedElements(info, where, toFind);
+        assertNotNull(toFind.toString(), tokens);
+        exp = new ArrayList<Token>();
+        jdts.move(code.indexOf("Collections", code.indexOf("link2")));
+        assertTrue(jdts.moveNext());
+        exp.add(jdts.token());
+        jdts.move(code.indexOf("Collections", code.indexOf("///@see")));
+        assertTrue(jdts.moveNext());
+        exp.add(jdts.token());
+        System.err.println("exp:");
+        for (Token e : exp) {
+            System.err.println(e.text());
+        }
+        System.err.println("tokens:");
+        for (Token e : tokens) {
+            System.err.println(e.text());
+        }
+        assertEquals(toFind.toString(), exp, tokens);
+
+        // toFind Math#PI
+        toFind = findElement(code, "PI;\n");
+        assertNotNull(toFind);
+        tokens = JavadocImports.computeTokensOfReferencedElements(info, where, toFind);
+        assertNotNull(toFind.toString(), tokens);
+        jdts.move(code.indexOf("PI", code.indexOf("unclosed link")));
+        assertTrue(jdts.moveNext());
+        exp = Arrays.<Token>asList(jdts.token());
+        assertEquals(toFind.toString(), exp, tokens);
+
+        // toFind Collections#binarySearch
+        toFind = findElement(code, "binarySearch(Collections.<String>emptyList()");
+        assertNotNull(toFind);
+        tokens = JavadocImports.computeTokensOfReferencedElements(info, where, toFind);
+        assertNotNull(toFind.toString(), tokens);
+        jdts.move(code.indexOf("binarySearch", code.indexOf("link2")));
+        assertTrue(jdts.moveNext());
+        exp = Arrays.<Token>asList(jdts.token());
+//        assertEquals(toFind.toString(), exp, tokens);
+    }
+
     public void testComputeTokensOfReferencedElementsForParams() throws Exception {
         String code =
                 "package p;\n" +
diff --git a/java/java.editor/src/org/netbeans/modules/editor/java/GoToSupport.java b/java/java.editor/src/org/netbeans/modules/editor/java/GoToSupport.java
index 8a60126a72..3e8b08e4e7 100644
--- a/java/java.editor/src/org/netbeans/modules/editor/java/GoToSupport.java
+++ b/java/java.editor/src/org/netbeans/modules/editor/java/GoToSupport.java
@@ -408,7 +408,7 @@ public class GoToSupport {
         boolean insideImportStmt = false;
         TreePath path = controller.getTreeUtilities().pathFor(exactOffset);
 
-        if (token[0] != null && token[0].id() == JavaTokenId.JAVADOC_COMMENT) {
+        if (token[0] != null && (token[0].id() == JavaTokenId.JAVADOC_COMMENT || token[0].id() == JavaTokenId.JAVADOC_COMMENT_LINE_RUN)) {
             el = JavadocImports.findReferencedElement(controller, offset);
         } else {
             path = adjustPathForModuleName(path);
@@ -662,7 +662,7 @@ public class GoToSupport {
 
                 Token<JavaTokenId> t = ts.token();
 
-                if (JavaTokenId.JAVADOC_COMMENT == t.id()) {
+                if (JavaTokenId.JAVADOC_COMMENT == t.id() || JavaTokenId.JAVADOC_COMMENT_LINE_RUN == t.id()) {
                     // javadoc hyperlinking (references + param names)
                     TokenSequence<JavadocTokenId> jdts = ts.embedded(JavadocTokenId.language());
                     if (JavadocImports.isInsideReference(jdts, offset) || JavadocImports.isInsideParamName(jdts, offset)) {
diff --git a/java/java.editor/src/org/netbeans/modules/editor/java/JavaCompletionCollector.java b/java/java.editor/src/org/netbeans/modules/editor/java/JavaCompletionCollector.java
index 91c22e9338..6c86a21dd3 100644
--- a/java/java.editor/src/org/netbeans/modules/editor/java/JavaCompletionCollector.java
+++ b/java/java.editor/src/org/netbeans/modules/editor/java/JavaCompletionCollector.java
@@ -1318,6 +1318,7 @@ public class JavaCompletionCollector implements CompletionCollector {
                     case LINE_COMMENT:
                     case BLOCK_COMMENT:
                     case JAVADOC_COMMENT:
+                    case JAVADOC_COMMENT_LINE_RUN:
                         break;
                     default:
                         return ts;
diff --git a/java/java.editor/src/org/netbeans/modules/editor/java/JavaCompletionItem.java b/java/java.editor/src/org/netbeans/modules/editor/java/JavaCompletionItem.java
index 733ba9ad32..47fbd2803f 100644
--- a/java/java.editor/src/org/netbeans/modules/editor/java/JavaCompletionItem.java
+++ b/java/java.editor/src/org/netbeans/modules/editor/java/JavaCompletionItem.java
@@ -4617,6 +4617,7 @@ public abstract class JavaCompletionItem implements CompletionItem {
                 case LINE_COMMENT:
                 case BLOCK_COMMENT:
                 case JAVADOC_COMMENT:
+                case JAVADOC_COMMENT_LINE_RUN:
                     break;
                 default:
                     return ts;
diff --git a/java/java.editor/src/org/netbeans/modules/editor/java/JavaKit.java b/java/java.editor/src/org/netbeans/modules/editor/java/JavaKit.java
index 5ac389c224..adefaee33d 100644
--- a/java/java.editor/src/org/netbeans/modules/editor/java/JavaKit.java
+++ b/java/java.editor/src/org/netbeans/modules/editor/java/JavaKit.java
@@ -458,6 +458,7 @@ public class JavaKit extends NbEditorKit {
                 if (isJavadocTouched) {
                     blockCommentComplete(doc, dotPos, context);
                 }
+                TypingCompletion.javadocLineRunCompletion(context);
             }
         }
 
diff --git a/java/java.editor/src/org/netbeans/modules/editor/java/TypingCompletion.java b/java/java.editor/src/org/netbeans/modules/editor/java/TypingCompletion.java
index 5f2172b49d..0682f52f5f 100644
--- a/java/java.editor/src/org/netbeans/modules/editor/java/TypingCompletion.java
+++ b/java/java.editor/src/org/netbeans/modules/editor/java/TypingCompletion.java
@@ -563,6 +563,21 @@ class TypingCompletion {
         return false;
     }
 
+    static boolean javadocLineRunCompletion(TypedBreakInterceptor.MutableContext context) {
+        TokenSequence<JavaTokenId> ts = javaTokenSequence(context, false);
+        if (ts == null) {
+            return false;
+        }
+        int dotPosition = context.getCaretOffset();
+        ts.move(dotPosition);
+        if (!((ts.moveNext() || ts.movePrevious()) && ts.token().id() == JavaTokenId.JAVADOC_COMMENT_LINE_RUN)) {
+            return false;
+        }
+        context.setText("\n///", -1, 4, 0, 4);
+
+        return false;
+    }
+
     private static boolean isAtRowEnd(CharSequence txt, int pos) {
         int length = txt.length();
         for (int i = pos; i < length; i++) {
diff --git a/java/java.editor/src/org/netbeans/modules/editor/java/Utilities.java b/java/java.editor/src/org/netbeans/modules/editor/java/Utilities.java
index da31e094c5..6ccb51a51e 100644
--- a/java/java.editor/src/org/netbeans/modules/editor/java/Utilities.java
+++ b/java/java.editor/src/org/netbeans/modules/editor/java/Utilities.java
@@ -288,6 +288,7 @@ public final class Utilities {
             case INVALID_COMMENT_END:
             case JAVADOC_COMMENT:
             case LINE_COMMENT:
+            case JAVADOC_COMMENT_LINE_RUN:
             case BLOCK_COMMENT:
                 return false;
             case STRING_LITERAL:
diff --git a/java/java.editor/src/org/netbeans/modules/java/editor/javadoc/JavadocCompletionTask.java b/java/java.editor/src/org/netbeans/modules/java/editor/javadoc/JavadocCompletionTask.java
index eac6a5607c..c328d4ae41 100644
--- a/java/java.editor/src/org/netbeans/modules/java/editor/javadoc/JavadocCompletionTask.java
+++ b/java/java.editor/src/org/netbeans/modules/java/editor/javadoc/JavadocCompletionTask.java
@@ -64,6 +64,7 @@ import javax.lang.model.util.Types;
 import javax.swing.text.Document;
 import org.netbeans.api.annotations.common.NonNull;
 import org.netbeans.api.annotations.common.NullAllowed;
+import org.netbeans.api.java.lexer.JavaTokenId;
 import org.netbeans.api.java.lexer.JavadocTokenId;
 import org.netbeans.api.java.source.ClassIndex;
 import org.netbeans.api.java.source.ClasspathInfo;
@@ -84,6 +85,7 @@ import org.netbeans.modules.parsing.api.ResultIterator;
 import org.netbeans.modules.parsing.api.Source;
 import org.netbeans.modules.parsing.api.UserTask;
 import org.netbeans.modules.parsing.spi.Parser;
+import org.openide.util.Pair;
 
 public class JavadocCompletionTask<T> extends UserTask {
 
@@ -188,16 +190,20 @@ public class JavadocCompletionTask<T> extends UserTask {
             return;
         }
         jdts.move(this.caretOffset);
+        JavadocTokenId javadocId;
         if (!jdts.moveNext() && !jdts.movePrevious()) {
             // XXX solve /***/
             // provide block tags, inline tags, html
-            return;
-        }
-        if (this.caretOffset - jdts.offset() == 0) {
-            // if position in token == 0 resolve CC according to previous token
-            jdts.movePrevious();
+            // XXX: for Markdown, continuing
+            javadocId = JavadocTokenId.OTHER_TEXT;
+        } else {
+            if (this.caretOffset - jdts.offset() == 0) {
+                // if position in token == 0 resolve CC according to previous token
+                jdts.movePrevious();
+            }
+            javadocId = jdts.token().id();
         }
-        switch (jdts.token().id()) {
+        switch (javadocId) {
             case TAG:
                 resolveTagToken(jdctx);
                 break;
@@ -265,7 +271,9 @@ public class JavadocCompletionTask<T> extends UserTask {
 
     private int skipWhitespacesBackwards(final JavadocContext jdctx, final int offset) {
         if (jdctx.jdts.move(offset) == 0 || !jdctx.jdts.moveNext()) {
-            jdctx.jdts.movePrevious();
+            if (!jdctx.jdts.movePrevious()) {
+                return offset;
+            }
         }
         do {
             Token t = jdctx.jdts.token();
@@ -415,13 +423,13 @@ public class JavadocCompletionTask<T> extends UserTask {
             int pos = caretOffset - jdts.offset();
             CharSequence cs = jdts.token().text();
             cs = pos < cs.length() ? cs.subSequence(0, pos) : cs;
-            if (JavadocCompletionUtils.isWhiteSpace(cs) || JavadocCompletionUtils.isLineBreak(jdts.token(), pos)) {
+            if (JavadocCompletionUtils.isWhiteSpace(cs) || JavadocCompletionUtils.isLineBreak(jdts, pos)) {
                 noPrefix = true;
             } else {
                 // broken syntax
                 return;
             }
-        } else if (!(JavadocCompletionUtils.isWhiteSpace(jdts.token()) || JavadocCompletionUtils.isLineBreak(jdts.token()))) {
+        } else if (!(JavadocCompletionUtils.isWhiteSpace(jdts.token()) || JavadocCompletionUtils.isLineBreak(jdts))) {
             // not java reference
             return;
         } else if (jdts.moveNext()) {
@@ -519,7 +527,7 @@ public class JavadocCompletionTask<T> extends UserTask {
             int pos = caretOffset - jdts.offset();
             CharSequence cs = jdts.token().text();
             cs = pos < cs.length() ? cs.subSequence(0, pos) : cs;
-            if (JavadocCompletionUtils.isWhiteSpace(cs) || JavadocCompletionUtils.isLineBreak(jdts.token(), pos)) {
+            if (JavadocCompletionUtils.isWhiteSpace(cs) || JavadocCompletionUtils.isLineBreak(jdts, pos)) {
                 // none prefix
                 anchorOffset = caretOffset;
                 completeParamName(tag, "", caretOffset, jdctx); // NOI18N
@@ -1226,11 +1234,10 @@ public class JavadocCompletionTask<T> extends UserTask {
 
     void resolveOtherText(JavadocContext jdctx, TokenSequence<JavadocTokenId> jdts) {
         Token<JavadocTokenId> token = jdts.token();
-        assert token != null;
-        assert token.id() == JavadocTokenId.OTHER_TEXT;
-        CharSequence text = token.text();
-        int pos = caretOffset - jdts.offset();
-        DocTreePath tag = getTag(jdctx, caretOffset);
+        assert token == null || token.id() == JavadocTokenId.OTHER_TEXT;
+        CharSequence text = token == null ? "" : token.text();
+        int pos = token == null ? 0 : caretOffset - jdts.offset();
+        DocTreePath tag = token == null ? null : getTag(jdctx, caretOffset);
 
         if (pos > 0 && pos <= text.length() && text.charAt(pos - 1) == '{') {
             if (tag != null && !JavadocCompletionUtils.isBlockTag(tag)) {
@@ -1244,10 +1251,10 @@ public class JavadocCompletionTask<T> extends UserTask {
         }
         if (tag != null) {
             insideTag(tag, jdctx);
-            if (JavadocCompletionUtils.isBlockTag(tag) && JavadocCompletionUtils.isLineBreak(token, pos)) {
+            if (JavadocCompletionUtils.isBlockTag(tag) && JavadocCompletionUtils.isLineBreak(jdts, pos)) {
                 resolveBlockTag(null, jdctx);
             }
-        } else if (JavadocCompletionUtils.isLineBreak(token, pos)) {
+        } else if (JavadocCompletionUtils.isLineBreak(jdts, pos)) {
             resolveBlockTag(null, jdctx);
         }
     }
@@ -1336,6 +1343,7 @@ public class JavadocCompletionTask<T> extends UserTask {
         private DocCommentTree comment;
         private DocSourcePositions positions;
         private TokenSequence<JavadocTokenId> jdts;
+        private TokenSequence<JavaTokenId> javats;
         private Document doc;
         private ReferencesCount count;
         private TreePath javadocFor;
diff --git a/java/java.editor/test/unit/src/org/netbeans/modules/editor/java/GoToSupportTest.java b/java/java.editor/test/unit/src/org/netbeans/modules/editor/java/GoToSupportTest.java
index 8deac6817b..5e143d4358 100644
--- a/java/java.editor/test/unit/src/org/netbeans/modules/editor/java/GoToSupportTest.java
+++ b/java/java.editor/test/unit/src/org/netbeans/modules/editor/java/GoToSupportTest.java
@@ -1145,6 +1145,67 @@ public class GoToSupportTest extends NbTestCase {
         assertEquals("<html><body>java.lang.String <b>str</b>", tooltip);
     }
 
+    public void testJavadoc() throws Exception {
+        final boolean[] wasCalled = new boolean[1];
+        final String code = "package test;\n" +
+                      "/**\n" +
+                      " * @see Obj|ect\n" +
+                      " */\n" +
+                      "public class Test {\n" +
+                      "}\n";
+
+        performTest(code, new UiUtilsCaller() {
+            @Override public boolean open(FileObject fo, int pos) {
+                fail("Should not be called.");
+                return true;
+            }
+
+            @Override public void beep(boolean goToSource, boolean goToJavadoc) {
+                fail("Should not be called.");
+            }
+            @Override public boolean open(ClasspathInfo info, ElementHandle<?> el, String fileName) {
+                assertEquals("java.lang.Object", el.getBinaryName());
+                wasCalled[0] = true;
+                return true;
+            }
+            @Override public void warnCannotOpen(String displayName) {
+                fail("Should not be called.");
+            }
+        }, false, false);
+
+        assertTrue(wasCalled[0]);
+    }
+
+    public void testMarkdownJavadoc() throws Exception {
+        final boolean[] wasCalled = new boolean[1];
+        this.sourceLevel = "23";
+        final String code = "package test;\n" +
+                      "///@see Obj|ect\n" +
+                      "public class Test {\n" +
+                      "}\n";
+
+        performTest(code, new UiUtilsCaller() {
+            @Override public boolean open(FileObject fo, int pos) {
+                fail("Should not be called.");
+                return true;
+            }
+
+            @Override public void beep(boolean goToSource, boolean goToJavadoc) {
+                fail("Should not be called.");
+            }
+            @Override public boolean open(ClasspathInfo info, ElementHandle<?> el, String fileName) {
+                assertEquals("java.lang.Object", el.getBinaryName());
+                wasCalled[0] = true;
+                return true;
+            }
+            @Override public void warnCannotOpen(String displayName) {
+                fail("Should not be called.");
+            }
+        }, false, false);
+
+        assertTrue(wasCalled[0]);
+    }
+
     private String sourceLevel = "1.5";
     private FileObject source;
 
diff --git a/java/java.editor/test/unit/src/org/netbeans/modules/editor/java/TypingCompletionUnitTest.java b/java/java.editor/test/unit/src/org/netbeans/modules/editor/java/TypingCompletionUnitTest.java
index a0713d608f..0525fc6a68 100644
--- a/java/java.editor/test/unit/src/org/netbeans/modules/editor/java/TypingCompletionUnitTest.java
+++ b/java/java.editor/test/unit/src/org/netbeans/modules/editor/java/TypingCompletionUnitTest.java
@@ -1419,6 +1419,21 @@ public void testPositionInTextBlock() throws Exception {
         ctx.assertDocumentTextEquals("{");
     }
 
+    public void testJavadocLineRun() {
+        Context ctx = new Context(new JavaKit(),
+                "class Test {\n" +
+                "    ///|\n" +
+                "}\n"
+        );
+        ctx.typeChar('\n');
+        ctx.assertDocumentTextEquals(
+                "class Test {\n" +
+                "    ///\n" +
+                "    ///|\n" +
+                "}\n"
+        );
+    }
+
     private boolean isInsideString(String code) throws BadLocationException {
         int pos = code.indexOf('|');
 
diff --git a/java/java.editor/test/unit/src/org/netbeans/modules/java/editor/javadoc/JavadocCompletionQueryTest.java b/java/java.editor/test/unit/src/org/netbeans/modules/java/editor/javadoc/JavadocCompletionQueryTest.java
index 8bf90d619f..884aba40be 100644
--- a/java/java.editor/test/unit/src/org/netbeans/modules/java/editor/javadoc/JavadocCompletionQueryTest.java
+++ b/java/java.editor/test/unit/src/org/netbeans/modules/java/editor/javadoc/JavadocCompletionQueryTest.java
@@ -23,10 +23,14 @@ import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
+import javax.swing.event.ChangeListener;
 import org.netbeans.junit.NbTestSuite;
 import org.netbeans.spi.editor.completion.CompletionItem;
 import org.netbeans.spi.editor.completion.CompletionProvider;
 import org.netbeans.modules.java.editor.base.javadoc.JavadocTestSupport;
+import org.netbeans.spi.java.queries.SourceLevelQueryImplementation2;
+import org.openide.filesystems.FileObject;
+import org.openide.util.lookup.ServiceProvider;
 
 /**
  *
@@ -601,8 +605,212 @@ public class JavadocCompletionQueryTest extends JavadocTestSupport {
                 "}\n";
         performCompletionTest(code, "@summary:");
     }    
-    
-    
+
+    public void testBlockTagsCompletionInMarkdown() throws Exception {
+        String code =
+                "package p;\n" +
+                "class Clazz {\n" +
+                "    ///\n" +
+                "    /// |\n" +
+                "    ///\n" +
+                "    void method(int p1, int p2) {\n" +
+                "    }\n" +
+                "}\n";
+
+        performCompletionTest(code, "@deprecated:", "@exception:", "@hidden:", "@param:", "@return:", "@see:", "@serialData:", "@since:", "@throws:");
+    }
+
+    public void testBlockTagsCompletionInMarkdown2() throws Exception {
+        String code =
+                "package p;\n" +
+                "class Clazz {\n" +
+                "    ///\n" +
+                "    ///|\n" +
+                "    ///\n" +
+                "    void method(int p1, int p2) {\n" +
+                "    }\n" +
+                "}\n";
+
+        performCompletionTest(code, "@deprecated:", "@exception:", "@hidden:", "@param:", "@return:", "@see:", "@serialData:", "@since:", "@throws:");
+    }
+
+    public void testBlockTagsCompletionInMarkdown3() throws Exception {
+        String code =
+                "package p;\n" +
+                "class Clazz {\n" +
+                "    ///\n" +
+                "    ///| \n" +
+                "    ///\n" +
+                "    void method(int p1, int p2) {\n" +
+                "    }\n" +
+                "}\n";
+
+        performCompletionTest(code, "@deprecated:", "@exception:", "@hidden:", "@param:", "@return:", "@see:", "@serialData:", "@since:", "@throws:");
+    }
+
+    public void XXX_testBlockTagsCompletionInMarkdownStart() throws Exception {
+        String code =
+                "package p;\n" +
+                "class Clazz {\n" +
+                "    ///|\n" +
+                "    void method(int p1, int p2) {\n" +
+                "    }\n" +
+                "}\n";
+
+        performCompletionTest(code, "@deprecated:", "@exception:", "@hidden:", "@param:", "@return:", "@see:", "@serialData:", "@since:", "@throws:");
+    }
+
+    public void testSeeMarkdown1() throws Exception {
+        String code =
+                "package p;\n" +
+                "class Clazz {\n" +
+                "    ///\n" +
+                "    /// @see CharSequence#le|\n" +
+                "    ///\n" +
+                "    Clazz() {\n" +
+                "    }\n" +
+                "}\n";
+
+        performCompletionTest(code, "public abstract int length()");
+    }
+
+    public void testSeeMarkdown2() throws Exception {
+        String code =
+                "package p;\n" +
+                "class Clazz {\n" +
+                "    ///\n" +
+                "    /// @see |\n" +
+                "    ///\n" +
+                "    Clazz() {\n" +
+                "    }\n" +
+                "}\n";
+
+        performCompletionTest(code, null, "String", "Clazz");
+    }
+
+    public void testSeeMarkdown3() throws Exception {
+        String code =
+                "package p;\n" +
+                "class Clazz {\n" +
+                "    ///@param i i\n" +
+                "    ///@see |\n" +
+                "    ///\n" +
+                "    Clazz(int i) {\n" +
+                "    }\n" +
+                "}\n";
+
+        performCompletionTest(code, null, "String", "Clazz");
+    }
+
+    public void testParamMarkdown() throws Exception {
+        String code =
+                "package p;\n" +
+                "class Clazz {\n" +
+                "    ///\n" +
+                "    /// @param |\n" +
+                "    ///\n" +
+                "    void method(int p1, int p2) {\n" +
+                "    }\n" +
+                "}\n";
+
+        performCompletionTest(code, "p1:", "p2:");
+    }
+
+    public void testJavadocOldStart1() throws Exception {
+        String code =
+                "package p;\n" +
+                "class Clazz {\n" +
+                "    /**| */\n" +
+                "    void method(int p1, int p2) {\n" +
+                "    }\n" +
+                "}\n";
+
+        performCompletionTest(code, "@deprecated:", "@exception:", "@hidden:", "@param:", "@return:", "@see:", "@serialData:", "@since:", "@throws:");
+    }
+
+    public void testJavadocOldStart2() throws Exception {
+        String code =
+                "package p;\n" +
+                "class Clazz {\n" +
+                "    /**@s| */\n" +
+                "    void method(int p1, int p2) {\n" +
+                "    }\n" +
+                "}\n";
+
+        performCompletionTest(code, "@see:", "@serialData:", "@since:");
+    }
+
+    public void testJavadocOldStart3() throws Exception {
+        String code =
+                "package p;\n" +
+                "class Clazz {\n" +
+                "    /**@param | */\n" +
+                "    void method(int p1, int p2) {\n" +
+                "    }\n" +
+                "}\n";
+
+        performCompletionTest(code, "p1:", "p2:");
+    }
+
+    public void testJavadocOldStart4() throws Exception {
+        String code =
+                "package p;\n" +
+                "class Clazz {\n" +
+                "    /**@see | */\n" +
+                "    void method(int p1, int p2) {\n" +
+                "    }\n" +
+                "}\n";
+
+        performCompletionTest(code, null, "String", "Clazz");
+    }
+
+    public void testJavadocMarkdownStart1() throws Exception {
+        String code =
+                "package p;\n" +
+                "class Clazz {\n" +
+                "    ///|\n" +
+                "    void method(int p1, int p2) {\n" +
+                "    }\n" +
+                "}\n";
+
+        performCompletionTest(code, "@deprecated:", "@exception:", "@hidden:", "@param:", "@return:", "@see:", "@serialData:", "@since:", "@throws:");
+    }
+
+    public void testJavadocMarkdownStart2() throws Exception {
+        String code =
+                "package p;\n" +
+                "class Clazz {\n" +
+                "    ///@s|\n" +
+                "    void method(int p1, int p2) {\n" +
+                "    }\n" +
+                "}\n";
+
+        performCompletionTest(code, "@see:", "@serialData:", "@since:");
+    }
+
+    public void testJavadocMarkdownStart3() throws Exception {
+        String code =
+                "package p;\n" +
+                "class Clazz {\n" +
+                "    ///@param |\n" +
+                "    void method(int p1, int p2) {\n" +
+                "    }\n" +
+                "}\n";
+
+        performCompletionTest(code, "p1:", "p2:");
+    }
+
+    public void testJavadocMarkdownStart4() throws Exception {
+        String code =
+                "package p;\n" +
+                "class Clazz {\n" +
+                "    ///@see |\n" +
+                "    void method(int p1, int p2) {\n" +
+                "    }\n" +
+                "}\n";
+
+        performCompletionTest(code, null, "String", "Clazz");
+    }
 
     private static String stripHTML(String from) {
         StringBuilder result = new StringBuilder();
@@ -647,4 +855,27 @@ public class JavadocCompletionQueryTest extends JavadocTestSupport {
             assertEquals(goldenList, resultStrings);
         }
     }
+
+    @ServiceProvider(service=SourceLevelQueryImplementation2.class)
+    public static final class SourceLevelQueryImpl implements SourceLevelQueryImplementation2 {
+
+        @Override
+        public Result getSourceLevel(FileObject javaFile) {
+            return new Result() {
+                @Override
+                public String getSourceLevel() {
+                    return "23";
+                }
+
+                @Override
+                public void addChangeListener(ChangeListener listener) {
+                }
+
+                @Override
+                public void removeChangeListener(ChangeListener listener) {
+                }
+            };
+        }
+
+    }
 }
diff --git a/java/java.lexer/src/org/netbeans/api/java/lexer/JavaTokenId.java b/java/java.lexer/src/org/netbeans/api/java/lexer/JavaTokenId.java
index 17602a5e40..25738a8da1 100644
--- a/java/java.lexer/src/org/netbeans/api/java/lexer/JavaTokenId.java
+++ b/java/java.lexer/src/org/netbeans/api/java/lexer/JavaTokenId.java
@@ -193,6 +193,7 @@ public enum JavaTokenId implements TokenId {
     LINE_COMMENT(null, "comment"), // Token includes ending new-line
     BLOCK_COMMENT(null, "comment"),
     JAVADOC_COMMENT(null, "comment"),
+    JAVADOC_COMMENT_LINE_RUN(null, "comment"), // A run of "markdown" javadoc comments, includes ending new-line
     
     // Errors
     INVALID_COMMENT_END("*/", "error"),
@@ -262,6 +263,9 @@ public enum JavaTokenId implements TokenId {
                 case JAVADOC_COMMENT:
                     return LanguageEmbedding.create(JavadocTokenId.language(), 3,
                             (token.partType() == PartType.COMPLETE) ? 2 : 0);
+                case JAVADOC_COMMENT_LINE_RUN:
+                    return LanguageEmbedding.create(JavadocTokenId.language(), 3,
+                            (token.partType() == PartType.COMPLETE) ? 1 : 0);
                 case STRING_LITERAL:
                     return LanguageEmbedding.create(JavaStringTokenId.language(), 1,
                             (token.partType() == PartType.COMPLETE) ? 1 : 0);
diff --git a/java/java.lexer/src/org/netbeans/lib/java/lexer/JavaLexer.java b/java/java.lexer/src/org/netbeans/lib/java/lexer/JavaLexer.java
index 49c32619b4..438b8b84ff 100644
--- a/java/java.lexer/src/org/netbeans/lib/java/lexer/JavaLexer.java
+++ b/java/java.lexer/src/org/netbeans/lib/java/lexer/JavaLexer.java
@@ -321,6 +321,13 @@ public class JavaLexer implements Lexer<JavaTokenId> {
                 case '/':
                     switch (nextChar()) {
                         case '/': // in single-line comment
+                            switch (nextChar()) {
+                                case '/': return finishJavadocLineRun();
+                                case '\r': consumeNewline();
+                                case '\n':
+                                case EOF:
+                                    return token(JavaTokenId.LINE_COMMENT);
+                            }
                             while (true)
                                 switch (nextChar()) {
                                     case '\r': consumeNewline();
@@ -1428,6 +1435,34 @@ public class JavaLexer implements Lexer<JavaTokenId> {
                 return token(JavaTokenId.DOUBLE_LITERAL);
         }
     }
+
+    private Token<JavaTokenId> finishJavadocLineRun() {
+        while (true) {
+            //finish current line:
+            LINE: while (true) {
+                switch (nextChar()) {
+                    case '\r': consumeNewline();
+                    case '\n': break LINE;
+                    case EOF:
+                        return token(JavaTokenId.JAVADOC_COMMENT_LINE_RUN);
+                }
+            }
+
+            //at the next line, if it starts with "<whitespace>///", include it in the run,
+            //otherwise finish the run:
+            int mark = input.readLength();
+            int c;
+
+            while (Character.isWhitespace(c = nextChar()) && c != '\r' && c != '\n' && c != EOF)
+                ;
+
+            if (c != '/' || nextChar() != '/' || nextChar() != '/') {
+                input.backup(input.readLengthEOF()- mark);
+
+                return token(JavaTokenId.JAVADOC_COMMENT_LINE_RUN);
+            }
+        }
+    }
     
     private Token<JavaTokenId> token(JavaTokenId id) {
         return token(id, PartType.COMPLETE);
diff --git a/java/java.lexer/src/org/netbeans/lib/java/lexer/JavadocLexer.java b/java/java.lexer/src/org/netbeans/lib/java/lexer/JavadocLexer.java
index fa7189b483..c6ab507fee 100644
--- a/java/java.lexer/src/org/netbeans/lib/java/lexer/JavadocLexer.java
+++ b/java/java.lexer/src/org/netbeans/lib/java/lexer/JavadocLexer.java
@@ -194,6 +194,20 @@ public class JavadocLexer implements Lexer<JavadocTokenId> {
                     leftbr = false;
                     newline = false;
                     break;
+                case '/':
+                    //TODO: check comment type?
+                    if (newline) {
+                        if (input.read() == '/') {
+                            if (input.read() == '/') {
+                                break;
+                            } else {
+                                input.backup(1);
+                            }
+                        } else {
+                            input.backup(1);
+                        }
+                        newline = false; //for fall-through:
+                    }
                 case '*':
                     if (newline) {
                         break;
diff --git a/java/java.lexer/test/unit/src/org/netbeans/lib/java/lexer/JavaLexerBatchTest.java b/java/java.lexer/test/unit/src/org/netbeans/lib/java/lexer/JavaLexerBatchTest.java
index 6402fc5c34..6ea9909143 100644
--- a/java/java.lexer/test/unit/src/org/netbeans/lib/java/lexer/JavaLexerBatchTest.java
+++ b/java/java.lexer/test/unit/src/org/netbeans/lib/java/lexer/JavaLexerBatchTest.java
@@ -812,4 +812,78 @@ public class JavaLexerBatchTest extends TestCase {
         assertFalse(ts.moveNext());
     }
 
+    public void testMarkdown1() {
+        String text = "///test\n" +
+                      "///@see second line\n" +
+                      "///third\n" +
+                      "\n" +
+                      "///another run\n" +
+                      "///another line\n" +
+                      "\n";
+        InputAttributes attr = new InputAttributes();
+        TokenHierarchy<?> hi = TokenHierarchy.create(text, false, JavaTokenId.language(), EnumSet.noneOf(JavaTokenId.class), attr);
+        TokenSequence<?> ts = hi.tokenSequence();
+
+        LexerTestUtilities.assertNextTokenEquals(ts,
+                                                 JavaTokenId.JAVADOC_COMMENT_LINE_RUN,
+                                                 "///test\n" +
+                                                 "///@see second line\n" +
+                                                 "///third\n");
+        LexerTestUtilities.assertNextTokenEquals(ts, JavaTokenId.WHITESPACE, "\n");
+        LexerTestUtilities.assertNextTokenEquals(ts,
+                                                 JavaTokenId.JAVADOC_COMMENT_LINE_RUN,
+                                                 "///another run\n" +
+                                                 "///another line\n");
+        LexerTestUtilities.assertNextTokenEquals(ts, JavaTokenId.WHITESPACE, "\n");
+        assertFalse(ts.moveNext());
+    }
+
+    public void testMarkdown2() {
+        String text = "///test\n" +
+                      "///@see second line\n" +
+                      "///third\n" +
+                      "\n" +
+                      "///another run\n" +
+                      "///another line\n";
+        InputAttributes attr = new InputAttributes();
+        TokenHierarchy<?> hi = TokenHierarchy.create(text, false, JavaTokenId.language(), EnumSet.noneOf(JavaTokenId.class), attr);
+        TokenSequence<?> ts = hi.tokenSequence();
+
+        LexerTestUtilities.assertNextTokenEquals(ts,
+                                                 JavaTokenId.JAVADOC_COMMENT_LINE_RUN,
+                                                 "///test\n" +
+                                                 "///@see second line\n" +
+                                                 "///third\n");
+        LexerTestUtilities.assertNextTokenEquals(ts, JavaTokenId.WHITESPACE, "\n");
+        LexerTestUtilities.assertNextTokenEquals(ts,
+                                                 JavaTokenId.JAVADOC_COMMENT_LINE_RUN,
+                                                 "///another run\n" +
+                                                 "///another line\n");
+        assertFalse(ts.moveNext());
+    }
+
+    public void testMarkdown3() {
+        String text = "///test\n" +
+                      "///@see second line\n" +
+                      "///third\n" +
+                      "\n" +
+                      "///another run\n" +
+                      "///another line";
+        InputAttributes attr = new InputAttributes();
+        TokenHierarchy<?> hi = TokenHierarchy.create(text, false, JavaTokenId.language(), EnumSet.noneOf(JavaTokenId.class), attr);
+        TokenSequence<?> ts = hi.tokenSequence();
+
+        LexerTestUtilities.assertNextTokenEquals(ts,
+                                                 JavaTokenId.JAVADOC_COMMENT_LINE_RUN,
+                                                 "///test\n" +
+                                                 "///@see second line\n" +
+                                                 "///third\n");
+        LexerTestUtilities.assertNextTokenEquals(ts, JavaTokenId.WHITESPACE, "\n");
+        LexerTestUtilities.assertNextTokenEquals(ts,
+                                                 JavaTokenId.JAVADOC_COMMENT_LINE_RUN,
+                                                 "///another run\n" +
+                                                 "///another line");
+        assertFalse(ts.moveNext());
+    }
+
 }
diff --git a/java/java.lexer/test/unit/src/org/netbeans/lib/java/lexer/JavadocLexerTest.java b/java/java.lexer/test/unit/src/org/netbeans/lib/java/lexer/JavadocLexerTest.java
index 72668f24a6..c0859ba2f8 100644
--- a/java/java.lexer/test/unit/src/org/netbeans/lib/java/lexer/JavadocLexerTest.java
+++ b/java/java.lexer/test/unit/src/org/netbeans/lib/java/lexer/JavadocLexerTest.java
@@ -143,6 +143,20 @@ public class JavadocLexerTest extends NbTestCase {
         LexerTestUtilities.assertNextTokenEquals(ts, JavadocTokenId.OTHER_TEXT, "}");
     }
 
+    public void testMarkdown() {
+        String text = "///@see\n/// @see";
+
+        TokenHierarchy<?> hi = TokenHierarchy.create(text, JavadocTokenId.language());
+        TokenSequence<?> ts = hi.tokenSequence();
+
+        LexerTestUtilities.assertNextTokenEquals(ts, JavadocTokenId.OTHER_TEXT, "///");
+        LexerTestUtilities.assertNextTokenEquals(ts, JavadocTokenId.TAG, "@see");
+        LexerTestUtilities.assertNextTokenEquals(ts, JavadocTokenId.OTHER_TEXT, "\n/// ");
+        LexerTestUtilities.assertNextTokenEquals(ts, JavadocTokenId.TAG, "@see");
+
+        assertFalse(ts.moveNext());
+    }
+
 //    public void testModification1() throws Exception {
 //        PlainDocument doc = new PlainDocument();
 //        doc.putProperty(Language.class, JavadocTokenId.language());
diff --git a/java/java.lsp.server/licenseinfo.xml b/java/java.lsp.server/licenseinfo.xml
index fc390b64bb..001c83187e 100644
--- a/java/java.lsp.server/licenseinfo.xml
+++ b/java/java.lsp.server/licenseinfo.xml
@@ -50,4 +50,9 @@
         <license ref="MIT-java-grammar" />
         <comment type="COMMENT_UNSUPPORTED" />
     </fileset>
+    <fileset>
+        <file>vscode/language-configuration.json</file>
+        <license ref="MIT-vscode" />
+        <comment type="COMMENT_UNSUPPORTED" />
+    </fileset>
 </licenseinfo>
diff --git a/java/java.lsp.server/vscode/language-configuration.json b/java/java.lsp.server/vscode/language-configuration.json
new file mode 100644
index 0000000000..c6b69e5336
--- /dev/null
+++ b/java/java.lsp.server/vscode/language-configuration.json
@@ -0,0 +1,111 @@
+{
+	"comments": {
+		"lineComment": "//",
+		"blockComment": [ "/*", "*/" ]
+	},
+	"brackets": [
+		["{", "}"],
+		["[", "]"],
+		["(", ")"]
+	],
+	"autoClosingPairs": [
+		["{", "}"],
+		["[", "]"],
+		["(", ")"],
+		{ "open": "\"", "close": "\"", "notIn": ["string"] },
+		{ "open": "'", "close": "'", "notIn": ["string"] },
+		{ "open": "/**", "close": " */", "notIn": ["string"] }
+	],
+	"surroundingPairs": [
+		["{", "}"],
+		["[", "]"],
+		["(", ")"],
+		["\"", "\""],
+		["'", "'"],
+		["<", ">"]
+	],
+	"folding": {
+		"markers": {
+			"start": "^\\s*//\\s*(?:(?:#?region\\b)|(?:<editor-fold\\b))",
+			"end": "^\\s*//\\s*(?:(?:#?endregion\\b)|(?:</editor-fold>))"
+		}
+	},
+	"onEnterRules": [
+		{
+			// e.g. /** | */
+			"beforeText": {
+				"pattern": "^\\s*/\\*\\*(?!/)([^\\*]|\\*(?!/))*$"
+			},
+			"afterText": {
+				"pattern": "^\\s*\\*/$"
+			},
+			"action": {
+				"indent": "indentOutdent",
+				"appendText": " * "
+			}
+		},
+		{
+			// e.g. /** ...|
+			"beforeText": {
+				"pattern": "^\\s*/\\*\\*(?!/)([^\\*]|\\*(?!/))*$"
+			},
+			"action": {
+				"indent": "none",
+				"appendText": " * "
+			}
+		},
+		{
+			// e.g.  * ...|
+			"beforeText": {
+				"pattern": "^(\\t|[ ])*[ ]\\*([ ]([^\\*]|\\*(?!/))*)?$"
+			},
+			"previousLineText": {
+				"pattern": "(?=^(\\s*(/\\*\\*|\\*)).*)(?=(?!(\\s*\\*/)))"
+			},
+			"action": {
+				"indent": "none",
+				"appendText": "* "
+			}
+		},
+		{
+			// e.g.  */|
+			"beforeText": {
+				"pattern": "^(\\t|[ ])*[ ]\\*/\\s*$"
+			},
+			"action": {
+				"indent": "none",
+				"removeText": 1
+			}
+		},
+		{
+			// e.g.  *-----*/|
+			"beforeText": {
+				"pattern": "^(\\t|[ ])*[ ]\\*[^/]*\\*/\\s*$"
+			},
+			"action": {
+				"indent": "none",
+				"removeText": 1
+			}
+		},
+		{
+			"beforeText": {
+				"pattern": "^\\s*(\\bcase\\s.+:|\\bdefault:)$"
+			},
+			"afterText": {
+				"pattern": "^(?!\\s*(\\bcase\\b|\\bdefault\\b))"
+			},
+			"action": {
+				"indent": "indent"
+			}
+		},
+		{
+			"beforeText": {
+				"pattern": "^\\s*///.*$"
+			},
+			"action": {
+				"indent": "none",
+				"appendText": "///"
+			}
+		}
+	]
+}
diff --git a/java/java.lsp.server/vscode/package.json b/java/java.lsp.server/vscode/package.json
index 07c3269640..a341dad480 100644
--- a/java/java.lsp.server/vscode/package.json
+++ b/java/java.lsp.server/vscode/package.json
@@ -35,6 +35,18 @@
 	"main": "./out/extension.js",
 	"contributes": {
 		"languages": [
+			{
+				"id": "java",
+				"extensions": [
+					".java",
+					".jav"
+				],
+				"aliases": [
+					"Java",
+					"java"
+				],
+				"configuration": "./language-configuration.json"
+			},
 			{
 				"id": "javascript",
 				"mimetypes": [
diff --git a/java/java.lsp.server/vscode/syntaxes/java.tmLanguage.json b/java/java.lsp.server/vscode/syntaxes/java.tmLanguage.json
index 1357aff68d..d990bf88fd 100644
--- a/java/java.lsp.server/vscode/syntaxes/java.tmLanguage.json
+++ b/java/java.lsp.server/vscode/syntaxes/java.tmLanguage.json
@@ -655,6 +655,63 @@
 							}
 						}
 					]
+				},
+				{
+					"begin": "^\\s*(///)",
+					"beginCaptures": {
+						"1": {
+							"name": "punctuation.definition.comment.java"
+						}
+					},
+					"end": "\n",
+					"endCaptures": {
+						"0": {
+							"name": "punctuation.definition.comment.java"
+						}
+					},
+					"name": "comment.block.javadoc.markdown.java",
+					"patterns": [
+						{
+							"match": "@(author|deprecated|return|see|serial|since|version)\\b",
+							"name": "keyword.other.documentation.javadoc.java"
+						},
+						{
+							"match": "(@param)\\s+(\\S+)",
+							"captures": {
+								"1": {
+									"name": "keyword.other.documentation.javadoc.java"
+								},
+								"2": {
+									"name": "variable.parameter.java"
+								}
+							}
+						},
+						{
+							"match": "(@(?:exception|throws))\\s+(\\S+)",
+							"captures": {
+								"1": {
+									"name": "keyword.other.documentation.javadoc.java"
+								},
+								"2": {
+									"name": "entity.name.type.class.java"
+								}
+							}
+						},
+						{
+							"match": "{(@link)\\s+(\\S+)?#([\\w$]+\\s*\\([^\\(\\)]*\\)).*?}",
+							"captures": {
+								"1": {
+									"name": "keyword.other.documentation.javadoc.java"
+								},
+								"2": {
+									"name": "entity.name.type.class.java"
+								},
+								"3": {
+									"name": "variable.parameter.java"
+								}
+							}
+						}
+					]
 				}
 			]
 		},
diff --git a/java/java.source.base/src/org/netbeans/api/java/source/TreeUtilities.java b/java/java.source.base/src/org/netbeans/api/java/source/TreeUtilities.java
index a7453c4477..bca4cbd46a 100644
--- a/java/java.source.base/src/org/netbeans/api/java/source/TreeUtilities.java
+++ b/java/java.source.base/src/org/netbeans/api/java/source/TreeUtilities.java
@@ -1302,7 +1302,11 @@ public final class TreeUtilities {
         
         tokenSequence.move(pos);
         
-        if (!tokenSequence.moveNext() || tokenSequence.token().id() != JavaTokenId.JAVADOC_COMMENT) return null;
+        if (!tokenSequence.moveNext() ||
+            (tokenSequence.token().id() != JavaTokenId.JAVADOC_COMMENT &&
+             tokenSequence.token().id() != JavaTokenId.JAVADOC_COMMENT_LINE_RUN)) {
+            return null;
+        }
         
         TokenSequence<JavadocTokenId> jdocTS = tokenSequence.embedded(JavadocTokenId.language());
         
diff --git a/java/java.sourceui/nbproject/project.xml b/java/java.sourceui/nbproject/project.xml
index 9ac80a3c09..1f7e220870 100644
--- a/java/java.sourceui/nbproject/project.xml
+++ b/java/java.sourceui/nbproject/project.xml
@@ -86,6 +86,14 @@
                         <implementation-version/>
                     </run-dependency>
                 </dependency>
+                <dependency>
+                    <code-name-base>org.netbeans.libs.flexmark</code-name-base>
+                    <build-prerequisite/>
+                    <compile-dependency/>
+                    <run-dependency>
+                        <specification-version>1.17</specification-version>
+                    </run-dependency>
+                </dependency>
                 <dependency>
                     <code-name-base>org.netbeans.libs.javacapi</code-name-base>
                     <build-prerequisite/>
diff --git a/java/java.sourceui/src/org/netbeans/api/java/source/ui/ElementJavadoc.java b/java/java.sourceui/src/org/netbeans/api/java/source/ui/ElementJavadoc.java
index fdabe50444..b1d1aa9ffd 100644
--- a/java/java.sourceui/src/org/netbeans/api/java/source/ui/ElementJavadoc.java
+++ b/java/java.sourceui/src/org/netbeans/api/java/source/ui/ElementJavadoc.java
@@ -119,6 +119,8 @@ import javax.tools.SimpleJavaFileObject;
 import com.sun.source.tree.ImportTree;
 import com.sun.source.tree.Tree;
 import com.sun.source.util.JavacTask;
+import com.vladsch.flexmark.html.HtmlRenderer;
+import com.vladsch.flexmark.parser.Parser;
 import javax.lang.model.element.RecordComponentElement;
 import org.netbeans.api.java.queries.SourceLevelQuery;
 import org.netbeans.api.java.queries.SourceLevelQuery.Profile;
@@ -1275,7 +1277,7 @@ public class ElementJavadoc {
     private StringBuilder inlineTags(List<? extends DocTree> tags, TreePath docPath, DocCommentTree doc, DocTrees trees, CharSequence inherited) {
         StringBuilder sb = new StringBuilder();
         Integer snippetCount=0;
-        for (DocTree tag : tags) {
+        for (DocTree tag : resolveMarkdown(trees, tags)) {
             switch (tag.getKind()) {
                 case REFERENCE:
                     ReferenceTree refTag = (ReferenceTree)tag;
@@ -1395,6 +1397,42 @@ public class ElementJavadoc {
         return sb;
     }
 
+    private static final char REPLACEMENT = '\uFFFD';
+    private List<? extends DocTree> resolveMarkdown(DocTrees trees, List<? extends DocTree> tags) {
+        if (tags.stream().noneMatch(t -> "MARKDOWN".equals(t.getKind().name()))) {
+            return tags;
+        }
+
+        StringBuilder markdownSource = new StringBuilder();
+        List<DocTree> replacements = new ArrayList<>();
+
+        for (DocTree t : tags) {
+            if ("MARKDOWN".equals(t.getKind().name())) {
+                markdownSource.append(t.toString()); //TODO: should avoid toString()
+            } else {
+                markdownSource.append(REPLACEMENT);
+                replacements.add(t);
+            }
+        }
+
+        String html = HtmlRenderer.builder().build().render(Parser.builder().build().parse(markdownSource.toString()));
+        if (html.startsWith("<p>")) {
+            html = html.substring("<p>".length());
+        }
+        html = html.replace("</p>", "");
+        List<DocTree> result = new ArrayList<>();
+        String[] parts = html.split(Pattern.quote("" + REPLACEMENT));
+
+        result.add(trees.getDocTreeFactory().newTextTree(parts[0]));
+
+        for (int i = 1; i < parts.length; i++) {
+            result.add(replacements.get(i - 1));
+            result.add(trees.getDocTreeFactory().newTextTree(parts[i]));
+        }
+
+        return result;
+    }
+
     private void processDocSnippet(StringBuilder sb, SnippetTree javadocSnippet, Integer snippetCount, TreePath docPath,DocCommentTree doc, DocTrees trees) {
         sb.append("<div id=\"snippet").append(snippetCount).append("\" style=\"font-size: 10px; border: 1px solid black; margin-top: 2px; margin-bottom: 2px\">"); //NOI18N
         sb.append("<div align=right>" //NOI18N
