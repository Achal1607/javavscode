diff --git a/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/Server.java b/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/Server.java
index 5d7abe9d19..c59662e820 100644
--- a/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/Server.java
+++ b/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/Server.java
@@ -158,6 +158,7 @@ import org.openide.util.lookup.ProxyLookup;
  */
 public final class Server {
     private static final Logger LOG = Logger.getLogger(Server.class.getName());
+    private static final LspServerTelemetryManager LSP_SERVER_TELEMETRY = new LspServerTelemetryManager();
 
     private Server() {
     }
@@ -180,7 +181,7 @@ public final class Server {
         ((LanguageClientAware) server).connect(remote);
         msgProcessor.attachClient(server.client);
         Future<Void> runningServer = serverLauncher.startListening();
-        LSPServerTelemetryFactory.getDefault().connect(server.client, runningServer);
+        LSP_SERVER_TELEMETRY.connect(server.client, runningServer);
         return new NbLspServer(server, runningServer);
     }
     
@@ -750,6 +752,8 @@ public final class Server {
                     }
                 }
                 f.complete(candidateMapping);
+                
+                LSP_SERVER_TELEMETRY.sendWorkspaceInfo(openedProjects.toArray(new Project[openedProjects.size()]), System.currentTimeMillis() - t);
                 LOG.log(Level.INFO, "{0} projects opened in {1}ms", new Object[] { prjsRequested.length, (System.currentTimeMillis() - t) });
             }).exceptionally(e -> {
                 f.completeExceptionally(e);
@@ -1321,11 +1335,10 @@ public final class Server {
         }
     }
 
-    public static class LSPServerTelemetryFactory extends CustomIndexerFactory {
+    public static class CustomIndexerTelemetryFactory extends CustomIndexerFactory {
 
-        private static LSPServerTelemetryFactory INSTANCE;
-
-        private final WeakHashMap<LanguageClient, Future<Void>> clients = new WeakHashMap<>();
+        private static CustomIndexerTelemetryFactory INSTANCE;
+        
         private final CustomIndexer noOp = new CustomIndexer() {
             @Override
             protected void index(Iterable<? extends Indexable> files, Context context) {
@@ -1333,49 +1346,25 @@ public final class Server {
         };
 
         @MimeRegistration(mimeType="", service=CustomIndexerFactory.class)
-        public static LSPServerTelemetryFactory getDefault() {
+        public static CustomIndexerTelemetryFactory getDefault() {
             if (INSTANCE == null) {
-                INSTANCE = new LSPServerTelemetryFactory();
+                INSTANCE = new CustomIndexerTelemetryFactory();
             }
             return INSTANCE;
         }
 
-        private LSPServerTelemetryFactory() {
-        }
-
-        public synchronized void connect(LanguageClient client, Future<Void> future) {
-            clients.put(client, future);
+        private CustomIndexerTelemetryFactory() {
         }
 
         @Override
         public synchronized boolean scanStarted(Context context) {
-            Set<LanguageClient> toRemove = new HashSet<>();
-            for (Map.Entry<LanguageClient, Future<Void>> entry : clients.entrySet()) {
-                if (entry.getValue().isDone()) {
-                    toRemove.add(entry.getKey());
-                } else {
-                    entry.getKey().telemetryEvent("nbls.scanStarted");
-                }
-            }
-            for (LanguageClient lc : toRemove) {
-                clients.remove(lc);
-            }
+            LSP_SERVER_TELEMETRY.sendTelemetry(new TelemetryEvent(MessageType.Info.toString(), LSP_SERVER_TELEMETRY.SCAN_START_EVT, "nbls.scanStarted"));
             return true;
         }
 
         @Override
         public synchronized void scanFinished(Context context) {
-            Set<LanguageClient> toRemove = new HashSet<>();
-            for (Map.Entry<LanguageClient, Future<Void>> entry : clients.entrySet()) {
-                if (entry.getValue().isDone()) {
-                    toRemove.add(entry.getKey());
-                } else {
-                    entry.getKey().telemetryEvent("nbls.scanFinished");
-                }
-            }
-            for (LanguageClient lc : toRemove) {
-                clients.remove(lc);
-            }
+            LSP_SERVER_TELEMETRY.sendTelemetry(new TelemetryEvent(MessageType.Info.toString(),LSP_SERVER_TELEMETRY.SCAN_END_EVT,"nbls.scanFinished"));
         }
 
         @Override
@@ -1388,7 +1377,7 @@ public final class Server {
 
         @Override
         public String getIndexerName() {
-            return "LSPServerTelemetry";
+            return "CustomIndexerTelemetryFactory";
         }
 
         @Override
diff --git a/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/TelemetryEvent.java b/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/TelemetryEvent.java
new file mode 100644
index 0000000000..34cc7de750
--- /dev/null
+++ b/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/TelemetryEvent.java
@@ -0,0 +1,54 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.netbeans.modules.java.lsp.server.protocol;
+
+/**
+ *
+ * @author atalati
+ */
+public class TelemetryEvent {
+
+    private final String name;
+    private final String type;
+    private final Object properties;
+
+    public TelemetryEvent(String type, String name) {
+        this.name = name;        
+        this.type = type;
+        this.properties = null;
+    }
+    
+    public TelemetryEvent(String type, String name, Object properties) {
+        this.name = name;        
+        this.type = type;
+        this.properties = properties;
+    }
+
+    public String getName() {
+        return name;
+    }
+    
+    public String getType() {
+        return type;
+    }
+
+    public Object getProperties() {
+        return properties;
+    }
+}
diff --git a/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/LspServerTelemetryManager.java b/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/LspServerTelemetryManager.java
new file mode 100644
index 0000000000..2f345f569b
--- /dev/null
+++ b/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/LspServerTelemetryManager.java
@@ -0,0 +1,144 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.netbeans.modules.java.lsp.server.protocol;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonObject;
+import java.math.BigInteger;
+import java.nio.charset.StandardCharsets;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.WeakHashMap;
+import java.util.concurrent.Future;
+import org.eclipse.lsp4j.MessageType;
+import org.eclipse.lsp4j.services.LanguageClient;
+import org.netbeans.api.java.queries.CompilerOptionsQuery;
+import org.netbeans.api.java.queries.CompilerOptionsQuery.Result;
+import org.netbeans.api.project.Project;
+import org.netbeans.api.project.ui.ProjectProblems;
+import org.openide.filesystems.FileObject;
+import org.openide.util.Exceptions;
+
+/**
+ *
+ * @author atalati
+ */
+public class LspServerTelemetryManager {
+
+    public final String SCAN_START_EVT = "SCAN_START_EVT";
+    public final String SCAN_END_EVT = "SCAN_END_EVT";
+    public final String WORKSPACE_INFO_EVT = "WORKSPACE_INFO_EVT";
+    
+    private final String ENABLE_PREVIEW = "--enable-preview"; 
+    private final WeakHashMap<LanguageClient, Future<Void>> clients = new WeakHashMap<>();
+    private long lspServerIntiailizationTime;
+
+    public synchronized void connect(LanguageClient client, Future<Void> future) {
+        clients.put(client, future);
+        lspServerIntiailizationTime = System.currentTimeMillis();
+    }
+
+    public void sendTelemetry(TelemetryEvent event) {
+        Set<LanguageClient> toRemove = new HashSet<>();
+        for (Map.Entry<LanguageClient, Future<Void>> entry : clients.entrySet()) {
+            if (entry.getValue().isDone()) {
+                toRemove.add(entry.getKey());
+            } else {
+                entry.getKey().telemetryEvent(event);
+            }
+        }
+        for (LanguageClient lc : toRemove) {
+            clients.remove(lc);
+        }
+    }
+
+    public void sendWorkspaceInfo(Project[] prjs, long timeToOpenPrjs) {
+        JsonObject properties = new JsonObject();
+        JsonArray prjProps = new JsonArray();
+
+        for (Project prj : prjs) {
+            try {
+                
+                JsonObject obj = new JsonObject();
+                
+                String prjPath = prj.getProjectDirectory().getPath();
+                String prjId = this.getPrjId(prjPath);
+                obj.addProperty("id", prjId);
+                
+                String buildToolName = prj.getClass().getSimpleName();
+                obj.addProperty("buildTool", (buildToolName.equals("NbGradleProjectImpl") ? "GradleProject" : "MavenProject"));
+                
+                obj.addProperty("javaVersion", System.getProperty("java.version"));
+                obj.addProperty("openedWithProblems", ProjectProblems.isBroken(prj));
+                
+                boolean isPreviewFlagEnabled = this.isEnablePreivew(prj);
+                obj.addProperty("enablePreview", isPreviewFlagEnabled);
+                
+                prjProps.add(obj);
+            } catch (NoSuchAlgorithmException ex) {
+                Exceptions.printStackTrace(ex);
+            }
+
+        }
+        properties.add("prjsInfo", prjProps);
+        if (prjs.length == 0) {
+            JsonObject obj = new JsonObject();
+
+            obj.addProperty("buildTool", "Standalone");
+            obj.addProperty("javaVersion", System.getProperty("java.version"));
+            obj.addProperty("openedWithProblems", false);
+            prjProps.add(obj);
+        }
+        properties.addProperty("timeToOpenPrjs", timeToOpenPrjs);
+        properties.addProperty("numOfPrjsOpened", prjs.length);
+        properties.addProperty("lspServerInitializationTime", System.currentTimeMillis() - this.lspServerIntiailizationTime);
+
+        this.sendTelemetry(new TelemetryEvent(MessageType.Info.toString(), this.WORKSPACE_INFO_EVT, properties));
+    }
+
+    public boolean isEnablePreivew(Project prj){
+        FileObject prjDir = prj.getProjectDirectory();
+        Result result = CompilerOptionsQuery.getOptions(prjDir);
+        return result.getArguments().contains(this.ENABLE_PREVIEW);
+    }
+            
+    public String getPrjId(String prjPath) throws NoSuchAlgorithmException
+    {
+        MessageDigest digest = MessageDigest.getInstance("SHA-256");
+        byte[] hash = digest.digest(prjPath.getBytes(StandardCharsets.UTF_8));
+        
+        BigInteger number = new BigInteger(1, hash);
+ 
+        // Convert message digest into hex value
+        StringBuilder hexString = new StringBuilder(number.toString(16));
+ 
+        // Pad with leading zeros
+        while (hexString.length() < 64)
+        {
+            hexString.insert(0, '0');
+        }
+ 
+        return hexString.toString();
+    }
+    
+}
+
