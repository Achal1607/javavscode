diff --git a/java/java.api.common/src/org/netbeans/modules/java/api/common/queries/GenericModuleInfoAccessibilityQuery.java b/java/java.api.common/src/org/netbeans/modules/java/api/common/queries/GenericModuleInfoAccessibilityQuery.java
new file mode 100644
index 000000000000..0c9a0949de5e
--- /dev/null
+++ b/java/java.api.common/src/org/netbeans/modules/java/api/common/queries/GenericModuleInfoAccessibilityQuery.java
@@ -0,0 +1,313 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.netbeans.modules.java.api.common.queries;
+
+import com.sun.source.tree.CompilationUnitTree;
+import com.sun.source.tree.DirectiveTree;
+import com.sun.source.tree.ExportsTree;
+import com.sun.source.tree.ModuleTree;
+import com.sun.source.tree.Tree.Kind;
+import com.sun.source.util.JavacTask;
+import java.beans.PropertyChangeEvent;
+import java.beans.PropertyChangeListener;
+import java.io.IOException;
+import java.lang.ref.Reference;
+import java.lang.ref.ReferenceQueue;
+import java.lang.ref.WeakReference;
+import java.net.URI;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.WeakHashMap;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import javax.swing.event.ChangeEvent;
+import javax.swing.event.ChangeListener;
+import javax.tools.SimpleJavaFileObject;
+import javax.tools.ToolProvider;
+import org.netbeans.api.java.classpath.ClassPath;
+import org.netbeans.api.java.queries.AccessibilityQuery;
+import org.netbeans.api.project.FileOwnerQuery;
+import org.netbeans.api.project.Project;
+import org.netbeans.spi.java.queries.AccessibilityQueryImplementation;
+import org.netbeans.spi.java.queries.AccessibilityQueryImplementation2;
+import org.openide.filesystems.FileChangeAdapter;
+import org.openide.filesystems.FileEvent;
+import org.openide.filesystems.FileObject;
+import org.openide.util.ChangeSupport;
+import org.openide.util.RequestProcessor;
+import org.openide.util.RequestProcessor.Task;
+import org.openide.util.Utilities;
+import org.openide.util.lookup.ServiceProvider;
+
+@ServiceProvider(service=AccessibilityQueryImplementation2.class)
+public class GenericModuleInfoAccessibilityQuery implements AccessibilityQueryImplementation2 {
+
+    private static final Logger LOG = Logger.getLogger(GenericModuleInfoAccessibilityQuery.class.getName());
+
+    private final Map<ClassPath, Reference<ClassPathListener>> sourcePath2Listener = new WeakHashMap<>();
+    private final Map<FileObject, Reference<Result>> path2Result = new HashMap<>();
+
+    @Override
+    public Result isPubliclyAccessible(FileObject folder) {
+        Result result;
+        synchronized (this) {
+            Reference<Result> ref = path2Result.get(folder);
+            result = ref != null ? ref.get() : null;
+            if (result != null) {
+                return result;
+            }
+        }
+
+        Project p = FileOwnerQuery.getOwner(folder);
+        if (p != null && (p.getLookup().lookup(AccessibilityQueryImplementation2.class) != null ||
+                          p.getLookup().lookup(AccessibilityQueryImplementation.class) != null)) {
+            //if there's a project-based AccessibilityQuery for this file, don't provide the generic results
+            return null;
+        }
+        ClassPath sourcePath = ClassPath.getClassPath(folder, ClassPath.SOURCE);
+        if (sourcePath == null) {
+            return null;
+        }
+
+        synchronized (this) {
+            Reference<Result> ref = path2Result.get(folder);
+
+            result = ref != null ? ref.get() : null;
+
+            if (result != null) {
+                return result;
+            }
+
+            Reference<ClassPathListener> listenerRef = sourcePath2Listener.get(sourcePath);
+            ClassPathListener cpl = listenerRef != null ? listenerRef.get() : null;
+
+            if (cpl == null) {
+                cpl = new ClassPathListener(sourcePath);
+            }
+
+            sourcePath2Listener.put(sourcePath, new WeakReference<>(cpl));
+
+            result = new ResultImpl(cpl, sourcePath, folder);
+
+            path2Result.put(folder, new CleanPath2Result(result, folder));
+
+            return result;
+        }
+    }
+
+    private final class CleanPath2Result extends WeakReference<Result> implements Runnable {
+
+        private final FileObject key;
+
+        public CleanPath2Result(Result value, FileObject key) {
+            super(value, Utilities.activeReferenceQueue());
+            this.key = key;
+        }
+
+        @Override
+        public void run() {
+            synchronized (GenericModuleInfoAccessibilityQuery.this) {
+                path2Result.remove(key);
+            }
+        }
+
+    }
+
+    private static final class ResultImpl implements Result, ChangeListener {
+
+        private final ChangeSupport cs = new ChangeSupport(this);
+        private final ClassPathListener listener;
+        private final Reference<ClassPath> sourcePath;
+        private final FileObject folder;
+
+        public ResultImpl(ClassPathListener listener, ClassPath sourcePath, FileObject folder) {
+            this.listener = listener;
+            this.sourcePath = new WeakReference<>(sourcePath);
+            this.folder = folder;
+            listener.addChangeListener(this);
+        }
+
+        @Override
+        public AccessibilityQuery.Accessibility getAccessibility() {
+            ClassPath sourcePath = this.sourcePath.get();
+            Set<String> exported = listener.getExportedPackages();
+
+            if (sourcePath == null || folder == null || exported == null) {
+                return AccessibilityQuery.Accessibility.UNKNOWN;
+            }
+            String packageName = sourcePath.getResourceName(folder).replace('/', '.');
+            return exported.contains(packageName) ? AccessibilityQuery.Accessibility.EXPORTED
+                                                  : AccessibilityQuery.Accessibility.PRIVATE;
+        }
+
+        @Override
+        public void addChangeListener(ChangeListener listener) {
+            cs.addChangeListener(listener);
+        }
+
+        @Override
+        public void removeChangeListener(ChangeListener listener) {
+            cs.removeChangeListener(listener);
+        }
+
+        @Override
+        public void stateChanged(ChangeEvent e) {
+            cs.fireChange();
+        }
+
+    }
+
+    private static final class ClassPathListener implements PropertyChangeListener {
+
+        private static final RequestProcessor WORKER = new RequestProcessor(ClassPathListener.class.getName(), 1, false, false);
+        private static final int DELAY = 100;
+        private final ChangeSupport cs = new ChangeSupport(this);
+        private final AtomicReference<Set<String>> exportedPackages = new AtomicReference<>(null);
+        private final Reference<ClassPath> sourcePath;
+        private final Task parseTask;
+        private final Task rootsTask;
+        private final FileChangeAdapter folderListener = new FileChangeAdapter() {
+            @Override
+            public void fileDataCreated(FileEvent fe) {
+                if (fe.getFile().getNameExt().equalsIgnoreCase("module-info.java")) {
+                    rootsTask.schedule(DELAY);
+                }
+            }
+        };
+        private final FileChangeAdapter moduleInfoListener = new FileChangeAdapter() {
+            @Override
+            public void fileChanged(FileEvent fe) {
+                parseTask.schedule(DELAY);
+            }
+        };
+
+        private Set<FileObject> oldRoots = new HashSet<>();
+        private Set<FileObject> oldModuleInfos = new HashSet<>();
+
+        public ClassPathListener(ClassPath sourcePath) {
+            this.sourcePath = new WeakReference<>(sourcePath);
+            this.parseTask = WORKER.create(() -> {
+                FileObject moduleInfo = sourcePath.findResource("module-info.java");
+                Set<String> exported;
+
+                if (moduleInfo != null) {
+                    exported = new HashSet<>();
+
+                    try {
+                        String code = moduleInfo.asText();
+                        JavacTask compilerTask = (JavacTask) ToolProvider.getSystemJavaCompiler().getTask(null, null, null, null, null, Collections.singleton(new TextJFO(code, moduleInfo.toURI())));
+                        CompilationUnitTree cut = compilerTask.parse().iterator().next();
+                        ModuleTree mt = cut.getModule();
+                        if (mt != null) {
+                            for (DirectiveTree dt : mt.getDirectives()) {
+                                if (dt.getKind() == Kind.EXPORTS) {
+                                    ExportsTree et = (ExportsTree) dt;
+                                    if (et.getModuleNames() == null || et.getModuleNames().isEmpty()) {
+                                        exported.add(et.getPackageName().toString());
+                                    }
+                                }
+                            }
+                        }
+                    } catch (IOException ex) {
+                        LOG.log(Level.FINE, null, ex);
+                    }
+                } else {
+                    exported = null;
+                }
+
+                exportedPackages.set(exported);
+                cs.fireChange();
+            });
+            rootsTask = WORKER.create(() -> {
+                ClassPath cp = ClassPathListener.this.sourcePath.get();
+
+                if (cp == null) {
+                    return ;
+                }
+
+                Set<FileObject> removedRoots = new HashSet<>(oldRoots);
+                Set<FileObject> removedModuleInfos = new HashSet<>(oldModuleInfos);
+
+                for (FileObject root : cp.getRoots()) {
+                    removedRoots.remove(root);
+                    if (oldRoots.add(root)) {
+                        root.addFileChangeListener(folderListener);
+                    }
+                    FileObject moduleInfo = root.getFileObject("module-info.java");
+                    if (moduleInfo != null) {
+                        removedModuleInfos.remove(moduleInfo);
+                        if (oldModuleInfos.add(moduleInfo)) {
+                            moduleInfo.addFileChangeListener(moduleInfoListener);
+                        }
+                    }
+                }
+
+                for (FileObject root : removedRoots) {
+                    root.removeFileChangeListener(folderListener);
+                }
+
+                for (FileObject moduleInfo : removedModuleInfos) {
+                    moduleInfo.removeFileChangeListener(moduleInfoListener);
+                }
+
+                parseTask.schedule(DELAY);
+            });
+            rootsTask.schedule(DELAY);
+            sourcePath.addPropertyChangeListener(this);
+        }
+
+        public Set<String> getExportedPackages() {
+            return exportedPackages.get();
+        }
+
+        public void addChangeListener(ChangeListener listener) {
+            cs.addChangeListener(listener);
+        }
+
+        public void removeChangeListener(ChangeListener listener) {
+            cs.removeChangeListener(listener);
+        }
+
+        @Override
+        public void propertyChange(PropertyChangeEvent evt) {
+            rootsTask.schedule(DELAY);
+        }
+
+    }
+    private static final class TextJFO extends SimpleJavaFileObject {
+        private final String code;
+
+        public TextJFO(String code, URI uri) {
+            super(uri, Kind.SOURCE);
+            this.code = code;
+        }
+
+        @Override
+        public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {
+            return code;
+        }
+
+    }
+}
diff --git a/java/java.editor/test/unit/src/org/netbeans/modules/java/editor/codegen/EqualsHashCodeGeneratorTest.java b/java/java.editor/test/unit/src/org/netbeans/modules/java/editor/codegen/EqualsHashCodeGeneratorTest.java
index 0fd04daa439a..bb4b1e8f3752 100644
--- a/java/java.editor/test/unit/src/org/netbeans/modules/java/editor/codegen/EqualsHashCodeGeneratorTest.java
+++ b/java/java.editor/test/unit/src/org/netbeans/modules/java/editor/codegen/EqualsHashCodeGeneratorTest.java
@@ -32,6 +32,7 @@
 import javax.swing.JDialog;
 import javax.swing.JTextArea;
 import javax.swing.SwingUtilities;
+import javax.swing.event.ChangeListener;
 import javax.swing.text.Document;
 import org.netbeans.api.java.source.CancellableTask;
 import org.netbeans.api.java.source.CompilationController;
@@ -42,7 +43,7 @@
 import org.netbeans.api.java.source.WorkingCopy;
 import org.netbeans.junit.NbTestCase;
 import org.netbeans.modules.java.source.BootClassPathUtil;
-import org.netbeans.spi.java.queries.SourceLevelQueryImplementation;
+import org.netbeans.spi.java.queries.SourceLevelQueryImplementation2;
 import org.openide.DialogDescriptor;
 import org.openide.DialogDisplayer;
 import org.openide.NotifyDescriptor;
@@ -68,9 +69,18 @@ protected void setUp() throws Exception {
         super.setUp();
         fo = SourceUtilsTestUtil.makeScratchDir(this);
         System.setProperty("netbeans.user", getWorkDirPath());
-        SourceUtilsTestUtil.setLookup(new Object[] { new DD(), new SourceLevelQueryImplementation() {
-            @Override public String getSourceLevel(FileObject javaFile) {
-                return sourceLevel != null ? sourceLevel : "1.5";
+        SourceUtilsTestUtil.setLookup(new Object[] { new DD(), new SourceLevelQueryImplementation2() {
+            @Override public Result getSourceLevel(FileObject javaFile) {
+                return new Result() {
+                    @Override
+                    public String getSourceLevel() {
+                        return sourceLevel != null ? sourceLevel : "1.5";
+                    }
+                    @Override
+                    public void addChangeListener(ChangeListener listener) {}
+                    @Override
+                    public void removeChangeListener(ChangeListener listener) {}
+                };
             }
         }, BootClassPathUtil.getBootClassPathProvider() }, getClass().getClassLoader());
     }
diff --git a/java/java.file.launcher/build.xml b/java/java.file.launcher/build.xml
new file mode 100644
index 000000000000..b1aaccb78710
--- /dev/null
+++ b/java/java.file.launcher/build.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<project basedir="." default="netbeans" name="java/java.file.launcher">
+    <description>Builds, tests, and runs the project org.netbeans.modules.java.file.launcher</description>
+    <import file="../../nbbuild/templates/projectized.xml"/>
+</project>
diff --git a/java/java.file.launcher/manifest.mf b/java/java.file.launcher/manifest.mf
new file mode 100644
index 000000000000..c8f42a4b1720
--- /dev/null
+++ b/java/java.file.launcher/manifest.mf
@@ -0,0 +1,6 @@
+Manifest-Version: 1.0
+AutoUpdate-Show-In-Client: false
+OpenIDE-Module: org.netbeans.modules.java.file.launcher
+OpenIDE-Module-Localizing-Bundle: org/netbeans/modules/java/file/launcher/Bundle.properties
+OpenIDE-Module-Specification-Version: 1.0
+
diff --git a/java/java.file.launcher/nbproject/project.properties b/java/java.file.launcher/nbproject/project.properties
new file mode 100644
index 000000000000..2699b073bc7c
--- /dev/null
+++ b/java/java.file.launcher/nbproject/project.properties
@@ -0,0 +1,21 @@
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+javac.source=1.8
+cp.extra=${tools.jar}
+requires.nb.javac=true
+javac.compilerargs=-Xlint -Xlint:-serial
diff --git a/java/java.file.launcher/nbproject/project.xml b/java/java.file.launcher/nbproject/project.xml
new file mode 100644
index 000000000000..1bc8cb541b84
--- /dev/null
+++ b/java/java.file.launcher/nbproject/project.xml
@@ -0,0 +1,269 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<project xmlns="http://www.netbeans.org/ns/project/1">
+    <type>org.netbeans.modules.apisupport.project</type>
+    <configuration>
+        <data xmlns="http://www.netbeans.org/ns/nb-module-project/3">
+            <code-name-base>org.netbeans.modules.java.file.launcher</code-name-base>
+            <module-dependencies>
+                <dependency>
+                    <code-name-base>org.netbeans.api.annotations.common</code-name-base>
+                    <build-prerequisite/>
+                    <compile-dependency/>
+                    <run-dependency>
+                        <release-version>1</release-version>
+                        <specification-version>1.48</specification-version>
+                    </run-dependency>
+                </dependency>
+                <dependency>
+                    <code-name-base>org.netbeans.api.debugger.jpda</code-name-base>
+                    <build-prerequisite/>
+                    <compile-dependency/>
+                    <run-dependency>
+                        <release-version>2</release-version>
+                        <specification-version>3.30</specification-version>
+                    </run-dependency>
+                </dependency>
+                <dependency>
+                    <code-name-base>org.netbeans.api.java</code-name-base>
+                    <build-prerequisite/>
+                    <compile-dependency/>
+                    <run-dependency>
+                        <release-version>1</release-version>
+                        <specification-version>1.86</specification-version>
+                    </run-dependency>
+                </dependency>
+                <dependency>
+                    <code-name-base>org.netbeans.api.java.classpath</code-name-base>
+                    <build-prerequisite/>
+                    <compile-dependency/>
+                    <run-dependency>
+                        <release-version>1</release-version>
+                        <specification-version>1.74</specification-version>
+                    </run-dependency>
+                </dependency>
+                <dependency>
+                    <code-name-base>org.netbeans.api.templates</code-name-base>
+                    <build-prerequisite/>
+                    <compile-dependency/>
+                    <run-dependency>
+                        <specification-version>1.28</specification-version>
+                    </run-dependency>
+                </dependency>
+                <dependency>
+                    <code-name-base>org.netbeans.libs.javacapi</code-name-base>
+                    <build-prerequisite/>
+                    <compile-dependency/>
+                    <run-dependency>
+                        <specification-version>8.44</specification-version>
+                    </run-dependency>
+                </dependency>
+                <dependency>
+                    <code-name-base>org.netbeans.modules.editor.mimelookup</code-name-base>
+                    <build-prerequisite/>
+                    <compile-dependency/>
+                    <run-dependency>
+                        <release-version>1</release-version>
+                        <specification-version>1.60</specification-version>
+                    </run-dependency>
+                </dependency>
+                <dependency>
+                    <code-name-base>org.netbeans.modules.extexecution</code-name-base>
+                    <build-prerequisite/>
+                    <compile-dependency/>
+                    <run-dependency>
+                        <release-version>2</release-version>
+                        <specification-version>1.69</specification-version>
+                    </run-dependency>
+                </dependency>
+                <dependency>
+                    <code-name-base>org.netbeans.modules.extexecution.base</code-name-base>
+                    <build-prerequisite/>
+                    <compile-dependency/>
+                    <run-dependency>
+                        <release-version>2</release-version>
+                        <specification-version>1.28</specification-version>
+                    </run-dependency>
+                </dependency>
+                <dependency>
+                    <code-name-base>org.netbeans.modules.java.lexer</code-name-base>
+                    <build-prerequisite/>
+                    <compile-dependency/>
+                    <run-dependency>
+                        <release-version>1</release-version>
+                        <specification-version>1.56</specification-version>
+                    </run-dependency>
+                </dependency>
+                <dependency>
+                    <code-name-base>org.netbeans.modules.java.platform</code-name-base>
+                    <build-prerequisite/>
+                    <compile-dependency/>
+                    <run-dependency>
+                        <release-version>1</release-version>
+                        <specification-version>1.62</specification-version>
+                    </run-dependency>
+                </dependency>
+                <dependency>
+                    <code-name-base>org.netbeans.modules.java.project.ui</code-name-base>
+                    <build-prerequisite/>
+                    <compile-dependency/>
+                    <run-dependency>
+                        <release-version>1</release-version>
+                        <specification-version>1.95</specification-version>
+                    </run-dependency>
+                </dependency>
+                <dependency>
+                    <code-name-base>org.netbeans.modules.lexer</code-name-base>
+                    <build-prerequisite/>
+                    <compile-dependency/>
+                    <run-dependency>
+                        <release-version>2</release-version>
+                        <specification-version>1.84</specification-version>
+                    </run-dependency>
+                </dependency>
+                <dependency>
+                    <code-name-base>org.netbeans.modules.parsing.indexing</code-name-base>
+                    <build-prerequisite/>
+                    <compile-dependency/>
+                    <run-dependency>
+                        <specification-version>9.29</specification-version>
+                    </run-dependency>
+                </dependency>
+                <dependency>
+                    <code-name-base>org.netbeans.modules.projectapi</code-name-base>
+                    <build-prerequisite/>
+                    <compile-dependency/>
+                    <run-dependency>
+                        <release-version>1</release-version>
+                        <specification-version>1.91</specification-version>
+                    </run-dependency>
+                </dependency>
+                <dependency>
+                    <code-name-base>org.netbeans.modules.queries</code-name-base>
+                    <build-prerequisite/>
+                    <compile-dependency/>
+                    <run-dependency>
+                        <release-version>1</release-version>
+                        <specification-version>1.63</specification-version>
+                    </run-dependency>
+                </dependency>
+                <dependency>
+                    <code-name-base>org.openide.filesystems</code-name-base>
+                    <build-prerequisite/>
+                    <compile-dependency/>
+                    <run-dependency>
+                        <specification-version>9.33</specification-version>
+                    </run-dependency>
+                </dependency>
+                <dependency>
+                    <code-name-base>org.openide.io</code-name-base>
+                    <build-prerequisite/>
+                    <compile-dependency/>
+                    <run-dependency>
+                        <specification-version>1.69</specification-version>
+                    </run-dependency>
+                </dependency>
+                <dependency>
+                    <code-name-base>org.openide.loaders</code-name-base>
+                    <build-prerequisite/>
+                    <compile-dependency/>
+                    <run-dependency>
+                        <specification-version>7.90</specification-version>
+                    </run-dependency>
+                </dependency>
+                <dependency>
+                    <code-name-base>org.openide.modules</code-name-base>
+                    <build-prerequisite/>
+                    <compile-dependency/>
+                    <run-dependency>
+                        <specification-version>7.68</specification-version>
+                    </run-dependency>
+                </dependency>
+                <dependency>
+                    <code-name-base>org.openide.nodes</code-name-base>
+                    <build-prerequisite/>
+                    <compile-dependency/>
+                    <run-dependency>
+                        <specification-version>7.65</specification-version>
+                    </run-dependency>
+                </dependency>
+                <dependency>
+                    <code-name-base>org.openide.util</code-name-base>
+                    <build-prerequisite/>
+                    <compile-dependency/>
+                    <run-dependency>
+                        <specification-version>9.28</specification-version>
+                    </run-dependency>
+                </dependency>
+                <dependency>
+                    <code-name-base>org.openide.util.lookup</code-name-base>
+                    <build-prerequisite/>
+                    <compile-dependency/>
+                    <run-dependency>
+                        <specification-version>8.54</specification-version>
+                    </run-dependency>
+                </dependency>
+                <dependency>
+                    <code-name-base>org.openide.util.ui</code-name-base>
+                    <build-prerequisite/>
+                    <compile-dependency/>
+                    <run-dependency>
+                        <specification-version>9.29</specification-version>
+                    </run-dependency>
+                </dependency>
+            </module-dependencies>
+            <test-dependencies>
+                <test-type>
+                    <name>unit</name>
+                    <test-dependency>
+                        <code-name-base>org.netbeans.libs.junit4</code-name-base>
+                        <compile-dependency/>
+                    </test-dependency>
+                    <test-dependency>
+                        <code-name-base>org.netbeans.modules.java.j2seplatform</code-name-base>
+                        <compile-dependency/>
+                    </test-dependency>
+                    <test-dependency>
+                        <code-name-base>org.netbeans.modules.java.source.base</code-name-base>
+                        <compile-dependency/>
+                        <test/>
+                    </test-dependency>
+                    <test-dependency>
+                        <code-name-base>org.netbeans.modules.nbjunit</code-name-base>
+                        <recursive/>
+                        <compile-dependency/>
+                    </test-dependency>
+                    <test-dependency>
+                        <code-name-base>org.netbeans.modules.projectapi.nb</code-name-base>
+                        <compile-dependency/>
+                    </test-dependency>
+                </test-type>
+            </test-dependencies>
+            <friend-packages>
+                <friend>org.netbeans.modules.java.lsp.server</friend>
+                <friend>org.netbeans.modules.refactoring.java</friend>
+                <package>org.netbeans.modules.java.file.launcher.api</package>
+                <package>org.netbeans.modules.java.file.launcher.spi</package>
+            </friend-packages>
+        </data>
+    </configuration>
+</project>
diff --git a/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/AttributeBasedSingleFileOptions.java b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/AttributeBasedSingleFileOptions.java
new file mode 100644
index 000000000000..586415f3c414
--- /dev/null
+++ b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/AttributeBasedSingleFileOptions.java
@@ -0,0 +1,111 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.netbeans.modules.java.file.launcher;
+
+import javax.swing.event.ChangeListener;
+import org.netbeans.api.project.FileOwnerQuery;
+import org.netbeans.api.project.Project;
+import org.netbeans.modules.java.file.launcher.queries.MultiSourceRootProvider;
+import org.netbeans.modules.java.file.launcher.spi.SingleFileOptionsQueryImplementation;
+import org.openide.filesystems.FileAttributeEvent;
+import org.openide.filesystems.FileChangeAdapter;
+import org.openide.filesystems.FileChangeListener;
+import org.openide.filesystems.FileObject;
+import org.openide.filesystems.FileUtil;
+import org.openide.util.ChangeSupport;
+import org.openide.util.Lookup;
+import org.openide.util.WeakListeners;
+import org.openide.util.lookup.ServiceProvider;
+
+@ServiceProvider(service=SingleFileOptionsQueryImplementation.class)
+public class AttributeBasedSingleFileOptions implements SingleFileOptionsQueryImplementation {
+
+    @Override
+    public Result optionsFor(FileObject file) {
+        Project p = FileOwnerQuery.getOwner(file);
+
+        if (p != null) {
+            return null;
+        }
+
+        if (file.isData() && !"text/x-java".equals(FileUtil.getMIMEType(file))) {
+            return null;
+        }
+
+        FileObject root = Lookup.getDefault().lookup(MultiSourceRootProvider.class).getSourceRoot(file);
+
+        if (!file.isData()) {
+            file = null;
+        }
+
+        if (root != null || file != null) {
+            return new ResultImpl(root, file);
+        }
+
+        return null;
+    }
+
+    private static final class ResultImpl implements Result {
+
+        private final ChangeSupport cs;
+        private final FileObject root;
+        private final FileObject source;
+        private final FileChangeListener attributeChanges = new FileChangeAdapter() {
+            @Override
+            public void fileAttributeChanged(FileAttributeEvent fe) {
+                cs.fireChange();
+            }
+        };
+
+        ResultImpl(FileObject root, FileObject source) {
+            this.cs = new ChangeSupport(this);
+            this.root = root;
+            this.source = source;
+            if (source != null) {
+                source.addFileChangeListener(WeakListeners.create(FileChangeListener.class, attributeChanges, source));
+            }
+            if (root != null) {
+                root.addFileChangeListener(WeakListeners.create(FileChangeListener.class, attributeChanges, root));
+            }
+        }
+
+        @Override
+        public String getOptions() {
+            Object vmOptionsObj = source != null ? source.getAttribute(SingleSourceFileUtil.FILE_VM_OPTIONS) : null;
+
+            if (vmOptionsObj != null) {
+                return (String) vmOptionsObj;
+            }
+
+            vmOptionsObj = root != null ? root.getAttribute(SingleSourceFileUtil.FILE_VM_OPTIONS) : null;
+
+            return vmOptionsObj != null ? (String) vmOptionsObj : "";
+        }
+
+        @Override
+        public void addChangeListener(ChangeListener listener) {
+            cs.addChangeListener(listener);
+        }
+
+        @Override
+        public void removeChangeListener(ChangeListener listener) {
+            cs.removeChangeListener(listener);
+        }
+    }
+}
diff --git a/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/Bundle.properties b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/Bundle.properties
new file mode 100644
index 000000000000..e091b91b1845
--- /dev/null
+++ b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/Bundle.properties
@@ -0,0 +1,18 @@
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+OpenIDE-Module-Name=Java File Launcher
diff --git a/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/SharedRootData.java b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/SharedRootData.java
new file mode 100644
index 000000000000..9939a96e8152
--- /dev/null
+++ b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/SharedRootData.java
@@ -0,0 +1,115 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.netbeans.modules.java.file.launcher;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.TreeMap;
+import java.util.stream.Collectors;
+import org.netbeans.api.annotations.common.CheckForNull;
+import org.netbeans.modules.java.file.launcher.api.SourceLauncher;
+import org.openide.filesystems.FileAttributeEvent;
+import org.openide.filesystems.FileChangeAdapter;
+import org.openide.filesystems.FileChangeListener;
+import org.openide.filesystems.FileEvent;
+import org.openide.filesystems.FileObject;
+import org.openide.filesystems.FileUtil;
+import org.openide.modules.SpecificationVersion;
+import org.openide.util.Exceptions;
+
+/**
+ *
+ * @author lahvac
+ */
+public class SharedRootData {
+
+    private static final Map<FileObject, SharedRootData> root2Data = new HashMap<>();
+
+    public static synchronized void ensureRootRegistered(FileObject root) {
+        root2Data.computeIfAbsent(root, r -> new SharedRootData(r));
+    }
+
+    public static synchronized @CheckForNull SharedRootData getDataForRoot(FileObject root) {
+        return root2Data.get(root);
+    }
+
+    private final FileObject root;
+    private final Map<String, String> options = new TreeMap<>();
+    private final FileChangeListener listener = new FileChangeAdapter() {
+        @Override
+        public void fileAttributeChanged(FileAttributeEvent fe) {
+            Map<String, String> newProperties = new HashMap<>();
+
+            addPropertiesFor(fe.getFile(), newProperties);
+            setNewProperties(newProperties);
+        }
+        @Override
+        public void fileDeleted(FileEvent fe) {
+            Map<String, String> newProperties = new HashMap<>();
+
+            newProperties.put(FileUtil.getRelativePath(root, fe.getFile()), null);
+            setNewProperties(newProperties);
+        }
+    };
+
+    private SharedRootData(FileObject root) {
+        this.root = root;
+        root.addRecursiveListener(listener);
+        Enumeration<? extends FileObject> todo = root.getChildren(true);
+        Map<String, String> newProperties = new HashMap<>();
+        while (todo.hasMoreElements()) {
+            FileObject current = todo.nextElement();
+            addPropertiesFor(current, newProperties);
+        }
+        setNewProperties(newProperties);
+    }
+
+    private void addPropertiesFor(FileObject file, Map<String, String> newProperties) {
+        if (file.isData() && "text/x-java".equals(file.getMIMEType())) {
+            newProperties.put(FileUtil.getRelativePath(root, file), (String) file.getAttribute(SingleSourceFileUtil.FILE_VM_OPTIONS));
+        }
+    }
+
+    private synchronized void setNewProperties(Map<String, String> newProperties) {
+        if (newProperties.isEmpty()) {
+            return ;
+        }
+        for (String key : newProperties.keySet()) {
+            String value = newProperties.get(key);
+            if (value == null) {
+                options.remove(key);
+            } else {
+                options.put(key, value);
+            }
+        }
+        String joinedCommandLine = SourceLauncher.joinCommandLines(options.values());
+        try {
+            if (!joinedCommandLine.equals(root.getAttribute(SingleSourceFileUtil.FILE_VM_OPTIONS))) {
+                root.setAttribute(SingleSourceFileUtil.FILE_VM_OPTIONS, joinedCommandLine);
+            }
+        } catch (IOException ex) {
+            Exceptions.printStackTrace(ex);
+        }
+    }
+
+}
diff --git a/java/java.api.common/src/org/netbeans/modules/java/api/common/singlesourcefile/SingleSourceFileUtil.java b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/SingleSourceFileUtil.java
similarity index 65%
rename from java/java.api.common/src/org/netbeans/modules/java/api/common/singlesourcefile/SingleSourceFileUtil.java
rename to java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/SingleSourceFileUtil.java
index 2914ee0a4c00..65b6fc08fd36 100644
--- a/java/java.api.common/src/org/netbeans/modules/java/api/common/singlesourcefile/SingleSourceFileUtil.java
+++ b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/SingleSourceFileUtil.java
@@ -16,7 +16,7 @@
  * specific language governing permissions and limitations
  * under the License.
  */
-package org.netbeans.modules.java.api.common.singlesourcefile;
+package org.netbeans.modules.java.file.launcher;
 
 import java.io.File;
 import java.io.IOException;
@@ -25,9 +25,14 @@
 import java.util.List;
 import java.util.logging.Level;
 import java.util.logging.Logger;
+import javax.swing.event.ChangeListener;
 import org.netbeans.api.java.platform.JavaPlatformManager;
 import org.netbeans.api.project.FileOwnerQuery;
 import org.netbeans.api.project.Project;
+import org.netbeans.modules.java.file.launcher.queries.MultiSourceRootProvider;
+import org.netbeans.modules.java.file.launcher.spi.SingleFileOptionsQueryImplementation;
+import org.netbeans.modules.java.file.launcher.spi.SingleFileOptionsQueryImplementation.Result;
+import org.netbeans.spi.java.queries.CompilerOptionsQueryImplementation;
 import org.openide.filesystems.FileObject;
 import org.openide.filesystems.FileUtil;
 import org.openide.loaders.DataObject;
@@ -37,10 +42,10 @@
  *
  * @author Arunava Sinha
  */
-final class SingleSourceFileUtil {
-    static final Logger LOG = Logger.getLogger(SingleSourceFileUtil.class.getPackage().getName());
+public final class SingleSourceFileUtil {
+    public static final Logger LOG = Logger.getLogger(SingleSourceFileUtil.class.getPackage().getName());
 
-    static int findJavaVersion() throws NumberFormatException {
+    public static int findJavaVersion() throws NumberFormatException {
         // JEP-330 is supported only on JDK-11 and above.
         String javaVersion = System.getProperty("java.specification.version"); //NOI18N
         if (javaVersion.startsWith("1.")) { //NOI18N
@@ -53,7 +58,7 @@ static int findJavaVersion() throws NumberFormatException {
     public static final String FILE_ARGUMENTS = "single_file_run_arguments"; //NOI18N
     public static final String FILE_VM_OPTIONS = "single_file_vm_options"; //NOI18N
 
-    static FileObject getJavaFileWithoutProjectFromLookup(Lookup lookup) {
+    public static FileObject getJavaFileWithoutProjectFromLookup(Lookup lookup) {
         for (DataObject dObj : lookup.lookupAll(DataObject.class)) {
             FileObject fObj = dObj.getPrimaryFile();
             if (isSingleSourceFile(fObj)) {
@@ -68,7 +73,7 @@ static FileObject getJavaFileWithoutProjectFromLookup(Lookup lookup) {
         return null;
     }
 
-    static boolean isSingleSourceFile(FileObject fObj) {
+    public static boolean isSingleSourceFile(FileObject fObj) {
         Project p = FileOwnerQuery.getOwner(fObj);
         if (p != null || !fObj.getExt().equalsIgnoreCase("java")) { //NOI18N
             return false;
@@ -76,7 +81,7 @@ static boolean isSingleSourceFile(FileObject fObj) {
         return true;
     }
 
-    static Process compileJavaSource(FileObject fileObject) {
+    public static Process compileJavaSource(FileObject fileObject) {
         FileObject javac = JavaPlatformManager.getDefault().getDefaultPlatform().findTool("javac"); //NOI18N
         File javacFile = FileUtil.toFile(javac);
         String javacPath = javacFile.getAbsolutePath();
@@ -101,8 +106,46 @@ static Process compileJavaSource(FileObject fileObject) {
         return null;
     }
 
-    static boolean hasClassSibling(FileObject fo) {
+    public static boolean hasClassSibling(FileObject fo) {
         return fo.getParent().getFileObject(fo.getName(), "class") != null;
     }
 
+    public static Result getOptionsFor(FileObject file) {
+        if (MultiSourceRootProvider.DISABLE_MULTI_SOURCE_ROOT) {
+            return null;
+        }
+
+        for (SingleFileOptionsQueryImplementation  i : Lookup.getDefault().lookupAll(SingleFileOptionsQueryImplementation.class)) {
+            Result r = i.optionsFor(file);
+
+            if (r != null) {
+                return r;
+            }
+        }
+        return null;
+    }
+
+    public static List<String> parseLine(String line) {
+        return PARSER.doParse(line);
+    }
+
+    private static final LineParser PARSER = new LineParser();
+
+    private static class LineParser extends CompilerOptionsQueryImplementation.Result {
+        public List<String> doParse(String line) {
+            return parseLine(line);
+        }
+
+        @Override
+        public List<? extends String> getArguments() {
+            return null;
+        }
+
+        @Override
+        public void addChangeListener(ChangeListener listener) {}
+
+        @Override
+        public void removeChangeListener(ChangeListener listener) {}
+    }
+
 }
diff --git a/java/java.api.common/src/org/netbeans/modules/java/api/common/singlesourcefile/JPDAStart.java b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/actions/JPDAStart.java
similarity index 97%
rename from java/java.api.common/src/org/netbeans/modules/java/api/common/singlesourcefile/JPDAStart.java
rename to java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/actions/JPDAStart.java
index 005532cdaf98..ede73c49dfe4 100644
--- a/java/java.api.common/src/org/netbeans/modules/java/api/common/singlesourcefile/JPDAStart.java
+++ b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/actions/JPDAStart.java
@@ -16,7 +16,7 @@
  * specific language governing permissions and limitations
  * under the License.
  */
-package org.netbeans.modules.java.api.common.singlesourcefile;
+package org.netbeans.modules.java.file.launcher.actions;
 
 import java.io.File;
 import java.util.HashMap;
@@ -37,6 +37,7 @@
 
 import org.netbeans.api.java.classpath.ClassPath;
 import org.netbeans.api.debugger.jpda.JPDADebugger;
+import org.netbeans.modules.java.file.launcher.SingleSourceFileUtil;
 import org.netbeans.spi.java.classpath.support.ClassPathSupport;
 import org.openide.windows.InputOutput;
 
diff --git a/java/java.api.common/src/org/netbeans/modules/java/api/common/singlesourcefile/LaunchProcess.java b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/actions/LaunchProcess.java
similarity index 97%
rename from java/java.api.common/src/org/netbeans/modules/java/api/common/singlesourcefile/LaunchProcess.java
rename to java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/actions/LaunchProcess.java
index 4a574834c794..7646ab59554d 100644
--- a/java/java.api.common/src/org/netbeans/modules/java/api/common/singlesourcefile/LaunchProcess.java
+++ b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/actions/LaunchProcess.java
@@ -16,7 +16,7 @@
  * specific language governing permissions and limitations
  * under the License.
  */
-package org.netbeans.modules.java.api.common.singlesourcefile;
+package org.netbeans.modules.java.file.launcher.actions;
 
 import java.io.File;
 import java.io.IOException;
@@ -27,6 +27,7 @@
 import java.util.logging.Level;
 import org.netbeans.api.extexecution.base.ExplicitProcessParameters;
 import org.netbeans.api.java.platform.JavaPlatformManager;
+import org.netbeans.modules.java.file.launcher.SingleSourceFileUtil;
 import org.openide.filesystems.FileObject;
 import org.openide.filesystems.FileUtil;
 import org.openide.util.BaseUtilities;
diff --git a/java/java.api.common/src/org/netbeans/modules/java/api/common/singlesourcefile/SingleJavaSourceRunActionProvider.java b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/actions/SingleJavaSourceRunActionProvider.java
similarity index 96%
rename from java/java.api.common/src/org/netbeans/modules/java/api/common/singlesourcefile/SingleJavaSourceRunActionProvider.java
rename to java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/actions/SingleJavaSourceRunActionProvider.java
index ccbddcecd642..007764c96487 100644
--- a/java/java.api.common/src/org/netbeans/modules/java/api/common/singlesourcefile/SingleJavaSourceRunActionProvider.java
+++ b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/actions/SingleJavaSourceRunActionProvider.java
@@ -16,11 +16,12 @@
  * specific language governing permissions and limitations
  * under the License.
  */
-package org.netbeans.modules.java.api.common.singlesourcefile;
+package org.netbeans.modules.java.file.launcher.actions;
 
 import java.util.concurrent.Future;
 import org.netbeans.api.extexecution.ExecutionDescriptor;
 import org.netbeans.api.extexecution.ExecutionService;
+import org.netbeans.modules.java.file.launcher.SingleSourceFileUtil;
 import org.netbeans.api.extexecution.base.ExplicitProcessParameters;
 import org.netbeans.spi.project.ActionProgress;
 import org.netbeans.spi.project.ActionProvider;
diff --git a/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/api/SourceLauncher.java b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/api/SourceLauncher.java
new file mode 100644
index 000000000000..8603ed6b899b
--- /dev/null
+++ b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/api/SourceLauncher.java
@@ -0,0 +1,118 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.netbeans.modules.java.file.launcher.api;
+
+import java.io.File;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.stream.Collectors;
+import org.netbeans.modules.java.file.launcher.SingleSourceFileUtil;
+import org.netbeans.modules.java.file.launcher.queries.MultiSourceRootProvider;
+import org.openide.filesystems.FileObject;
+import org.openide.modules.SpecificationVersion;
+import org.openide.util.Lookup;
+
+/**Holds utilities for source file launcher.
+ *
+ */
+public final class SourceLauncher {
+
+    private static final String ENABLE_PREVIEW = "--enable-preview";
+    private static final String SOURCE = "--source";
+    private static final String CLASS_PATH = "--class-path";
+    private static final String CLASSPATH = "-classpath";
+    private static final String CP = "-cp";
+    private static final String MODULE_PATH = "--module-path";
+    private static final String P = "-p";
+
+    /**Returns {@code true} if and only if the given file is known as a
+     * file that is handled by a source file launcher. This, in particular,
+     * typically means the file is outside of a project.
+     *
+     * @param file the file to test
+     * @return {@code true} if and only if the file is known as a file handled by the
+     *         source launcher. {@code false} otherwise.
+     */
+    public static boolean isSourceLauncherFile(FileObject file) {
+        MultiSourceRootProvider msrp = Lookup.getDefault().lookup(MultiSourceRootProvider.class);
+        return msrp != null && msrp.isSourceLauncher(file);
+    }
+
+    public static String joinCommandLines(Iterable<? extends String> inputLines) {
+        Map<String, String> joinedOptions = new HashMap<>();
+
+        for (String value : inputLines) {
+            List<String> args = SingleSourceFileUtil.parseLine(value);
+
+            for (int i = 0; i < args.size(); i++) {
+                switch (args.get(i)) {
+                    case ENABLE_PREVIEW:
+                        joinedOptions.put(ENABLE_PREVIEW, null);
+                        break;
+                    case CLASSPATH: case CLASS_PATH: case CP:
+                        if (i + 1 < args.size()) {
+                            joinedOptions.put(CLASS_PATH, mergePaths(joinedOptions.get(CLASS_PATH), args.get(i + 1)));
+                            i++;
+                        }
+                        break;
+                    case MODULE_PATH: case P:
+                        if (i + 1 < args.size()) {
+                            joinedOptions.put(MODULE_PATH, mergePaths(joinedOptions.get(MODULE_PATH), args.get(i + 1)));
+                            i++;
+                        }
+                        break;
+                    case SOURCE:
+                        if (i + 1 < args.size()) {
+                            String version = args.get(i + 1);
+                            String testVersion = version;
+                            if (testVersion.startsWith("1.")) {
+                                testVersion = testVersion.substring(2);
+                            }
+                            String existingVersion = joinedOptions.get(SOURCE);
+                            if (existingVersion != null) {
+                                if (existingVersion.startsWith("1.")) {
+                                    existingVersion = existingVersion.substring(2);
+                                }
+                                if (new SpecificationVersion(testVersion).compareTo(new SpecificationVersion(existingVersion)) > 0) {
+                                    joinedOptions.put(SOURCE, version);
+                                }
+                            } else {
+                                joinedOptions.put(SOURCE, version);
+                            }
+                            i++;
+                        }
+                        break;
+                }
+            }
+        }
+
+        return joinedOptions.entrySet().stream().map(e -> e.getKey() + (e.getValue() != null ? " " + e.getValue() : "")).collect(Collectors.joining(" "));
+    }
+
+    private static String mergePaths(String oldPath, String newPath) {
+        if (oldPath == null) {
+            return newPath;
+        }
+        if (newPath == null) {
+            return oldPath;
+        }
+        return oldPath + File.pathSeparator + newPath;
+    }
+}
diff --git a/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/indexer/CompilerOptionsIndexer.java b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/indexer/CompilerOptionsIndexer.java
new file mode 100644
index 000000000000..d541b4c77600
--- /dev/null
+++ b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/indexer/CompilerOptionsIndexer.java
@@ -0,0 +1,78 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.netbeans.modules.java.file.launcher.indexer;
+
+import org.netbeans.modules.java.file.launcher.SharedRootData;
+import org.netbeans.api.editor.mimelookup.MimeRegistration;
+import org.netbeans.api.project.FileOwnerQuery;
+import org.netbeans.modules.parsing.spi.indexing.Context;
+import org.netbeans.modules.parsing.spi.indexing.CustomIndexer;
+import org.netbeans.modules.parsing.spi.indexing.CustomIndexerFactory;
+import org.netbeans.modules.parsing.spi.indexing.Indexable;
+
+/**
+ *
+ * @author lahvac
+ */
+public class CompilerOptionsIndexer extends CustomIndexer {
+
+
+    @Override
+    protected void index(Iterable<? extends Indexable> files, Context context) {
+        if (FileOwnerQuery.getOwner(context.getRoot()) != null) {
+            return ; //ignore roots under projects
+        }
+        SharedRootData.ensureRootRegistered(context.getRoot());
+    }
+
+
+    @MimeRegistration(mimeType="text/x-java", service=CustomIndexerFactory.class, position=1_000)
+    public static final class FactoryImpl extends CustomIndexerFactory {
+
+        @Override
+        public CustomIndexer createIndexer() {
+            return new CompilerOptionsIndexer();
+        }
+
+        @Override
+        public boolean supportsEmbeddedIndexers() {
+            return true;
+        }
+
+        @Override
+        public void filesDeleted(Iterable<? extends Indexable> deleted, Context context) {
+        }
+
+        @Override
+        public void filesDirty(Iterable<? extends Indexable> dirty, Context context) {
+            //nothing
+        }
+
+        @Override
+        public String getIndexerName() {
+            return "java-launcher-compiler-options";
+        }
+
+        @Override
+        public int getIndexVersion() {
+            return 1;
+        }
+
+    }
+}
diff --git a/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/queries/LauncherSourceLevelQueryImpl.java b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/queries/LauncherSourceLevelQueryImpl.java
new file mode 100644
index 000000000000..f84258ecce93
--- /dev/null
+++ b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/queries/LauncherSourceLevelQueryImpl.java
@@ -0,0 +1,112 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.netbeans.modules.java.file.launcher.queries;
+
+import java.util.List;
+import java.util.Objects;
+import javax.swing.event.ChangeEvent;
+import javax.swing.event.ChangeListener;
+import org.netbeans.api.java.platform.JavaPlatformManager;
+import org.netbeans.modules.java.file.launcher.SingleSourceFileUtil;
+import org.netbeans.modules.java.file.launcher.spi.SingleFileOptionsQueryImplementation;
+import org.netbeans.spi.java.queries.SourceLevelQueryImplementation2;
+import org.openide.filesystems.FileObject;
+import org.openide.util.ChangeSupport;
+import org.openide.util.lookup.ServiceProvider;
+
+/**
+ *
+ * @author lahvac
+ */
+@ServiceProvider(service=SourceLevelQueryImplementation2.class, position=9_999)
+public class LauncherSourceLevelQueryImpl implements SourceLevelQueryImplementation2 {
+
+    @Override
+    public Result getSourceLevel(FileObject javaFile) {
+        SingleFileOptionsQueryImplementation.Result delegate = SingleSourceFileUtil.getOptionsFor(javaFile);
+
+        if (delegate != null) {
+            return new ResultImpl(delegate);
+        } else {
+            return null;
+        }
+    }
+
+    private static final class ResultImpl implements ChangeListener, Result {
+
+        private static final String DEFAULT_SOURCE_LEVEL =
+                JavaPlatformManager.getDefault().getDefaultPlatform().getSpecification().getVersion().toString();
+
+        private final ChangeSupport cs = new ChangeSupport(this);
+        private final SingleFileOptionsQueryImplementation.Result delegate;
+        private String sourceLevel;
+
+        public ResultImpl(SingleFileOptionsQueryImplementation.Result delegate) {
+            this.delegate = delegate;
+            this.delegate.addChangeListener(this);
+            updateDelegate();
+        }
+
+        private void updateDelegate() {
+            List<String> parsed = SingleSourceFileUtil.parseLine(delegate.getOptions());
+            String sourceLevel = DEFAULT_SOURCE_LEVEL;
+
+            for (int i = 0; i < parsed.size(); i++) {
+                if ("--source".equals(parsed.get(i)) && i + 1 < parsed.size()) {
+                    sourceLevel = parsed.get(i + 1);
+                }
+            }
+
+            boolean modified;
+
+            synchronized (this) {
+                modified = !Objects.equals(this.sourceLevel, sourceLevel);
+
+                if (modified) {
+                    this.sourceLevel = sourceLevel;
+                }
+            }
+
+            if (modified) {
+                cs.fireChange();
+            }
+        }
+
+        @Override
+        public void stateChanged(ChangeEvent ce) {
+            updateDelegate();
+        }
+
+        @Override
+        public synchronized String getSourceLevel() {
+            return sourceLevel;
+        }
+
+        @Override
+        public void addChangeListener(ChangeListener listener) {
+            cs.addChangeListener(listener);
+        }
+
+        @Override
+        public void removeChangeListener(ChangeListener listener) {
+            cs.removeChangeListener(listener);
+        }
+
+    }
+}
diff --git a/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/queries/MultiSourceRootProvider.java b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/queries/MultiSourceRootProvider.java
new file mode 100644
index 000000000000..47a8bad00c02
--- /dev/null
+++ b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/queries/MultiSourceRootProvider.java
@@ -0,0 +1,302 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.netbeans.modules.java.file.launcher.queries;
+
+import java.beans.PropertyChangeListener;
+import java.beans.PropertyChangeSupport;
+import java.io.IOException;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.EnumSet;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+import java.util.WeakHashMap;
+import javax.swing.event.ChangeEvent;
+import javax.swing.event.ChangeListener;
+import org.netbeans.api.java.classpath.ClassPath;
+import org.netbeans.api.java.classpath.GlobalPathRegistry;
+import org.netbeans.api.java.classpath.JavaClassPathConstants;
+import org.netbeans.api.java.lexer.JavaTokenId;
+import org.netbeans.api.java.platform.JavaPlatformManager;
+import org.netbeans.api.lexer.TokenHierarchy;
+import org.netbeans.api.lexer.TokenSequence;
+import org.netbeans.api.queries.FileEncodingQuery;
+import org.netbeans.modules.java.file.launcher.SingleSourceFileUtil;
+import org.netbeans.modules.java.file.launcher.spi.SingleFileOptionsQueryImplementation;
+import org.netbeans.spi.java.classpath.ClassPathFactory;
+import org.netbeans.spi.java.classpath.ClassPathImplementation;
+import static org.netbeans.spi.java.classpath.ClassPathImplementation.PROP_RESOURCES;
+import org.netbeans.spi.java.classpath.ClassPathProvider;
+import org.netbeans.spi.java.classpath.PathResourceImplementation;
+import org.netbeans.spi.java.classpath.support.ClassPathSupport;
+import org.openide.filesystems.FileObject;
+import org.openide.filesystems.FileUtil;
+import org.openide.util.Exceptions;
+import org.openide.util.lookup.ServiceProvider;
+import org.openide.util.lookup.ServiceProviders;
+
+@ServiceProviders({
+    @ServiceProvider(service=ClassPathProvider.class, position=9_999),
+    @ServiceProvider(service=MultiSourceRootProvider.class)
+})
+public class MultiSourceRootProvider implements ClassPathProvider {
+
+    public static boolean DISABLE_MULTI_SOURCE_ROOT = false;
+
+    //TODO: the cache will probably be never cleared, as the ClassPath/value refers to the key(?)
+    private Map<FileObject, ClassPath> file2SourceCP = new WeakHashMap<>();
+    private Map<FileObject, ClassPath> root2SourceCP = new WeakHashMap<>();
+    private Map<FileObject, ClassPath> file2AllPath = new WeakHashMap<>();
+    private Map<FileObject, ClassPath> file2ClassPath = new WeakHashMap<>();
+    private Map<FileObject, ClassPath> file2ModulePath = new WeakHashMap<>();
+
+    @Override
+    public ClassPath findClassPath(FileObject file, String type) {
+        switch (type) {
+            case ClassPath.SOURCE: return getSourcePath(file);
+            case ClassPath.COMPILE:
+                return attributeBasedPath(file, file2AllPath, "-classpath", "-cp", "--class-path", "--module-path", "-p");
+            case JavaClassPathConstants.MODULE_CLASS_PATH:
+                return attributeBasedPath(file, file2ClassPath, "-classpath", "-cp", "--class-path");
+            case JavaClassPathConstants.MODULE_COMPILE_PATH:
+                return attributeBasedPath(file, file2ModulePath, "--module-path", "-p");
+            case ClassPath.BOOT:
+            case JavaClassPathConstants.MODULE_BOOT_PATH:
+                return getBootPath(file);
+        }
+        return null;
+    }
+
+    private ClassPath getSourcePath(FileObject file) {
+        if (DISABLE_MULTI_SOURCE_ROOT) return null;
+        synchronized (this) {
+            //XXX: what happens if there's a Java file in user's home???
+            if (file.isData() && "text/x-java".equals(file.getMIMEType())) {
+                return file2SourceCP.computeIfAbsent(file, f -> {
+                    try {
+                        String content = new String(file.asBytes(), FileEncodingQuery.getEncoding(file));
+                        String packName = findPackage(content);
+                        FileObject root = file.getParent();
+
+                        if (packName != null) {
+                            List<String> packageParts = Arrays.asList(packName.split("\\."));
+
+                            Collections.reverse(packageParts);
+
+                            for (String packagePart : packageParts) {
+                                if (!root.getNameExt().equalsIgnoreCase(packagePart)) {
+                                    //ignore files outside of proper package structure,
+                                    //those may too easily lead to using a too general
+                                    //directory as a root, leading to too much indexing:
+                                    return null;
+                                }
+                                root = root.getParent();
+                            }
+                        }
+
+                        return root2SourceCP.computeIfAbsent(root, r -> {
+                            ClassPath srcCP = ClassPathSupport.createClassPath(r);
+                            GlobalPathRegistry.getDefault().register(ClassPath.SOURCE, new ClassPath[] {srcCP});
+                            return srcCP;
+                        });
+                    } catch (IOException ex) {
+                        Exceptions.printStackTrace(ex);
+                    }
+                    return null;
+                });
+            } else {
+                FileObject folder = file;
+
+                while (!folder.isRoot()) {
+                    ClassPath cp = root2SourceCP.get(folder);
+
+                    if (cp != null) {
+                        return cp;
+                    }
+
+                    folder = folder.getParent();
+                }
+
+                return null;
+            }
+        }
+    }
+
+    private synchronized FileObject getSourceRootImpl(FileObject file) {
+        for (FileObject root : root2SourceCP.keySet()) {
+            if (root.equals(file) || FileUtil.isParentOf(root, file)) {
+                return root;
+            }
+        }
+
+        return null;
+    }
+
+    public FileObject getSourceRoot(FileObject file) {
+        FileObject root = getSourceRootImpl(file);
+
+        if (root == null) {
+            getSourcePath(file);
+            root = getSourceRootImpl(file);
+        }
+
+        return root;
+    }
+
+    public boolean isSourceLauncher(FileObject file) {
+        return getSourceRoot(file) != null;
+    }
+
+    private ClassPath getBootPath(FileObject file) {
+        if (isSourceLauncher(file)) {
+            return JavaPlatformManager.getDefault()
+                                      .getDefaultPlatform()
+                                      .getBootstrapLibraries();
+        }
+
+        return null;
+    }
+
+    private static final Set<JavaTokenId> IGNORED_TOKENS = EnumSet.of(
+        JavaTokenId.BLOCK_COMMENT,
+        JavaTokenId.JAVADOC_COMMENT,
+        JavaTokenId.LINE_COMMENT,
+        JavaTokenId.WHITESPACE
+    );
+
+    private static final Set<JavaTokenId> STOP_TOKENS = EnumSet.of(
+        JavaTokenId.IMPORT,
+        JavaTokenId.PUBLIC,
+        JavaTokenId.PROTECTED,
+        JavaTokenId.PRIVATE,
+        JavaTokenId.CLASS,
+        JavaTokenId.LBRACE
+    );
+
+    static String findPackage(String fileContext) {
+        TokenHierarchy<String> th = TokenHierarchy.create(fileContext, true, JavaTokenId.language(), IGNORED_TOKENS, null);
+        TokenSequence<JavaTokenId> ts = th.tokenSequence(JavaTokenId.language());
+
+        ts.moveStart();
+
+        while (ts.moveNext()) {
+            if (ts.token().id() == JavaTokenId.PACKAGE) {
+                StringBuilder packageName = new StringBuilder();
+                while (ts.moveNext() && (ts.token().id() == JavaTokenId.DOT || ts.token().id() == JavaTokenId.IDENTIFIER)) {
+                    packageName.append(ts.token().text());
+                }
+                return packageName.toString();
+            } else if (STOP_TOKENS.contains(ts.token().id())) {
+                break;
+            }
+        }
+
+        return null;
+    }
+
+    private ClassPath attributeBasedPath(FileObject file, Map<FileObject, ClassPath> file2ClassPath, String... optionKeys) {
+        if (!isSourceLauncher(file)) {
+            return null;
+        }
+
+        synchronized (this) {
+        return file2ClassPath.computeIfAbsent(file, f -> {
+            SingleFileOptionsQueryImplementation.Result delegate = SingleSourceFileUtil.getOptionsFor(f);
+
+            if (delegate == null) {
+                return null;
+            }
+            AttributeBasedClassPathImplementation cpi = new AttributeBasedClassPathImplementation(delegate, optionKeys);
+
+            return ClassPathFactory.createClassPath(cpi);
+        });
+        }
+    }
+
+    private static final class AttributeBasedClassPathImplementation implements ChangeListener, ClassPathImplementation {
+        private final PropertyChangeSupport pcs = new PropertyChangeSupport(this);
+        private final SingleFileOptionsQueryImplementation.Result delegate;
+        private final Set<String> optionKeys;
+        private Set<URL> currentURLs;
+        private List<? extends PathResourceImplementation> delegates = Collections.emptyList();
+
+        public AttributeBasedClassPathImplementation(SingleFileOptionsQueryImplementation.Result delegate, String... optionKeys) {
+            this.delegate = delegate;
+            this.optionKeys = new HashSet<>(Arrays.asList(optionKeys));
+            delegate.addChangeListener(this);
+            updateDelegates();
+        }
+
+        @Override
+        public void stateChanged(ChangeEvent ce) {
+            updateDelegates();
+        }
+
+        private void updateDelegates() {
+            Set<URL> newURLs = new HashSet<>();
+            List<PathResourceImplementation> newDelegates = new ArrayList<>();
+            List<String> parsed = SingleSourceFileUtil.parseLine(delegate.getOptions());
+
+            for (int i = 0; i < parsed.size(); i++) {
+                if (optionKeys.contains(parsed.get(i)) && i + 1 < parsed.size()) {
+                    ClassPathSupport.createClassPath(parsed.get(i + 1))
+                        .entries()
+                        .stream()
+                        .map(e -> e.getURL())
+                        .forEach(u -> {
+                            newURLs.add(u);
+                            newDelegates.add(ClassPathSupport.createResource(u));
+                        });
+                }
+            }
+
+            synchronized (this) {
+                if (Objects.equals(currentURLs, newURLs)) {
+                    return ;
+                }
+                this.currentURLs = newURLs;
+                this.delegates = newDelegates;
+            }
+
+            pcs.firePropertyChange(PROP_RESOURCES, null, null);
+        }
+
+        @Override
+        public synchronized List<? extends PathResourceImplementation> getResources() {
+            return delegates;
+        }
+
+        @Override
+        public void addPropertyChangeListener(PropertyChangeListener listener) {
+            pcs.addPropertyChangeListener(listener);
+        }
+
+        @Override
+        public void removePropertyChangeListener(PropertyChangeListener listener) {
+            pcs.removePropertyChangeListener(listener);
+        }
+
+    }
+
+}
diff --git a/java/java.api.common/src/org/netbeans/modules/java/api/common/singlesourcefile/SingleSourceCompilerOptQueryImpl.java b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/queries/SingleSourceCompilerOptQueryImpl.java
similarity index 69%
rename from java/java.api.common/src/org/netbeans/modules/java/api/common/singlesourcefile/SingleSourceCompilerOptQueryImpl.java
rename to java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/queries/SingleSourceCompilerOptQueryImpl.java
index eea975a0a659..28d08d914e16 100644
--- a/java/java.api.common/src/org/netbeans/modules/java/api/common/singlesourcefile/SingleSourceCompilerOptQueryImpl.java
+++ b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/queries/SingleSourceCompilerOptQueryImpl.java
@@ -16,13 +16,13 @@
  * specific language governing permissions and limitations
  * under the License.
  */
-package org.netbeans.modules.java.api.common.singlesourcefile;
+package org.netbeans.modules.java.file.launcher.queries;
 
-import java.beans.PropertyChangeEvent;
-import java.beans.PropertyChangeListener;
-import java.util.ArrayList;
 import java.util.List;
+import javax.swing.event.ChangeEvent;
 import javax.swing.event.ChangeListener;
+import org.netbeans.modules.java.file.launcher.SingleSourceFileUtil;
+import org.netbeans.modules.java.file.launcher.spi.SingleFileOptionsQueryImplementation;
 import org.netbeans.spi.java.queries.CompilerOptionsQueryImplementation;
 import org.openide.filesystems.FileObject;
 import org.openide.util.ChangeSupport;
@@ -37,30 +37,29 @@ public class SingleSourceCompilerOptQueryImpl implements CompilerOptionsQueryImp
 
     @Override
     public CompilerOptionsQueryImplementation.Result getOptions(FileObject file) {
-        String fileName = file.getName();
-        Result res = null;
-        if (SingleSourceFileUtil.isSingleSourceFile(file)) {
-            res = new ResultImpl(file);
+        SingleFileOptionsQueryImplementation.Result delegate = SingleSourceFileUtil.getOptionsFor(file);
+
+        if (delegate != null) {
+            return new ResultImpl(delegate);
+        } else {
+            return null;
         }
-        return res;
     }
 
-    private static final class ResultImpl extends CompilerOptionsQueryImplementation.Result implements PropertyChangeListener {
+    private static final class ResultImpl extends CompilerOptionsQueryImplementation.Result implements ChangeListener {
 
         private final ChangeSupport cs;
-        private final FileObject file;
-
-        ResultImpl(FileObject file) {
+        private final SingleFileOptionsQueryImplementation.Result delegate;
 
+        ResultImpl(SingleFileOptionsQueryImplementation.Result delegate) {
             this.cs = new ChangeSupport(this);
-            this.file = file;
+            this.delegate = delegate;
+            this.delegate.addChangeListener(this);
         }
 
         @Override
         public List<? extends String> getArguments() {
-
-            Object vmOptionsObj = file.getAttribute(SingleSourceFileUtil.FILE_VM_OPTIONS);
-            return vmOptionsObj != null ? parseLine((String) vmOptionsObj) : new ArrayList<String>();
+            return parseLine(delegate.getOptions());
         }
 
         @Override
@@ -74,7 +73,7 @@ public void removeChangeListener(ChangeListener listener) {
         }
 
         @Override
-        public void propertyChange(PropertyChangeEvent evt) {
+        public void stateChanged(ChangeEvent ce) {
             cs.fireChange();
         }
     }
diff --git a/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/spi/SingleFileOptionsQueryImplementation.java b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/spi/SingleFileOptionsQueryImplementation.java
new file mode 100644
index 000000000000..ed29d610d89d
--- /dev/null
+++ b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/spi/SingleFileOptionsQueryImplementation.java
@@ -0,0 +1,33 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.netbeans.modules.java.file.launcher.spi;
+
+import javax.swing.event.ChangeListener;
+import org.openide.filesystems.FileObject;
+
+public interface SingleFileOptionsQueryImplementation {
+
+    public Result optionsFor(FileObject file);
+
+    public interface Result {
+        public String getOptions();
+        public void addChangeListener(ChangeListener l);
+        public void removeChangeListener(ChangeListener l);
+    }
+}
diff --git a/java/java.api.common/src/org/netbeans/modules/java/api/common/singlesourcefile/Description.html b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/templates/Description.html
similarity index 100%
rename from java/java.api.common/src/org/netbeans/modules/java/api/common/singlesourcefile/Description.html
rename to java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/templates/Description.html
diff --git a/java/java.api.common/src/org/netbeans/modules/java/api/common/singlesourcefile/File.java.template b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/templates/File.java.template
similarity index 100%
rename from java/java.api.common/src/org/netbeans/modules/java/api/common/singlesourcefile/File.java.template
rename to java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/templates/File.java.template
diff --git a/java/java.api.common/src/org/netbeans/modules/java/api/common/singlesourcefile/package-info.java b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/templates/package-info.java
similarity index 95%
rename from java/java.api.common/src/org/netbeans/modules/java/api/common/singlesourcefile/package-info.java
rename to java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/templates/package-info.java
index 3785a46c2e3b..afc9351fab0b 100644
--- a/java/java.api.common/src/org/netbeans/modules/java/api/common/singlesourcefile/package-info.java
+++ b/java/java.file.launcher/src/org/netbeans/modules/java/file/launcher/templates/package-info.java
@@ -19,7 +19,7 @@
 @TemplateRegistration(folder = "Other", iconBase = JavaTemplates.JAVA_ICON, displayName = "#JAVAtemplate_displayName", content = "File.java.template", requireProject = false, targetName = "newJavaFile", description = "Description.html", scriptEngine = "freemarker", category = {"java-main-class"}, position=300)
         
 @Messages(value = "JAVAtemplate_displayName=Java File")
-package org.netbeans.modules.java.api.common.singlesourcefile;
+package org.netbeans.modules.java.file.launcher.templates;
 
 import org.netbeans.api.templates.TemplateRegistration;
 import org.netbeans.spi.java.project.support.ui.templates.JavaTemplates;
diff --git a/java/java.file.launcher/test/unit/src/org/netbeans/modules/java/file/launcher/SharedRootDataTest.java b/java/java.file.launcher/test/unit/src/org/netbeans/modules/java/file/launcher/SharedRootDataTest.java
new file mode 100644
index 000000000000..6fd8083a3634
--- /dev/null
+++ b/java/java.file.launcher/test/unit/src/org/netbeans/modules/java/file/launcher/SharedRootDataTest.java
@@ -0,0 +1,86 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.netbeans.modules.java.file.launcher;
+
+import java.io.File;
+import java.io.IOException;
+import org.netbeans.junit.NbTestCase;
+import org.openide.filesystems.FileObject;
+import org.openide.filesystems.FileUtil;
+
+public class SharedRootDataTest extends NbTestCase {
+
+    public SharedRootDataTest(String name) {
+        super(name);
+    }
+
+    public void testSourceLevels() throws IOException {
+        clearWorkDir();
+
+        File wd = getWorkDir();
+        FileObject root = FileUtil.toFileObject(wd);
+        FileObject file1 = FileUtil.createData(root, "File1.java");
+        FileObject file2 = FileUtil.createData(root, "File2.java");
+
+        SharedRootData.ensureRootRegistered(root);
+
+        SharedRootData data = SharedRootData.getDataForRoot(root);
+
+        assertNotNull(data);
+        file1.setAttribute(SingleSourceFileUtil.FILE_VM_OPTIONS, "--enable-preview --source 1.7");
+        assertEquals("--enable-preview --source 1.7", root.getAttribute(SingleSourceFileUtil.FILE_VM_OPTIONS));
+        file2.setAttribute(SingleSourceFileUtil.FILE_VM_OPTIONS, "--enable-preview --source 17");
+        assertEquals("--enable-preview --source 17", root.getAttribute(SingleSourceFileUtil.FILE_VM_OPTIONS));
+        file2.setAttribute(SingleSourceFileUtil.FILE_VM_OPTIONS, "--enable-preview --source 1.8");
+        assertEquals("--enable-preview --source 1.8", root.getAttribute(SingleSourceFileUtil.FILE_VM_OPTIONS));
+        file1.setAttribute(SingleSourceFileUtil.FILE_VM_OPTIONS, "--enable-preview --source 11");
+        assertEquals("--enable-preview --source 11", root.getAttribute(SingleSourceFileUtil.FILE_VM_OPTIONS));
+
+        file1.delete();
+        assertEquals("--enable-preview --source 1.8", root.getAttribute(SingleSourceFileUtil.FILE_VM_OPTIONS));
+    }
+
+    public void testPathMerging() throws IOException {
+        clearWorkDir();
+
+        File wd = getWorkDir();
+        FileObject wdFO = FileUtil.toFileObject(wd);
+        FileObject root = FileUtil.createFolder(wdFO, "root");
+        FileObject file1 = FileUtil.createData(root, "File1.java");
+        FileObject file2 = FileUtil.createData(root, "File2.java");
+        FileObject test1Jar = FileUtil.createData(wdFO, "test1.jar");
+        FileObject test2Jar = FileUtil.createData(wdFO, "test2.jar");
+
+        SharedRootData.ensureRootRegistered(root);
+
+        SharedRootData data = SharedRootData.getDataForRoot(root);
+
+        assertNotNull(data);
+        file1.setAttribute(SingleSourceFileUtil.FILE_VM_OPTIONS, "--class-path test1.jar");
+        assertEquals("--class-path test1.jar", root.getAttribute(SingleSourceFileUtil.FILE_VM_OPTIONS));
+        file2.setAttribute(SingleSourceFileUtil.FILE_VM_OPTIONS, "-cp test2.jar");
+        assertEquals("--class-path test1.jar" + File.pathSeparator + "test2.jar", root.getAttribute(SingleSourceFileUtil.FILE_VM_OPTIONS));
+
+        file1.setAttribute(SingleSourceFileUtil.FILE_VM_OPTIONS, "--module-path test1.jar");
+        assertEquals("--class-path test2.jar --module-path test1.jar", root.getAttribute(SingleSourceFileUtil.FILE_VM_OPTIONS));
+        file2.setAttribute(SingleSourceFileUtil.FILE_VM_OPTIONS, "--module-path test2.jar");
+        assertEquals("--module-path test1.jar" + File.pathSeparator + "test2.jar", root.getAttribute(SingleSourceFileUtil.FILE_VM_OPTIONS));
+    }
+
+}
diff --git a/java/java.api.common/test/unit/src/org/netbeans/modules/java/api/common/singlesourcefile/SingleSourceFileUtilTest.java b/java/java.file.launcher/test/unit/src/org/netbeans/modules/java/file/launcher/SingleSourceFileUtilTest.java
similarity index 97%
rename from java/java.api.common/test/unit/src/org/netbeans/modules/java/api/common/singlesourcefile/SingleSourceFileUtilTest.java
rename to java/java.file.launcher/test/unit/src/org/netbeans/modules/java/file/launcher/SingleSourceFileUtilTest.java
index 016eab8e09bf..c9e63c0d6fac 100644
--- a/java/java.api.common/test/unit/src/org/netbeans/modules/java/api/common/singlesourcefile/SingleSourceFileUtilTest.java
+++ b/java/java.file.launcher/test/unit/src/org/netbeans/modules/java/file/launcher/SingleSourceFileUtilTest.java
@@ -16,7 +16,7 @@
  * specific language governing permissions and limitations
  * under the License.
  */
-package org.netbeans.modules.java.api.common.singlesourcefile;
+package org.netbeans.modules.java.file.launcher;
 
 import java.io.IOException;
 import org.junit.Test;
diff --git a/java/java.api.common/test/unit/src/org/netbeans/modules/java/api/common/singlesourcefile/JavaFileTest.java b/java/java.file.launcher/test/unit/src/org/netbeans/modules/java/file/launcher/actions/JavaFileTest.java
similarity index 96%
rename from java/java.api.common/test/unit/src/org/netbeans/modules/java/api/common/singlesourcefile/JavaFileTest.java
rename to java/java.file.launcher/test/unit/src/org/netbeans/modules/java/file/launcher/actions/JavaFileTest.java
index 2c616b2b9504..38fb8ef3d91b 100644
--- a/java/java.api.common/test/unit/src/org/netbeans/modules/java/api/common/singlesourcefile/JavaFileTest.java
+++ b/java/java.file.launcher/test/unit/src/org/netbeans/modules/java/file/launcher/actions/JavaFileTest.java
@@ -16,7 +16,7 @@
  * specific language governing permissions and limitations
  * under the License.
  */
-package org.netbeans.modules.java.api.common.singlesourcefile;
+package org.netbeans.modules.java.file.launcher.actions;
 
 import java.io.BufferedReader;
 import java.io.File;
@@ -26,6 +26,7 @@
 import static junit.framework.TestCase.assertEquals;
 import org.netbeans.api.extexecution.base.ExplicitProcessParameters;
 import org.netbeans.junit.NbTestCase;
+import org.netbeans.modules.java.file.launcher.SingleSourceFileUtil;
 import org.openide.filesystems.FileObject;
 import org.openide.filesystems.FileUtil;
 
diff --git a/java/java.file.launcher/test/unit/src/org/netbeans/modules/java/file/launcher/queries/MultiSourceRootProviderTest.java b/java/java.file.launcher/test/unit/src/org/netbeans/modules/java/file/launcher/queries/MultiSourceRootProviderTest.java
new file mode 100644
index 000000000000..48083a04b762
--- /dev/null
+++ b/java/java.file.launcher/test/unit/src/org/netbeans/modules/java/file/launcher/queries/MultiSourceRootProviderTest.java
@@ -0,0 +1,64 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.netbeans.modules.java.file.launcher.queries;
+
+import org.netbeans.api.java.classpath.ClassPath;
+import org.netbeans.api.java.source.TestUtilities;
+import org.netbeans.junit.NbTestCase;
+import org.openide.filesystems.FileObject;
+import org.openide.filesystems.FileUtil;
+
+/**
+ *
+ * @author lahvac
+ */
+public class MultiSourceRootProviderTest extends NbTestCase {
+
+    public MultiSourceRootProviderTest(String name) {
+        super(name);
+    }
+
+    public void testFindPackage() {
+        assertEquals("test.pack.nested", MultiSourceRootProvider.findPackage("/*package*/package test/**pack*/\n.pack.//package\nnested;"));
+        assertEquals(null, MultiSourceRootProvider.findPackage("/*package pack*/"));
+    }
+
+    public void testSourcePathFiltering() throws Exception {
+        clearWorkDir();
+
+        FileObject wd = FileUtil.toFileObject(getWorkDir());
+        FileObject validTest = FileUtil.createData(wd, "valid/pack/Test1.java");
+        FileObject invalidTest1 = FileUtil.createData(wd, "valid/pack/Test2.java");
+        FileObject invalidTest2 = FileUtil.createData(wd, "valid/pack/Test3.java");
+
+        TestUtilities.copyStringToFile(validTest, "package valid.pack;");
+        TestUtilities.copyStringToFile(invalidTest1, "package invalid.pack;");
+        TestUtilities.copyStringToFile(invalidTest2, "package invalid;");
+
+        MultiSourceRootProvider provider = new MultiSourceRootProvider();
+        ClassPath valid = provider.findClassPath(validTest, ClassPath.SOURCE);
+
+        assertNotNull(valid);
+        assertEquals(1, valid.entries().size());
+        assertEquals(wd, valid.getRoots()[0]);
+
+        assertNull(provider.findClassPath(invalidTest1, ClassPath.SOURCE));
+        assertNull(provider.findClassPath(invalidTest2, ClassPath.SOURCE));
+    }
+}
diff --git a/java/java.hints.declarative/src/org/netbeans/modules/java/hints/declarative/test/TestPerformer.java b/java/java.hints.declarative/src/org/netbeans/modules/java/hints/declarative/test/TestPerformer.java
index 5e2438cae635..657d4bdbd348 100644
--- a/java/java.hints.declarative/src/org/netbeans/modules/java/hints/declarative/test/TestPerformer.java
+++ b/java/java.hints.declarative/src/org/netbeans/modules/java/hints/declarative/test/TestPerformer.java
@@ -265,12 +265,10 @@ public String getSourceLevel() {
 
             @Override
             public void addChangeListener(ChangeListener listener) {
-                throw new UnsupportedOperationException("Not implemented.");
             }
 
             @Override
             public void removeChangeListener(ChangeListener listener) {
-                throw new UnsupportedOperationException("Not implemented.");
             }
         }
         
diff --git a/java/java.hints.test/src/org/netbeans/modules/java/hints/test/api/HintTest.java b/java/java.hints.test/src/org/netbeans/modules/java/hints/test/api/HintTest.java
index 4e59f3257ca3..02beebcf0753 100644
--- a/java/java.hints.test/src/org/netbeans/modules/java/hints/test/api/HintTest.java
+++ b/java/java.hints.test/src/org/netbeans/modules/java/hints/test/api/HintTest.java
@@ -109,7 +109,7 @@
 import org.netbeans.spi.java.hints.JavaFix;
 import org.netbeans.spi.java.queries.CompilerOptionsQueryImplementation;
 import org.netbeans.spi.java.queries.SourceForBinaryQueryImplementation;
-import org.netbeans.spi.java.queries.SourceLevelQueryImplementation;
+import org.netbeans.spi.java.queries.SourceLevelQueryImplementation2;
 import org.netbeans.spi.lexer.MutableTextInput;
 import org.openide.LifecycleManager;
 import org.openide.cookies.EditorCookie;
@@ -718,12 +718,29 @@ public ClassPath findClassPath(FileObject file, String type) {
 
     }
 
-    private class TestSourceLevelQueryImplementation implements SourceLevelQueryImplementation {
+    private class TestSourceLevelQueryImplementation implements SourceLevelQueryImplementation2 {
 
-        public String getSourceLevel(FileObject javaFile) {
-            return sourceLevel;
+        private final Result result = new ResultImpl();
+
+        @Override
+        public Result getSourceLevel(FileObject javaFile) {
+            return result;
         }
 
+        private class ResultImpl implements Result {
+
+            @Override
+            public String getSourceLevel() {
+                return sourceLevel;
+            }
+
+            @Override
+            public void addChangeListener(ChangeListener l) {}
+
+            @Override
+            public void removeChangeListener(ChangeListener l) {}
+
+        }
     }
 
     private class TestCompilerOptionsQueryImplementation implements CompilerOptionsQueryImplementation {
@@ -1262,6 +1279,12 @@ public int compare (ErrorDescription e1, ErrorDescription e2) {
     static {
         System.setProperty("org.openide.util.Lookup", TestLookup.class.getName());
         assertEquals(TestLookup.class, Lookup.getDefault().getClass());
+        try {
+            Class multiSourceRootProvider = Class.forName("org.netbeans.modules.java.file.launcher.queries.MultiSourceRootProvider");
+            multiSourceRootProvider.getField("DISABLE_MULTI_SOURCE_ROOT").set(null, true);
+        } catch (Exception ex) {
+            //ignore
+        }
     }
 
     //workdir computation (copied from NbTestCase):
diff --git a/java/java.kit/nbproject/project.xml b/java/java.kit/nbproject/project.xml
index be9d02dac121..cbc93c33361c 100644
--- a/java/java.kit/nbproject/project.xml
+++ b/java/java.kit/nbproject/project.xml
@@ -95,6 +95,12 @@
                         <specification-version>1.6</specification-version>
                     </run-dependency>
                 </dependency>
+                <dependency>
+                    <code-name-base>org.netbeans.modules.java.file.launcher</code-name-base>
+                    <run-dependency>
+                        <specification-version>1.0</specification-version>
+                    </run-dependency>
+                </dependency>
                 <dependency>
                     <code-name-base>org.netbeans.modules.java.freeform</code-name-base>
                     <run-dependency>
diff --git a/java/java.lsp.server/nbproject/project.xml b/java/java.lsp.server/nbproject/project.xml
index 24a039f7f86b..2994df98cff1 100644
--- a/java/java.lsp.server/nbproject/project.xml
+++ b/java/java.lsp.server/nbproject/project.xml
@@ -347,6 +347,14 @@
                         <implementation-version/>
                     </run-dependency>
                 </dependency>
+                <dependency>
+                    <code-name-base>org.netbeans.modules.java.file.launcher</code-name-base>
+                    <build-prerequisite/>
+                    <compile-dependency/>
+                    <run-dependency>
+                        <specification-version>1.0</specification-version>
+                    </run-dependency>
+                </dependency>
                 <dependency>
                     <code-name-base>org.netbeans.modules.java.hints</code-name-base>
                     <build-prerequisite/>
diff --git a/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/TextDocumentServiceImpl.java b/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/TextDocumentServiceImpl.java
index a21dd42572af..4b5b7839e3fd 100644
--- a/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/TextDocumentServiceImpl.java
+++ b/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/TextDocumentServiceImpl.java
@@ -257,6 +257,7 @@
 import org.openide.util.Union2;
 import org.openide.util.WeakSet;
 import org.openide.util.lookup.Lookups;
+import org.openide.util.lookup.ProxyLookup;
 import org.openide.util.lookup.ServiceProvider;
 
 /**
@@ -315,7 +316,14 @@ public void indexingComplete(Set<URL> indexedRoots) {
                 delegates = this.delegates.toArray(new TextDocumentServiceImpl[this.delegates.size()]);
             }
             for (TextDocumentServiceImpl delegate : delegates) {
-                delegate.reRunDiagnostics();
+                //augmenting the lookup with NbCodeLanguageClient, so that the
+                //correct javac configuration is used for project-less files
+                //note this lookup does not contain other services usually present
+                //while processing a request, like OperationContext:
+                ProxyLookup augmentedLookup = new ProxyLookup(Lookups.fixed(delegate.client), Lookup.getDefault());
+                Lookups.executeWith(augmentedLookup, () -> {
+                    delegate.reRunDiagnostics();
+                });
             }
         }
     }
@@ -1868,6 +1876,9 @@ private void runDiagnosticTasks(String uri, boolean force) {
                 SourceAccessor.getINSTANCE().invalidate(Source.create(originalDoc), true);
             }
         }
+        if (Lookup.getDefault().lookup(NbCodeLanguageClient.class) == null) {
+            new Exception("no NbCodeLanguageClient!").printStackTrace();
+        }
 
         diagnosticTasks.computeIfAbsent(uri, u -> {
             return BACKGROUND_TASKS.create(() -> {
diff --git a/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/WorkspaceServiceImpl.java b/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/WorkspaceServiceImpl.java
index e33782964063..7d11bd70d001 100644
--- a/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/WorkspaceServiceImpl.java
+++ b/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/WorkspaceServiceImpl.java
@@ -123,7 +123,7 @@
 import org.netbeans.modules.java.lsp.server.debugging.attach.AttachConfigurations;
 import org.netbeans.modules.java.lsp.server.debugging.attach.AttachNativeConfigurations;
 import org.netbeans.modules.java.lsp.server.project.LspProjectInfo;
-import org.netbeans.modules.java.lsp.server.singlesourcefile.CompilerOptionsQueryImpl;
+import org.netbeans.modules.java.lsp.server.singlesourcefile.SingleFileOptionsQueryImpl;
 import org.netbeans.modules.java.source.ElementHandleAccessor;
 import org.netbeans.modules.java.source.ui.JavaSymbolProvider;
 import org.netbeans.modules.java.source.ui.JavaTypeProvider;
@@ -1298,7 +1298,7 @@ public void didChangeConfiguration(DidChangeConfigurationParams params) {
             }
         });
         String fullAltConfigPrefix = client.getNbCodeCapabilities().getAltConfigurationPrefix();
-        String altConfigPrefix = fullConfigPrefix.substring(0, fullAltConfigPrefix.length() - 1);
+        String altConfigPrefix = fullAltConfigPrefix.substring(0, fullAltConfigPrefix.length() - 1);
         boolean modified = false;
         String newVMOptions = "";
         JsonObject javaPlus = ((JsonObject) params.getSettings()).getAsJsonObject(altConfigPrefix);
@@ -1308,7 +1308,7 @@ public void didChangeConfiguration(DidChangeConfigurationParams params) {
                 newVMOptions = runConfig.getAsJsonPrimitive("vmOptions").getAsString();
             }
         }
-        for (CompilerOptionsQueryImpl query : Lookup.getDefault().lookupAll(CompilerOptionsQueryImpl.class)) {
+        for (SingleFileOptionsQueryImpl query : Lookup.getDefault().lookupAll(SingleFileOptionsQueryImpl.class)) {
             modified |= query.setConfiguration(client, newVMOptions);
         }
         if (modified) {
diff --git a/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/singlesourcefile/CompilerOptionsQueryImpl.java b/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/singlesourcefile/CompilerOptionsQueryImpl.java
deleted file mode 100644
index 487b8557dad1..000000000000
--- a/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/singlesourcefile/CompilerOptionsQueryImpl.java
+++ /dev/null
@@ -1,307 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.netbeans.modules.java.lsp.server.singlesourcefile;
-
-import java.beans.PropertyChangeListener;
-import java.beans.PropertyChangeSupport;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-import java.util.WeakHashMap;
-import java.util.stream.Collectors;
-import javax.lang.model.SourceVersion;
-import javax.swing.event.ChangeListener;
-import org.netbeans.api.java.classpath.ClassPath;
-import org.netbeans.api.java.classpath.JavaClassPathConstants;
-import org.netbeans.api.project.FileOwnerQuery;
-import org.netbeans.api.project.Project;
-import org.netbeans.modules.java.lsp.server.protocol.NbCodeLanguageClient;
-import org.netbeans.spi.java.classpath.ClassPathFactory;
-import org.netbeans.spi.java.classpath.ClassPathImplementation;
-import org.netbeans.spi.java.classpath.ClassPathProvider;
-import org.netbeans.spi.java.classpath.PathResourceImplementation;
-import org.netbeans.spi.java.classpath.support.ClassPathSupport;
-import org.netbeans.spi.java.queries.CompilerOptionsQueryImplementation;
-import org.netbeans.spi.java.queries.SourceLevelQueryImplementation2;
-import org.openide.filesystems.FileObject;
-import org.openide.util.ChangeSupport;
-import org.openide.util.Lookup;
-import org.openide.util.lookup.ServiceProvider;
-import org.openide.util.lookup.ServiceProviders;
-
-@ServiceProviders({
-    @ServiceProvider(service=CompilerOptionsQueryImplementation.class, position=99),
-    @ServiceProvider(service=ClassPathProvider.class, position=9999), //DefaultClassPathProvider has 10000
-    @ServiceProvider(service=CompilerOptionsQueryImpl.class)
-})
-public class CompilerOptionsQueryImpl implements CompilerOptionsQueryImplementation, ClassPathProvider, SourceLevelQueryImplementation2 {
-
-    private final Map<NbCodeLanguageClient, Configuration> file2Configuration = new WeakHashMap<>();
-
-    @Override
-    public CompilerOptionsQueryImplementation.Result getOptions(FileObject file) {
-        if (isSingleSourceFile(file)) {
-            NbCodeLanguageClient client = Lookup.getDefault().lookup(NbCodeLanguageClient.class);
-            if (client != null) {
-                return getConfiguration(client).compilerOptions;
-            }
-        }
-        return null;
-    }
-
-    @Override
-    public ClassPath findClassPath(FileObject file, String type) {
-        if (isSingleSourceFile(file)) {
-            NbCodeLanguageClient client = Lookup.getDefault().lookup(NbCodeLanguageClient.class);
-            if (client != null) {
-                switch (type) {
-                    case ClassPath.COMPILE: case JavaClassPathConstants.MODULE_CLASS_PATH:
-                        return getConfiguration(client).compileClassPath;
-                    case JavaClassPathConstants.MODULE_COMPILE_PATH:
-                        return getConfiguration(client).moduleCompileClassPath;
-                }
-            }
-        }
-        return null;
-    }
-
-    @Override
-    public SourceLevelQueryImplementation2.Result getSourceLevel(FileObject file) {
-        if (isSingleSourceFile(file)) {
-            NbCodeLanguageClient client = Lookup.getDefault().lookup(NbCodeLanguageClient.class);
-            if (client != null) {
-                return getConfiguration(client).sourceLevelResult;
-            }
-        }
-        return null;
-    }
-
-    public boolean setConfiguration(NbCodeLanguageClient client, String vmOptions) {
-        return getConfiguration(client).setConfiguration(vmOptions);
-    }
-
-    private synchronized Configuration getConfiguration(NbCodeLanguageClient client) {
-        return file2Configuration.computeIfAbsent(client, cl -> {
-            return new Configuration();
-        });
-    }
-
-    //copied from SingleSourceFileUtil:
-    static boolean isSingleSourceFile(FileObject fObj) {
-        Project p = FileOwnerQuery.getOwner(fObj);
-        if (p != null || !fObj.getExt().equalsIgnoreCase("java")) { //NOI18N
-            return false;
-        }
-        return true;
-    }
-
-    private static final class OptionsResultImpl extends CompilerOptionsQueryImplementation.Result {
-
-        private final ChangeSupport cs = new ChangeSupport(this);
-        private List<String> args = Collections.emptyList();
-
-        public List<String> doParse(String line) {
-            return parseLine(line);
-        }
-
-        private void setArguments(List<String> newArguments) {
-            synchronized (this) {
-                args = newArguments;
-            }
-            cs.fireChange();
-        }
-
-        @Override
-        public synchronized List<? extends String> getArguments() {
-            return args;
-        }
-
-        @Override
-        public void addChangeListener(ChangeListener listener) {
-            cs.addChangeListener(listener);
-        }
-
-        @Override
-        public void removeChangeListener(ChangeListener listener) {
-            cs.addChangeListener(listener);
-        }
-
-    }
-
-    private static final class SourceLevelResultImpl implements SourceLevelQueryImplementation2.Result {
-
-        private static final String DEFAULT_SL = String.valueOf(SourceVersion.latest().ordinal() - SourceVersion.RELEASE_0.ordinal());
-        private final ChangeSupport cs = new ChangeSupport(this);
-        private String sourceLevel = DEFAULT_SL;
-
-        @Override
-        public synchronized String getSourceLevel() {
-            return sourceLevel;
-        }
-
-        private void setSourceLevel(String sourceLevel) {
-            synchronized (this) {
-                this.sourceLevel = sourceLevel;
-            }
-            cs.fireChange();
-        }
-
-        @Override
-        public void addChangeListener(ChangeListener listener) {
-            cs.addChangeListener(listener);
-        }
-
-        @Override
-        public void removeChangeListener(ChangeListener listener) {
-            cs.addChangeListener(listener);
-        }
-
-    }
-
-    private static final class Configuration {
-        private List<String> currentOptions = Collections.emptyList();
-        public final OptionsResultImpl compilerOptions;
-        public final SourceLevelResultImpl sourceLevelResult;
-        public final ProxyClassPathImplementation compileClassPathImplementation;
-        public final ProxyClassPathImplementation compileModulePathImplementation;
-        public final ClassPath compileClassPath;
-        public final ClassPath moduleCompileClassPath;
-
-        public Configuration() {
-            compilerOptions = new OptionsResultImpl();
-            sourceLevelResult = new SourceLevelResultImpl();
-            compileClassPathImplementation = new ProxyClassPathImplementation();
-            compileModulePathImplementation = new ProxyClassPathImplementation();
-            compileClassPath = ClassPathFactory.createClassPath(compileClassPathImplementation);
-            moduleCompileClassPath = ClassPathFactory.createClassPath(compileModulePathImplementation);
-        }
-
-        private boolean setConfiguration(String vmOptions) {
-            List<String> newOptions = compilerOptions.doParse(vmOptions);
-
-            synchronized (this) {
-                if (currentOptions.equals(newOptions)) {
-                    return false;
-                }
-
-                currentOptions = newOptions;
-            }
-
-            compilerOptions.setArguments(newOptions);
-
-            String classpath = "";
-            String modulepath = "";
-            String sourceLevel = SourceLevelResultImpl.DEFAULT_SL;
-
-            for (int i = 0; i < newOptions.size() - 1; i++) {
-                String parameter = newOptions.get(i + 1);
-
-                switch (newOptions.get(i)) {
-                    case "-classpath": case "-cp": case "--class-path":
-                        classpath = parameter;
-                        break;
-                    case "--module-path": case "-p":
-                        modulepath = parameter;
-                        break;
-                    case "--source":
-                        sourceLevel = parameter;
-                        break;
-                }
-            }
-
-            compileClassPathImplementation.setDelegates(spec2CP(classpath));
-            compileModulePathImplementation.setDelegates(spec2CP(modulepath));
-
-            sourceLevelResult.setSourceLevel(sourceLevel);
-
-            return true;
-        }
-
-        private List<ClassPathImplementation> spec2CP(String spec) {
-            List<PathResourceImplementation> entries;
-
-            if (spec.isEmpty()) {
-                entries = Collections.emptyList();
-            } else {
-                entries = ClassPathSupport.createClassPath(spec)
-                                          .entries()
-                                          .stream()
-                                          .map(e -> e.getURL())
-                                          .map(ClassPathSupport::createResource)
-                                          .collect(Collectors.toList());
-            }
-            return Arrays.asList(ClassPathSupport.createClassPathImplementation(entries));
-        }
-    }
-
-    private static final class ProxyClassPathImplementation implements ClassPathImplementation {
-        private final PropertyChangeSupport pcs = new PropertyChangeSupport(this);
-        private List<ClassPathImplementation> delegates = Collections.emptyList();
-        private List<? extends PathResourceImplementation> cachedResources = null;
-
-        public void setDelegates(List<ClassPathImplementation> delegates) {
-            synchronized (delegates) {
-                this.delegates = new ArrayList<>(delegates);
-                this.cachedResources = null;
-            }
-            pcs.firePropertyChange(PROP_RESOURCES, null, null);
-        }
-
-        @Override
-        public List<? extends PathResourceImplementation> getResources() {
-            List<ClassPathImplementation> delegates;
-
-            synchronized (this) {
-                if (cachedResources != null) {
-                    return cachedResources;
-                }
-
-                delegates = this.delegates;
-            }
-
-            List<PathResourceImplementation> allResources = new ArrayList<>();
-
-            delegates.stream().map(d -> d.getResources()).forEach(allResources::addAll);
-
-            allResources = Collections.unmodifiableList(allResources);
-
-            synchronized (this) {
-                if (cachedResources == null && this.delegates == delegates) {
-                    cachedResources = allResources;
-                }
-            }
-
-            return allResources;
-        }
-
-        @Override
-        public void addPropertyChangeListener(PropertyChangeListener listener) {
-            pcs.addPropertyChangeListener(listener);
-        }
-
-        @Override
-        public void removePropertyChangeListener(PropertyChangeListener listener) {
-            pcs.removePropertyChangeListener(listener);
-        }
-
-    }
-
-}
diff --git a/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/singlesourcefile/SingleFileOptionsQueryImpl.java b/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/singlesourcefile/SingleFileOptionsQueryImpl.java
new file mode 100644
index 000000000000..4ac93cf6160d
--- /dev/null
+++ b/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/singlesourcefile/SingleFileOptionsQueryImpl.java
@@ -0,0 +1,145 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.netbeans.modules.java.lsp.server.singlesourcefile;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.WeakHashMap;
+import javax.swing.event.ChangeListener;
+import org.netbeans.api.project.FileOwnerQuery;
+import org.netbeans.api.project.Project;
+import org.netbeans.modules.java.file.launcher.api.SourceLauncher;
+import org.netbeans.modules.java.file.launcher.spi.SingleFileOptionsQueryImplementation;
+import org.netbeans.modules.java.lsp.server.protocol.NbCodeLanguageClient;
+import org.openide.filesystems.FileObject;
+import org.openide.util.ChangeSupport;
+import org.openide.util.Lookup;
+import org.openide.util.lookup.ServiceProvider;
+
+@ServiceProvider(service=SingleFileOptionsQueryImplementation.class, position=100)
+public class SingleFileOptionsQueryImpl implements SingleFileOptionsQueryImplementation {
+
+    private final Map<NbCodeLanguageClient, ResultImpl> client2Options = new WeakHashMap<>();
+    private final GlobalResultImpl globalOptions = new GlobalResultImpl();
+
+    @Override
+    public Result optionsFor(FileObject file) {
+        if (isSingleSourceFile(file)) {
+            NbCodeLanguageClient client = Lookup.getDefault().lookup(NbCodeLanguageClient.class);
+
+            if (client != null) {
+                return getResult(client);
+            } else {
+                return globalOptions;
+            }
+        }
+        return null;
+    }
+
+    private static final class ResultImpl implements Result {
+
+        private final ChangeSupport cs = new ChangeSupport(this);
+        private String options = "";
+
+        @Override
+        public synchronized String getOptions() {
+            return options;
+        }
+
+        public boolean setOptions(String options) {
+            synchronized (this) {
+                if (Objects.equals(this.options, options)) {
+                    return false;
+                }
+                this.options = options;
+            }
+            cs.fireChange();
+            return true;
+        }
+
+        @Override
+        public void addChangeListener(ChangeListener l) {
+            cs.addChangeListener(l);
+        }
+
+        @Override
+        public void removeChangeListener(ChangeListener l) {
+            cs.removeChangeListener(l);
+        }
+
+    }
+
+    private final class GlobalResultImpl implements Result {
+
+        private final ChangeSupport cs = new ChangeSupport(this);
+
+        @Override
+        public String getOptions() {
+            List<String> options = new ArrayList<>();
+
+            synchronized (SingleFileOptionsQueryImpl.this) {
+                for (ResultImpl r : client2Options.values()) {
+                    options.add(r.getOptions());
+                }
+            }
+
+            return SourceLauncher.joinCommandLines(options);
+        }
+
+        @Override
+        public void addChangeListener(ChangeListener l) {
+            cs.addChangeListener(l);
+        }
+
+        @Override
+        public void removeChangeListener(ChangeListener l) {
+            cs.removeChangeListener(l);
+        }
+
+    }
+
+    public boolean setConfiguration(NbCodeLanguageClient client, String vmOptions) {
+        if (getResult(client).setOptions(vmOptions)) {
+            globalOptions.cs.fireChange();
+            return true;
+        }
+        return false;
+    }
+
+    private synchronized ResultImpl getResult(NbCodeLanguageClient client) {
+        return client2Options.computeIfAbsent(client, cl -> {
+            return new ResultImpl();
+        });
+    }
+
+    //copied from SingleSourceFileUtil:
+    static boolean isSingleSourceFile(FileObject fObj) {
+        Project p = FileOwnerQuery.getOwner(fObj);
+        if (p != null) {
+            return false;
+        }
+        if (!fObj.isFolder() && !fObj.getExt().equalsIgnoreCase("java")) { //NOI18N
+            return false;
+        }
+        return SourceLauncher.isSourceLauncherFile(fObj);
+    }
+
+}
diff --git a/java/java.lsp.server/test/unit/src/org/netbeans/modules/java/lsp/server/protocol/ServerTest.java b/java/java.lsp.server/test/unit/src/org/netbeans/modules/java/lsp/server/protocol/ServerTest.java
index eb830b02d1cf..a1e6d53ab386 100644
--- a/java/java.lsp.server/test/unit/src/org/netbeans/modules/java/lsp/server/protocol/ServerTest.java
+++ b/java/java.lsp.server/test/unit/src/org/netbeans/modules/java/lsp/server/protocol/ServerTest.java
@@ -162,6 +162,7 @@
 import org.netbeans.api.java.queries.AnnotationProcessingQuery.Result;
 import org.netbeans.api.java.queries.AnnotationProcessingQuery.Trigger;
 import org.netbeans.api.java.source.JavaSource;
+import org.netbeans.api.java.source.SourceUtilsTestUtil2;
 import org.netbeans.api.progress.ProgressHandle;
 import org.netbeans.api.project.FileOwnerQuery;
 import org.netbeans.api.project.Project;
@@ -262,6 +263,7 @@ public CompletableFuture<Object> processCommand(NbCodeLanguageClient client, Str
     protected void setUp() throws Exception {
         System.setProperty("java.awt.headless", Boolean.TRUE.toString());
         ParameterNameProviderImpl.DISABLE_PARAMETER_NAMES_LOADING = true;
+        SourceUtilsTestUtil2.disableMultiFileSourceRoots();
         super.setUp();
         clearWorkDir();
         ServerSocket srv = new ServerSocket(0, 1, InetAddress.getLoopbackAddress());
diff --git a/java/java.lsp.server/test/unit/src/org/netbeans/modules/java/lsp/server/singlesourcefile/CompilerOptionsQueryImplTest.java b/java/java.lsp.server/test/unit/src/org/netbeans/modules/java/lsp/server/singlesourcefile/CompilerOptionsQueryImplTest.java
deleted file mode 100644
index 548aac166a91..000000000000
--- a/java/java.lsp.server/test/unit/src/org/netbeans/modules/java/lsp/server/singlesourcefile/CompilerOptionsQueryImplTest.java
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.netbeans.modules.java.lsp.server.singlesourcefile;
-
-import java.io.File;
-import java.util.Arrays;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
-import static junit.framework.TestCase.assertEquals;
-import org.netbeans.api.java.classpath.ClassPath;
-import org.netbeans.api.java.classpath.JavaClassPathConstants;
-import org.netbeans.junit.NbTestCase;
-import org.netbeans.modules.java.lsp.server.TestCodeLanguageClient;
-import org.netbeans.modules.java.lsp.server.protocol.NbCodeLanguageClient;
-import org.netbeans.spi.java.queries.CompilerOptionsQueryImplementation;
-import org.netbeans.spi.java.queries.SourceLevelQueryImplementation2;
-import org.openide.filesystems.FileObject;
-import org.openide.filesystems.FileUtil;
-import org.openide.util.lookup.Lookups;
-
-public class CompilerOptionsQueryImplTest extends NbTestCase {
-
-    public CompilerOptionsQueryImplTest(String name) {
-        super(name);
-    }
-
-    public void testParseCommandLine1() throws Exception {
-        File wd = getWorkDir();
-        FileObject wdFO = FileUtil.toFileObject(wd);
-        FileObject testFO = FileUtil.createData(wdFO, "Test.java");
-        File testJar = new File(wd, "test.jar");
-        CompilerOptionsQueryImpl query = new CompilerOptionsQueryImpl();
-        NbCodeLanguageClient client = new TestCodeLanguageClient() {
-        };
-
-        query.setConfiguration(client, "-classpath " + testJar.getAbsolutePath() + " --module-path " + testJar.getAbsolutePath() + " --source 21 --enable-preview");
-
-        AtomicReference<CompilerOptionsQueryImplementation.Result> optionsResult = new AtomicReference<>();
-        AtomicInteger optionsResultModificationCount = new AtomicInteger();
-        AtomicReference<ClassPath> compileCP = new AtomicReference<>();
-        AtomicInteger compileCPModificationCount = new AtomicInteger();
-        AtomicReference<ClassPath> compileModuleCP = new AtomicReference<>();
-        AtomicInteger compileModuleCPModificationCount = new AtomicInteger();
-        AtomicReference<SourceLevelQueryImplementation2.Result> sourceLevelResult = new AtomicReference<>();
-        AtomicInteger sourceLevelResultModificationCount = new AtomicInteger();
-
-        Lookups.executeWith(Lookups.fixed(client), () -> {
-            optionsResult.set(query.getOptions(testFO));
-            compileCP.set(query.findClassPath(testFO, ClassPath.COMPILE));
-            compileModuleCP.set(query.findClassPath(testFO, JavaClassPathConstants.MODULE_COMPILE_PATH));
-            sourceLevelResult.set(query.getSourceLevel(testFO));
-        });
-
-        optionsResult.get().addChangeListener(evt -> optionsResultModificationCount.incrementAndGet());
-        assertEquals(Arrays.asList("-classpath", testJar.getAbsolutePath(), "--module-path", testJar.getAbsolutePath(), "--source", "21", "--enable-preview"),
-                     optionsResult.get().getArguments());
-        assertEquals(0, optionsResultModificationCount.get());
-
-        compileCP.get().addPropertyChangeListener(evt -> compileCPModificationCount.incrementAndGet());
-        assertEquals(testJar.getAbsolutePath(),
-                     compileCP.get().toString(ClassPath.PathConversionMode.PRINT));
-        assertEquals(0, compileCPModificationCount.get());
-
-        compileModuleCP.get().addPropertyChangeListener(evt -> compileModuleCPModificationCount.incrementAndGet());
-        assertEquals(testJar.getAbsolutePath(),
-                     compileModuleCP.get().toString(ClassPath.PathConversionMode.PRINT));
-        assertEquals(0, compileModuleCPModificationCount.get());
-
-        sourceLevelResult.get().addChangeListener(evt -> sourceLevelResultModificationCount.incrementAndGet());
-        assertEquals("21",
-                     sourceLevelResult.get().getSourceLevel());
-        assertEquals(0, sourceLevelResultModificationCount.get());
-
-        query.setConfiguration(client, "-cp " + testJar.getAbsolutePath() + " -p " + testJar.getAbsolutePath() + " --source 17");
-
-        assertEquals(Arrays.asList("-cp", testJar.getAbsolutePath(), "-p", testJar.getAbsolutePath(), "--source", "17"),
-                     optionsResult.get().getArguments());
-        assertEquals(1, optionsResultModificationCount.get());
-
-        assertEquals(testJar.getAbsolutePath(),
-                     compileCP.get().toString(ClassPath.PathConversionMode.PRINT));
-        assertEquals(2, compileCPModificationCount.get());
-
-        assertEquals(testJar.getAbsolutePath(),
-                     compileModuleCP.get().toString(ClassPath.PathConversionMode.PRINT));
-        assertEquals(2, compileModuleCPModificationCount.get());
-
-        assertEquals("17",
-                     sourceLevelResult.get().getSourceLevel());
-        assertEquals(1, sourceLevelResultModificationCount.get());
-    }
-
-}
diff --git a/java/java.project/src/org/netbeans/modules/java/project/ProjectAccessibilityQuery2.java b/java/java.project/src/org/netbeans/modules/java/project/ProjectAccessibilityQuery2.java
index e7db0d1f4bdd..9a15e984603b 100644
--- a/java/java.project/src/org/netbeans/modules/java/project/ProjectAccessibilityQuery2.java
+++ b/java/java.project/src/org/netbeans/modules/java/project/ProjectAccessibilityQuery2.java
@@ -31,7 +31,7 @@
  * owns the affected source folder.
  * @author Tomas Zezula
  */
-@ServiceProvider(service = AccessibilityQueryImplementation2.class)
+@ServiceProvider(service = AccessibilityQueryImplementation2.class, position=100)
 public final class ProjectAccessibilityQuery2 implements AccessibilityQueryImplementation2 {
 
     public ProjectAccessibilityQuery2() {}
diff --git a/java/java.source.base/nbproject/project.xml b/java/java.source.base/nbproject/project.xml
index ca5a5c314b9e..7cc5ba6e5f51 100644
--- a/java/java.source.base/nbproject/project.xml
+++ b/java/java.source.base/nbproject/project.xml
@@ -339,6 +339,10 @@
                         <recursive/>
                         <compile-dependency/>
                     </test-dependency>
+                    <test-dependency>
+                        <code-name-base>org.netbeans.modules.java.file.launcher</code-name-base>
+                        <compile-dependency/>
+                    </test-dependency>
                     <test-dependency>
                         <code-name-base>org.netbeans.modules.java.guards</code-name-base>
                         <compile-dependency/>
diff --git a/java/java.source.base/src/org/netbeans/modules/java/source/indexing/APTUtils.java b/java/java.source.base/src/org/netbeans/modules/java/source/indexing/APTUtils.java
index 8103b9019a4f..5f47ca7cd445 100644
--- a/java/java.source.base/src/org/netbeans/modules/java/source/indexing/APTUtils.java
+++ b/java/java.source.base/src/org/netbeans/modules/java/source/indexing/APTUtils.java
@@ -135,6 +135,7 @@ private APTUtils(@NonNull final FileObject root) {
         this.root = root;
         bootPath = ClassPath.getClassPath(root, ClassPath.BOOT);
         compilePath = ClassPath.getClassPath(root, ClassPath.COMPILE);
+        compilePath.addPropertyChangeListener(this);
         processorPath = new AtomicReference<>(ClassPath.getClassPath(root, JavaClassPathConstants.PROCESSOR_PATH));
         processorModulePath = new AtomicReference<>(ClassPath.getClassPath(root, JavaClassPathConstants.MODULE_PROCESSOR_PATH));
         aptOptions = AnnotationProcessingQuery.getAnnotationProcessingOptions(root);
@@ -309,12 +310,16 @@ public void stateChanged(ChangeEvent e) {
     @Override
     public void propertyChange(PropertyChangeEvent evt) {
         if (ClassPath.PROP_ROOTS.equals(evt.getPropertyName())) {
-            classLoaderCache = null;
-            ROOT_CHANGE_RP.execute(()-> {
-                if (verifyProcessorPath(root, usedRoots, PROCESSOR_MODULE_PATH) || verifyProcessorPath(root, usedRoots, PROCESSOR_PATH)) {
-                    slidingRefresh.schedule(SLIDING_WINDOW);
-                }
-            });
+            if (evt.getSource() == compilePath) {
+                stateChanged(null);
+            } else {
+                classLoaderCache = null;
+                ROOT_CHANGE_RP.execute(()-> {
+                    if (verifyProcessorPath(root, usedRoots, PROCESSOR_MODULE_PATH) || verifyProcessorPath(root, usedRoots, PROCESSOR_PATH)) {
+                        slidingRefresh.schedule(SLIDING_WINDOW);
+                    }
+                });
+            }
         }
     }
 
@@ -351,7 +356,11 @@ private ClassPath[] validatePaths() {
             pp = ClassPath.getClassPath(root, JavaClassPathConstants.PROCESSOR_PATH);
             if (pp != null && processorPath.compareAndSet(null, pp)) {
                 bootPath = ClassPath.getClassPath(root, ClassPath.BOOT);
+                if (compilePath != null) {
+                    compilePath.removePropertyChangeListener(this);
+                }
                 compilePath = ClassPath.getClassPath(root, ClassPath.COMPILE);
+                compilePath.addPropertyChangeListener(this);
                 listenOnProcessorPath(pp, this);
                 classLoaderCache = null;
             }
diff --git a/java/java.source.base/src/org/netbeans/modules/java/source/indexing/VanillaCompileWorker.java b/java/java.source.base/src/org/netbeans/modules/java/source/indexing/VanillaCompileWorker.java
index 1503fe37fb73..2880620eaa98 100644
--- a/java/java.source.base/src/org/netbeans/modules/java/source/indexing/VanillaCompileWorker.java
+++ b/java/java.source.base/src/org/netbeans/modules/java/source/indexing/VanillaCompileWorker.java
@@ -43,12 +43,15 @@
 import com.sun.tools.javac.api.BasicJavacTask;
 import com.sun.tools.javac.api.JavacTaskImpl;
 import com.sun.tools.javac.code.Attribute;
+import com.sun.tools.javac.code.DeferredCompletionFailureHandler;
+import com.sun.tools.javac.code.DeferredCompletionFailureHandler.Handler;
 import com.sun.tools.javac.code.Flags;
 import com.sun.tools.javac.code.Kinds.Kind;
 import com.sun.tools.javac.code.Source;
 import com.sun.tools.javac.code.Source.Feature;
 import com.sun.tools.javac.code.Symbol;
 import com.sun.tools.javac.code.Symbol.ClassSymbol;
+import com.sun.tools.javac.code.Symbol.CompletionFailure;
 import com.sun.tools.javac.code.Symbol.MethodSymbol;
 import com.sun.tools.javac.code.Symbol.RecordComponent;
 import com.sun.tools.javac.code.Symbol.TypeSymbol;
@@ -550,6 +553,7 @@ private void dropMethodsAndErrors(com.sun.tools.javac.util.Context ctx, Compilat
         Elements el = JavacElements.instance(ctx);
         Source source = Source.instance(ctx);
         boolean hasMatchException = el.getTypeElement("java.lang.MatchException") != null;
+        DeferredCompletionFailureHandler dcfh = DeferredCompletionFailureHandler.instance(ctx);
         //TODO: should preserve error types!!!
         new TreePathScanner<Void, Void>() {
             private Set<JCNewClass> anonymousClasses = Collections.newSetFromMap(new LinkedHashMap<>());
@@ -675,8 +679,14 @@ public Void visitBlock(BlockTree node, Void p) {
             }
 
             private JCStatement throwTree(SortedMap<Long, List<Diagnostic<? extends JavaFileObject>>> diags) {
-                String message = diags.isEmpty() ? "Uncompilable code"
-                                                 : "Uncompilable code - " + DIAGNOSTIC_TO_TEXT.apply(diags.values().iterator().next().get(0));
+                String message = diags.isEmpty() ? null
+                                                 : DIAGNOSTIC_TO_TEXT.apply(diags.values().iterator().next().get(0));
+                return throwTree(message);
+            }
+
+            private JCStatement throwTree(String message) {
+                message = message == null ? "Uncompilable code"
+                                          : "Uncompilable code - " + message;
                 JCNewClass nct =
                         make.NewClass(null,
                                       com.sun.tools.javac.util.List.nil(),
@@ -754,6 +764,7 @@ public Void visitClass(ClassTree node, Void p) {
                         clazz.defs = com.sun.tools.javac.util.List.filter(clazz.defs, def);
                     }
                 }
+                fixRecordMethods(clazz);
                 super.visitClass(node, p);
                 //remove anonymous classes that remained in the tree from anonymousClasses:
                 new TreeScanner<Void, Void>() {
@@ -787,6 +798,32 @@ public Void visitClass(ClassTree nestedNode, Void p) {
                 return null;
             }
 
+            private final Set<String> RECORD_METHODS = new HashSet<>(Arrays.asList("toString", "hashCode", "equals"));
+
+            private void fixRecordMethods(JCClassDecl clazz) {
+                if ((clazz.sym.flags() & Flags.RECORD) == 0) {
+                    return ;
+                }
+                Handler prevHandler = dcfh.setHandler(dcfh.speculativeCodeHandler);
+                try {
+                    try {
+                        syms.objectMethodsType.tsym.flags();
+                    } catch (CompletionFailure cf) {
+                        //ignore
+                    }
+                    if (!syms.objectMethodsType.tsym.type.isErroneous()) {
+                        //ObjectMethods exist:
+                        return ;
+                    }
+                } finally {
+                    dcfh.setHandler(prevHandler);
+                }
+                for (Symbol s : clazz.sym.members().getSymbols(s -> (s.flags() & Flags.RECORD) != 0 && s.kind == Kind.MTH && RECORD_METHODS.contains(s.name.toString()))) {
+                    clazz.defs = clazz.defs.prepend(make.MethodDef((MethodSymbol) s, make.Block(0, com.sun.tools.javac.util.List.of(throwTree("java.lang.runtime.ObjectMethods does not exist!")))));
+                    s.flags_field &= ~Flags.RECORD;
+                }
+            }
+
             private JCStatement clearAndWrapAnonymous(JCNewClass nc) {
                 new TreeScanner<Void, Void>() {
                     @Override
diff --git a/java/java.source.base/test/unit/src/org/netbeans/api/java/source/ClassIndexTest.java b/java/java.source.base/test/unit/src/org/netbeans/api/java/source/ClassIndexTest.java
index aacf8e84d810..674da8164972 100644
--- a/java/java.source.base/test/unit/src/org/netbeans/api/java/source/ClassIndexTest.java
+++ b/java/java.source.base/test/unit/src/org/netbeans/api/java/source/ClassIndexTest.java
@@ -41,6 +41,7 @@
 import org.netbeans.junit.NbTestCase;
 import org.netbeans.junit.NbTestSuite;
 import org.netbeans.junit.RandomlyFails;
+import org.netbeans.modules.java.file.launcher.queries.MultiSourceRootProvider;
 import org.netbeans.modules.java.source.parsing.FileObjects;
 import org.netbeans.modules.java.source.usages.ClassIndexManager;
 import org.netbeans.modules.java.source.usages.ClassIndexManagerEvent;
@@ -668,6 +669,10 @@ private static void deleteFile (final String path) throws IOException {
     }
        
 
+    static {
+        MultiSourceRootProvider.DISABLE_MULTI_SOURCE_ROOT = true;
+    }
+
     public static class ClassPathProviderImpl implements ClassPathProvider {
 
         public ClassPath findClassPath(final FileObject file, final String type) {
diff --git a/java/java.source.base/test/unit/src/org/netbeans/api/java/source/ScanUtilsTest.java b/java/java.source.base/test/unit/src/org/netbeans/api/java/source/ScanUtilsTest.java
index 85c899b71aee..e973412d4ec9 100644
--- a/java/java.source.base/test/unit/src/org/netbeans/api/java/source/ScanUtilsTest.java
+++ b/java/java.source.base/test/unit/src/org/netbeans/api/java/source/ScanUtilsTest.java
@@ -38,6 +38,7 @@
 import javax.lang.model.element.TypeElement;
 import org.netbeans.api.java.classpath.ClassPath;
 import org.netbeans.junit.NbTestCase;
+import org.netbeans.modules.java.file.launcher.queries.MultiSourceRootProvider;
 import org.netbeans.modules.java.source.BootClassPathUtil;
 import org.netbeans.modules.java.source.parsing.JavacParserResult;
 import org.netbeans.modules.parsing.api.ResultIterator;
@@ -683,4 +684,8 @@ public void run(CompilationController parameter) throws Exception {
             assertNull(error.get(), error.get());
         }
     }
+
+    static {
+        MultiSourceRootProvider.DISABLE_MULTI_SOURCE_ROOT = true;
+    }
 }
diff --git a/java/java.source.base/test/unit/src/org/netbeans/api/java/source/SourceUtilsTestUtil.java b/java/java.source.base/test/unit/src/org/netbeans/api/java/source/SourceUtilsTestUtil.java
index 792242d01501..2b51136ad086 100644
--- a/java/java.source.base/test/unit/src/org/netbeans/api/java/source/SourceUtilsTestUtil.java
+++ b/java/java.source.base/test/unit/src/org/netbeans/api/java/source/SourceUtilsTestUtil.java
@@ -27,7 +27,6 @@
 import java.util.*;
 import java.util.logging.Level;
 import java.util.logging.Logger;
-import java.util.regex.Pattern;
 import java.util.stream.Collectors;
 import javax.swing.event.ChangeListener;
 import javax.swing.text.Document;
@@ -59,7 +58,6 @@
 import org.netbeans.spi.java.queries.SourceForBinaryQueryImplementation;
 import org.netbeans.spi.java.queries.SourceLevelQueryImplementation;
 import org.openide.filesystems.FileObject;
-import org.openide.filesystems.FileStateInvalidException;
 import org.openide.filesystems.FileSystem;
 import org.openide.filesystems.FileUtil;
 import org.openide.filesystems.LocalFileSystem;
@@ -182,6 +180,7 @@ public FileObject getFileObject(Document document) {
         SourceUtilsTestUtil.class.getClassLoader().setDefaultAssertionStatus(true);
         System.setProperty("org.openide.util.Lookup", SourceUtilsTestUtil.class.getName());
         Assert.assertEquals(SourceUtilsTestUtil.class, Lookup.getDefault().getClass());
+        SourceUtilsTestUtil2.disableMultiFileSourceRoots();
     }
     
     public static void prepareTest(FileObject sourceRoot, FileObject buildRoot, FileObject cache) throws Exception {
diff --git a/java/java.source.base/test/unit/src/org/netbeans/api/java/source/SourceUtilsTestUtil2.java b/java/java.source.base/test/unit/src/org/netbeans/api/java/source/SourceUtilsTestUtil2.java
index 347040b7c204..72137aacb41a 100644
--- a/java/java.source.base/test/unit/src/org/netbeans/api/java/source/SourceUtilsTestUtil2.java
+++ b/java/java.source.base/test/unit/src/org/netbeans/api/java/source/SourceUtilsTestUtil2.java
@@ -79,4 +79,13 @@ public static void disableConfinementTest() {
             //ignore
         }
     }
+
+    public static void disableMultiFileSourceRoots() {
+        try {
+            Class multiSourceRootProvider = Class.forName("org.netbeans.modules.java.file.launcher.queries.MultiSourceRootProvider");
+            multiSourceRootProvider.getField("DISABLE_MULTI_SOURCE_ROOT").set(null, true);
+        } catch (Exception ex) {
+            //ignore
+        }
+    }
 }
diff --git a/java/java.source.base/test/unit/src/org/netbeans/modules/java/source/JavaSourceUtilImplTest.java b/java/java.source.base/test/unit/src/org/netbeans/modules/java/source/JavaSourceUtilImplTest.java
index 675d610fae17..b644653b09cc 100644
--- a/java/java.source.base/test/unit/src/org/netbeans/modules/java/source/JavaSourceUtilImplTest.java
+++ b/java/java.source.base/test/unit/src/org/netbeans/modules/java/source/JavaSourceUtilImplTest.java
@@ -39,6 +39,7 @@
 import org.netbeans.api.java.classpath.ClassPath;
 import org.netbeans.api.java.classpath.JavaClassPathConstants;
 import org.netbeans.api.java.queries.AnnotationProcessingQuery;
+import org.netbeans.api.java.source.SourceUtilsTestUtil2;
 import org.netbeans.api.java.source.TestUtilities;
 import org.netbeans.junit.NbTestCase;
 import org.netbeans.modules.classfile.ClassFile;
@@ -74,6 +75,7 @@ public JavaSourceUtilImplTest(String name) {
     @Override
     public void setUp() throws Exception {
         clearWorkDir();
+        SourceUtilsTestUtil2.disableMultiFileSourceRoots();
         wd = FileUtil.toFileObject(FileUtil.normalizeFile(getWorkDir()));
         root = FileUtil.createFolder(wd, "src");    //NOI18N
         java = createFile(root, "org/nb/A.java","package nb;\n class A {}");    //NOI18N
diff --git a/java/java.source.base/test/unit/src/org/netbeans/modules/java/source/indexing/VanillaCompileWorkerTest.java b/java/java.source.base/test/unit/src/org/netbeans/modules/java/source/indexing/VanillaCompileWorkerTest.java
index fd8d5bdc478a..bcd1c07c8701 100644
--- a/java/java.source.base/test/unit/src/org/netbeans/modules/java/source/indexing/VanillaCompileWorkerTest.java
+++ b/java/java.source.base/test/unit/src/org/netbeans/modules/java/source/indexing/VanillaCompileWorkerTest.java
@@ -2342,6 +2342,95 @@ public void testWrongRecordComponent() throws Exception {
         assertEquals(expected, file2Fixed);
     }
 
+    public void testRecord1() throws Exception {
+        setSourceLevel("11");
+        Map<String, String> file2Fixed = new HashMap<>();
+        VanillaCompileWorker.fixedListener = (file, cut) -> {
+            try {
+                FileObject source = URLMapper.findFileObject(file.toUri().toURL());
+                file2Fixed.put(FileUtil.getRelativePath(getRoot(), source), cut.toString());
+            } catch (MalformedURLException ex) {
+                throw new IllegalStateException(ex);
+            }
+        };
+        ParsingOutput result = runIndexing(Arrays.asList(compileTuple("test/Test.java", "package test;\n"
+                        + "record Test(int i) {}\n")), Arrays.asList());
+
+        assertFalse(result.lowMemory);
+        assertTrue(result.success);
+
+        Set<String> createdFiles = new HashSet<String>();
+
+        for (File created : result.createdFiles) {
+            createdFiles.add(getWorkDir().toURI().relativize(created.toURI()).getPath());
+        }
+
+        assertEquals(new HashSet<String>(Arrays.asList("cache/s1/java/15/classes/test/Test.sig")), createdFiles);
+        Map<String, String> expected = Collections.singletonMap("test/Test.java",
+                "package test;\n" +
+                "\n" +
+                "class Test {\n" +
+                "    static {\n" +
+                "        throw new java.lang.RuntimeException(\"Uncompilable code - compiler.err.feature.not.supported.in.source.plural\");\n" +
+                "    }\n" +
+                "    \n" +
+                "    public final java.lang.String toString() {\n" +
+                "        throw new java.lang.RuntimeException(\"Uncompilable code - java.lang.runtime.ObjectMethods does not exist!\");\n" +
+                "    }\n" +
+                "    \n" +
+                "    public final int hashCode() {\n" +
+                "        throw new java.lang.RuntimeException(\"Uncompilable code - java.lang.runtime.ObjectMethods does not exist!\");\n" +
+                "    }\n" +
+                "    \n" +
+                "    public final boolean equals(java.lang.Object o) {\n" +
+                "        throw new java.lang.RuntimeException(\"Uncompilable code - java.lang.runtime.ObjectMethods does not exist!\");\n" +
+                "    }\n" +
+                "    \n" +
+                "    Test(int i) {\n" +
+                "        throw new java.lang.RuntimeException(\"Uncompilable code\");\n" +
+                "    }\n" +
+                "    private final int i;\n" +
+                "}");
+        assertEquals(expected, file2Fixed);
+    }
+
+    public void testRecord2() throws Exception {
+        setSourceLevel("17");
+        Map<String, String> file2Fixed = new HashMap<>();
+        VanillaCompileWorker.fixedListener = (file, cut) -> {
+            try {
+                FileObject source = URLMapper.findFileObject(file.toUri().toURL());
+                file2Fixed.put(FileUtil.getRelativePath(getRoot(), source), cut.toString());
+            } catch (MalformedURLException ex) {
+                throw new IllegalStateException(ex);
+            }
+        };
+        ParsingOutput result = runIndexing(Arrays.asList(compileTuple("test/Test.java", "package test;\n"
+                        + "record Test(int i) {}\n")), Arrays.asList());
+
+        assertFalse(result.lowMemory);
+        assertTrue(result.success);
+
+        Set<String> createdFiles = new HashSet<String>();
+
+        for (File created : result.createdFiles) {
+            createdFiles.add(getWorkDir().toURI().relativize(created.toURI()).getPath());
+        }
+
+        assertEquals(new HashSet<String>(Arrays.asList("cache/s1/java/15/classes/test/Test.sig")), createdFiles);
+        Map<String, String> expected = Collections.singletonMap("test/Test.java",
+                "package test;\n" +
+                "\n" +
+                "class Test {\n" +
+                "    \n" +
+                "    Test(int i) {\n" +
+                "        super();\n" +
+                "    }\n" +
+                "    private final int i;\n" +
+                "}");
+        assertEquals(expected, file2Fixed);
+    }
+
     public static void noop() {}
 
     @Override
diff --git a/java/refactoring.java/nbproject/project.xml b/java/refactoring.java/nbproject/project.xml
index 7dc084a2afb1..47b8676e08bb 100644
--- a/java/refactoring.java/nbproject/project.xml
+++ b/java/refactoring.java/nbproject/project.xml
@@ -148,6 +148,14 @@
                         <specification-version>1.15</specification-version>
                     </run-dependency>
                 </dependency>
+                <dependency>
+                    <code-name-base>org.netbeans.modules.java.file.launcher</code-name-base>
+                    <build-prerequisite/>
+                    <compile-dependency/>
+                    <run-dependency>
+                        <specification-version>1.0</specification-version>
+                    </run-dependency>
+                </dependency>
                 <dependency>
                     <code-name-base>org.netbeans.modules.java.lexer</code-name-base>
                     <build-prerequisite/>
diff --git a/java/refactoring.java/src/org/netbeans/modules/refactoring/java/RefactoringUtils.java b/java/refactoring.java/src/org/netbeans/modules/refactoring/java/RefactoringUtils.java
index 6d918528263f..21fa62e07d25 100644
--- a/java/refactoring.java/src/org/netbeans/modules/refactoring/java/RefactoringUtils.java
+++ b/java/refactoring.java/src/org/netbeans/modules/refactoring/java/RefactoringUtils.java
@@ -55,6 +55,7 @@
 import org.netbeans.api.project.ProjectUtils;
 import org.netbeans.api.project.SourceGroup;
 import org.netbeans.api.project.ui.OpenProjects;
+import org.netbeans.modules.java.file.launcher.api.SourceLauncher;
 import org.netbeans.modules.refactoring.java.plugins.LocalVarScanner;
 import org.netbeans.spi.java.classpath.support.ClassPathSupport;
 import org.openide.cookies.EditorCookie;
@@ -288,7 +289,7 @@ public static boolean isFileInOpenProject(FileObject file) {
         }
         Project p = FileOwnerQuery.getOwner(file);
         if (p == null) {
-            return false;
+            return SourceLauncher.isSourceLauncherFile(file);
         }
         return isOpenProject(p);
     }
diff --git a/java/spi.java.hints/test/unit/src/org/netbeans/modules/java/hints/spiimpl/batch/BatchSearchTest.java b/java/spi.java.hints/test/unit/src/org/netbeans/modules/java/hints/spiimpl/batch/BatchSearchTest.java
index 511b4e31145a..2fe06806580e 100644
--- a/java/spi.java.hints/test/unit/src/org/netbeans/modules/java/hints/spiimpl/batch/BatchSearchTest.java
+++ b/java/spi.java.hints/test/unit/src/org/netbeans/modules/java/hints/spiimpl/batch/BatchSearchTest.java
@@ -51,6 +51,7 @@
 import org.netbeans.junit.NbTestSuite;
 import org.netbeans.junit.RandomlyFails;
 import org.netbeans.lib.nbjavac.services.NBAttr;
+import org.netbeans.modules.java.file.launcher.queries.MultiSourceRootProvider;
 import org.netbeans.modules.java.hints.spiimpl.batch.BatchSearch.BatchResult;
 import org.netbeans.modules.java.hints.spiimpl.batch.BatchSearch.Folder;
 import org.netbeans.modules.java.hints.spiimpl.batch.BatchSearch.Resource;
@@ -95,6 +96,7 @@ public static TestSuite suite() {
     protected void setUp() throws Exception {
         SourceUtilsTestUtil.prepareTest(new String[0], new Object[0]);
         Main.initializeURLFactory();
+        MultiSourceRootProvider.DISABLE_MULTI_SOURCE_ROOT = true;
         org.netbeans.api.project.ui.OpenProjects.getDefault().getOpenProjects();
         prepareTest();
         MimeTypes.setAllMimeTypes(Collections.singleton("text/x-java"));
diff --git a/nbbuild/cluster.properties b/nbbuild/cluster.properties
index 137e9aea70a0..45110038ad08 100644
--- a/nbbuild/cluster.properties
+++ b/nbbuild/cluster.properties
@@ -604,6 +604,7 @@ nb.cluster.java=\
         java.editor.base,\
         java.editor.lib,\
         java.examples,\
+        java.file.launcher,\
         java.freeform,\
         java.graph,\
         java.guards,\
