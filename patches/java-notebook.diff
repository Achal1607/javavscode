diff --git a/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/JavaEvaluator.java b/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/JavaEvaluator.java
new file mode 100644
index 0000000000..f34d9c676e
--- /dev/null
+++ b/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/JavaEvaluator.java
@@ -0,0 +1,142 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.netbeans.modules.java.lsp.server.protocol;
+
+import jdk.jshell.JShell;
+import jdk.jshell.SnippetEvent;
+import com.google.gson.JsonPrimitive;
+import java.io.ByteArrayOutputStream;
+import java.io.PrintStream;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Set;
+import java.util.HashSet;
+import java.util.List;
+import java.util.concurrent.CompletableFuture;
+import org.netbeans.spi.lsp.CommandProvider;
+import org.openide.util.lookup.ServiceProvider;
+
+@ServiceProvider(service = CommandProvider.class)
+public class JavaEvaluator implements CommandProvider {
+
+    private JShell jshell = null;
+    private ByteArrayOutputStream outputStream;
+    private ByteArrayOutputStream errorStream;
+    private static final String NBLS_JSHELL_EXEC = "nbls.jshell.execute.cell";
+    private static final Set<String> COMMANDS = new HashSet<>(Arrays.asList(NBLS_JSHELL_EXEC));
+
+    public JavaEvaluator() {
+        try {
+            this.outputStream = new ByteArrayOutputStream();
+            this.errorStream = new ByteArrayOutputStream();
+            PrintStream outPrintStream = new PrintStream(this.outputStream, true);
+            PrintStream errPrintStream = new PrintStream(this.errorStream, true);
+
+            String javaVersion = System.getProperty("java.version");
+
+            String majorVersion = javaVersion.split("\\.")[0];
+
+            String[] options = {"--enable-preview", "--source", majorVersion};
+
+            this.jshell = JShell.builder()
+                    .out(outPrintStream)
+                    .err(errPrintStream)
+                    .compilerOptions(options)
+                    .build();
+            // Import common packages
+            List.of("java.io", "java.math", "java.net", "java.nio", "java.nio.file",
+                    "java.text", "java.time", "java.util", "java.util.function",
+                    "java.util.concurrent", "java.util.stream")
+                    .forEach(pkg -> this.jshell.eval("import " + pkg + ".*;\n"));
+
+            // Static imports
+            List.of("java.lang.Math", "java.lang.System", "java.util.stream.Collectors")
+                    .forEach(cls -> this.jshell.eval("import static " + cls + ".*;\n"));
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    @Override
+    public Set<String> getCommands() {
+        return COMMANDS;
+    }
+
+    @Override
+    public CompletableFuture<Object> runCommand(String command, List<Object> arguments) {
+        switch (command) {
+            case NBLS_JSHELL_EXEC: {
+                String sourceCode = ((JsonPrimitive) arguments.get(0)).getAsString();
+                return evaluate(sourceCode).thenApply(results -> results);
+            }
+            default:
+                throw new UnsupportedOperationException("Command not supported: " + command);
+        }
+    }
+
+    public CompletableFuture<List<String>> evaluate(String snippet) {
+        List<String> results = new ArrayList<>();
+        try {
+            List<SnippetEvent> snippetEvents = jshell.eval(snippet + ";");
+
+            for (SnippetEvent event : snippetEvents) {
+                flushStreams(results);
+
+                if (event.exception() != null) {
+                    results.add(event.exception().getMessage());
+                } else if (event.value() != null) {
+                    results.add(event.value());
+                }
+
+                jshell.diagnostics(event.snippet())
+                        .forEach(diag -> results.add(diag.getMessage(null)));
+
+                flushStreams(results);
+            }
+
+            flushStreams(results);
+
+        } catch (Exception e) {
+            results.add("Evaluation error: " + e.getMessage());
+        }
+
+        return CompletableFuture.completedFuture(results);
+    }
+
+    private void flushStreams(List<String> results) {
+        String output = this.outputStream.toString().trim();
+        if (!output.isEmpty()) {
+            results.add(output);
+            this.outputStream.reset();
+        }
+
+        String error = errorStream.toString().trim();
+        if (!error.isEmpty()) {
+            results.add(error);
+            this.errorStream.reset();
+        }
+    }
+
+    public void closeJShell() {
+        if (jshell != null) {
+            jshell.close();
+            jshell = null;
+        }
+    }
+}
