diff --git a/java/java.completion/src/org/netbeans/modules/java/completion/BaseTask.java b/java/java.completion/src/org/netbeans/modules/java/completion/BaseTask.java
index 78fdd4caa30d..95ae5235c67a 100644
--- a/java/java.completion/src/org/netbeans/modules/java/completion/BaseTask.java
+++ b/java/java.completion/src/org/netbeans/modules/java/completion/BaseTask.java
@@ -176,6 +176,7 @@ TokenSequence<JavaTokenId> nextNonWhitespaceToken(TokenSequence<JavaTokenId> ts)
                 case LINE_COMMENT:
                 case BLOCK_COMMENT:
                 case JAVADOC_COMMENT:
+                case JAVADOC_COMMENT_LINE_RUN:
                     break;
                 default:
                     return ts;
@@ -206,6 +207,7 @@ TokenSequence<JavaTokenId> previousNonWhitespaceToken(TokenSequence<JavaTokenId>
                 case LINE_COMMENT:
                 case BLOCK_COMMENT:
                 case JAVADOC_COMMENT:
+                case JAVADOC_COMMENT_LINE_RUN:
                     break;
                 default:
                     return ts;
@@ -427,6 +429,7 @@ private Env getEnvImpl(CompilationController controller, TreePath orig, TreePath
                                     case LINE_COMMENT:
                                     case BLOCK_COMMENT:
                                     case JAVADOC_COMMENT:
+                                    case JAVADOC_COMMENT_LINE_RUN:
                                         break;
                                     case ARROW:
                                         scope = controller.getTrees().getScope(blockPath);
@@ -456,6 +459,7 @@ private Env getEnvImpl(CompilationController controller, TreePath orig, TreePath
                             case LINE_COMMENT:
                             case BLOCK_COMMENT:
                             case JAVADOC_COMMENT:
+                            case JAVADOC_COMMENT_LINE_RUN:
                                 break;
                             case ARROW:
                                 return new Env(offset, prefix, controller, path, sourcePositions, scope);
diff --git a/java/java.completion/src/org/netbeans/modules/java/completion/JavaCompletionTask.java b/java/java.completion/src/org/netbeans/modules/java/completion/JavaCompletionTask.java
index 9ec7273f86f6..be001bce2358 100644
--- a/java/java.completion/src/org/netbeans/modules/java/completion/JavaCompletionTask.java
+++ b/java/java.completion/src/org/netbeans/modules/java/completion/JavaCompletionTask.java
@@ -1608,6 +1608,7 @@ private void insideMemberSelect(Env env) throws IOException {
                 case LINE_COMMENT:
                 case BLOCK_COMMENT:
                 case JAVADOC_COMMENT:
+                case JAVADOC_COMMENT_LINE_RUN:
                     break;
                 default:
                     lastNonWhitespaceTokenId = ts.token().id();
diff --git a/java/java.editor.base/nbproject/project.properties b/java/java.editor.base/nbproject/project.properties
index 1f620a92a638..808db111121e 100644
--- a/java/java.editor.base/nbproject/project.properties
+++ b/java/java.editor.base/nbproject/project.properties
@@ -16,7 +16,7 @@
 # under the License.
 spec.version.base=2.90.0
 is.autoload=true
-javac.source=1.8
+javac.release=17
 javac.compilerargs=-Xlint -Xlint:-serial
 
 test.config.semantic.includes=\
diff --git a/java/java.editor.base/src/org/netbeans/modules/java/editor/base/javadoc/JavadocCompletionUtils.java b/java/java.editor.base/src/org/netbeans/modules/java/editor/base/javadoc/JavadocCompletionUtils.java
index a0682653d7f6..0bf0f69914db 100644
--- a/java/java.editor.base/src/org/netbeans/modules/java/editor/base/javadoc/JavadocCompletionUtils.java
+++ b/java/java.editor.base/src/org/netbeans/modules/java/editor/base/javadoc/JavadocCompletionUtils.java
@@ -51,7 +51,7 @@
  */
 public final class JavadocCompletionUtils {
     
-    static final Pattern JAVADOC_LINE_BREAK = Pattern.compile("\\n[ \\t]*\\**[ \\t]*\\z"); // NOI18N
+    static final Pattern JAVADOC_LINE_BREAK = Pattern.compile("(\\n[ \\t]*\\**[ \\t]*\\z)|(\\n[ \\t]*///[ \\t]*\\z)"); // NOI18N
     static final Pattern JAVADOC_WHITE_SPACE = Pattern.compile("[^ \\t]"); // NOI18N
     /**
      * javadoc parser considers whatever number of spaces or standalone newline
@@ -62,7 +62,7 @@ public final class JavadocCompletionUtils {
     static final Pattern JAVADOC_EMPTY = Pattern.compile("(\\s*\\**\\s*\n)*\\s*\\**\\s*\\**"); // NOI18N
     static final Pattern JAVADOC_FIRST_WHITE_SPACE = Pattern.compile("[ \\t]*\\**[ \\t]*"); // NOI18N
     private static Set<JavaTokenId> IGNORE_TOKES = EnumSet.of(
-            JavaTokenId.WHITESPACE, JavaTokenId.BLOCK_COMMENT, JavaTokenId.LINE_COMMENT);
+            JavaTokenId.WHITESPACE, JavaTokenId.BLOCK_COMMENT, JavaTokenId.LINE_COMMENT, JavaTokenId.JAVADOC_COMMENT_LINE_RUN);
     private static final Logger LOGGER = Logger.getLogger(JavadocCompletionUtils.class.getName());
     
     /**
@@ -196,6 +196,7 @@ public static TokenSequence<JavadocTokenId> findJavadocTokenSequence(Compilation
                         break;
                     }
                 case JAVADOC_COMMENT:
+                case JAVADOC_COMMENT_LINE_RUN:
                     if (token.partType() == PartType.COMPLETE) {
                         return javac.getElements().getDocComment(e) == null
                                 ? null : s.embedded(JavadocTokenId.language());
@@ -246,36 +247,39 @@ static boolean isInsideIndent(Token<JavadocTokenId> token, int offset) {
     
     /**
      * Is javadoc line break?
-     * @param token token to test
+     * @param ts a token sequence positioned to the token to test
      * @return {@code true} in case the token is something like {@code "\n\t*"}
      */
-    public static boolean isLineBreak(Token<JavadocTokenId> token) {
-        return isLineBreak(token, token.length());
+    public static boolean isLineBreak(TokenSequence<JavadocTokenId> ts) {
+        return isLineBreak(ts, ts.token().length());
     }
     
     /**
      * Tests if the token part before {@code pos} is a javadoc line break.
-     * @param token a token to test
+     * @param ts a token sequence positioned to the token to test
      * @param pos position in the token
      * @return {@code true} in case the token is something like {@code "\n\t* |\n\t*"}
      */
-    public static boolean isLineBreak(Token<JavadocTokenId> token, int pos) {
+    public static boolean isLineBreak(TokenSequence<JavadocTokenId> ts, int pos) {
+        Token<JavadocTokenId> token = ts.token();
+
         if (token == null || token.id() != JavadocTokenId.OTHER_TEXT) {
-            return false;
+            return ts.isEmpty() || ts.index() == 0;
         }
         try {
             CharSequence text = token.text();
             if (pos < token.length())
                 text = text.subSequence(0, pos);
-            boolean result = pos > 0
+            boolean result = (pos > 0
                     && JAVADOC_LINE_BREAK.matcher(text).find()
-                    && (pos == token.length() || !isInsideIndent(token, pos));
+                    && (pos == token.length() || !isInsideIndent(token, pos))
+                    );
             return result;
         } catch (IndexOutOfBoundsException e) {
             throw (IndexOutOfBoundsException) new IndexOutOfBoundsException("pos: " + pos + ", token.length: " + token.length() + ", token text: " + token.text()).initCause(e);
         }
     }
-    
+
     public static boolean isWhiteSpace(CharSequence text) {
         return text != null && text.length() > 0 && !JAVADOC_WHITE_SPACE.matcher(text).find();
     }
@@ -437,7 +441,8 @@ private static boolean movedToJavadocToken(TokenSequence<JavaTokenId> ts, int of
             return false;
         }
         
-        if (ts.token().id() != JavaTokenId.JAVADOC_COMMENT) {
+        if (ts.token().id() != JavaTokenId.JAVADOC_COMMENT &&
+            ts.token().id() != JavaTokenId.JAVADOC_COMMENT_LINE_RUN) {
             return false;
         }
         
@@ -456,6 +461,11 @@ private static boolean isEmptyJavadoc(Token<JavaTokenId> token, int offset) {
             // check special case /**|*/
             return offset == 3 && "/***/".contentEquals(text); //NOI18N
         }
+        if (token != null && token.id() == JavaTokenId.JAVADOC_COMMENT_LINE_RUN) {
+            CharSequence text = token.text();
+            // check special case ///|\n
+            return offset == 3 && "///\n".contentEquals(text); //NOI18N
+        }
         return false;
     }
 
diff --git a/java/java.editor.base/src/org/netbeans/modules/java/editor/base/javadoc/JavadocImports.java b/java/java.editor.base/src/org/netbeans/modules/java/editor/base/javadoc/JavadocImports.java
index 07ccd639c0e0..2d91d7065f64 100644
--- a/java/java.editor.base/src/org/netbeans/modules/java/editor/base/javadoc/JavadocImports.java
+++ b/java/java.editor.base/src/org/netbeans/modules/java/editor/base/javadoc/JavadocImports.java
@@ -641,7 +641,7 @@ public static boolean isInsideReference(TokenSequence<JavadocTokenId> jdts, int
                         }
                     case OTHER_TEXT:
                         isBeforeWS |= JavadocCompletionUtils.isWhiteSpace(jdt);
-                        isBeforeWS |= JavadocCompletionUtils.isLineBreak(jdt);
+                        isBeforeWS |= JavadocCompletionUtils.isLineBreak(jdts);
                         if (isBeforeWS) {
                             continue;
                         } else {
@@ -690,7 +690,9 @@ private static TokenSequence<JavadocTokenId> getJavadocTS(CompilationInfo javac,
         TokenSequence<JavadocTokenId> javadoc = null;
         TokenSequence<JavaTokenId> ts = SourceUtils.getJavaTokenSequence(javac.getTokenHierarchy(), start);
 
-        if (ts.moveNext() && ts.token().id() == JavaTokenId.JAVADOC_COMMENT) {
+        if (ts.moveNext() &&
+            (ts.token().id() == JavaTokenId.JAVADOC_COMMENT ||
+             ts.token().id() == JavaTokenId.JAVADOC_COMMENT_LINE_RUN)) {
             javadoc = ts.embedded(JavadocTokenId.language());
         }
         
@@ -893,14 +895,14 @@ private static void insideTag(DocTreePath tag, JavadocContext jdctx, int caretOf
             cs = pos < cs.length() ? cs.subSequence(0, pos) : cs;
 
             if (JavadocCompletionUtils.isWhiteSpace(cs)
-                    || JavadocCompletionUtils.isLineBreak(jdts.token(), pos)) {
+                    || JavadocCompletionUtils.isLineBreak(jdts, pos)) {
                 noPrefix = true;
             } else {
                 // broken syntax
                 return;
             }
         } else if (!(JavadocCompletionUtils.isWhiteSpace(jdts.token())
-                || JavadocCompletionUtils.isLineBreak(jdts.token()))) {
+                || JavadocCompletionUtils.isLineBreak(jdts))) {
             // not java reference
             return;
         } else if (jdts.moveNext()) {
diff --git a/java/java.editor.base/test/unit/src/org/netbeans/modules/java/editor/base/javadoc/JavadocCompletionUtilsTest.java b/java/java.editor.base/test/unit/src/org/netbeans/modules/java/editor/base/javadoc/JavadocCompletionUtilsTest.java
index add1ca7dc20d..33926dc0b405 100644
--- a/java/java.editor.base/test/unit/src/org/netbeans/modules/java/editor/base/javadoc/JavadocCompletionUtilsTest.java
+++ b/java/java.editor.base/test/unit/src/org/netbeans/modules/java/editor/base/javadoc/JavadocCompletionUtilsTest.java
@@ -270,32 +270,32 @@ public void testIsLineBreak() throws Exception {
         TokenSequence<JavadocTokenId> jdts = JavadocCompletionUtils.findJavadocTokenSequence(info, offset);
         assertTrue(jdts.moveNext());
         assertTrue(insertPointer(code, offset),
-                JavadocCompletionUtils.isLineBreak(jdts.token()));
+                JavadocCompletionUtils.isLineBreak(jdts));
         offset += 1;
         jdts = JavadocCompletionUtils.findJavadocTokenSequence(info, offset);
         assertTrue(jdts.moveNext());
         // token is INDENT
         assertFalse(insertPointer(code, offset),
-                JavadocCompletionUtils.isLineBreak(jdts.token()));
+                JavadocCompletionUtils.isLineBreak(jdts));
         
         what = "  \n";
         offset = code.indexOf(what);
         jdts = JavadocCompletionUtils.findJavadocTokenSequence(info, offset);
         assertTrue(jdts.moveNext());
         assertTrue(insertPointer(code, offset),
-                JavadocCompletionUtils.isLineBreak(jdts.token(), offset - jdts.offset()));
+                JavadocCompletionUtils.isLineBreak(jdts, offset - jdts.offset()));
         
         what = "  * {*i";
         offset = code.indexOf(what) + what.length() - 3;
         jdts = JavadocCompletionUtils.findJavadocTokenSequence(info, offset);
         assertTrue(jdts.moveNext());
         assertFalse(insertPointer(code, offset),
-                JavadocCompletionUtils.isLineBreak(jdts.token()));
+                JavadocCompletionUtils.isLineBreak(jdts));
         assertTrue(insertPointer(code, offset),
-                JavadocCompletionUtils.isLineBreak(jdts.token(), offset - jdts.offset()));
+                JavadocCompletionUtils.isLineBreak(jdts, offset - jdts.offset()));
         offset = code.indexOf(what);
         assertFalse(insertPointer(code, offset),
-                JavadocCompletionUtils.isLineBreak(jdts.token(), offset - jdts.offset()));
+                JavadocCompletionUtils.isLineBreak(jdts, offset - jdts.offset()));
     }
     
     public void testIsLineBreak2() throws Exception {
@@ -319,10 +319,10 @@ public void testIsLineBreak2() throws Exception {
         assertTrue(jdts.moveNext());
         assertTrue(jdts.token().id() == JavadocTokenId.OTHER_TEXT);
         assertFalse(insertPointer(code, jdts.offset() + jdts.token().length()),
-                JavadocCompletionUtils.isLineBreak(jdts.token()));
+                JavadocCompletionUtils.isLineBreak(jdts));
         // test OTHER_TEXT('     * |{')
         assertTrue(insertPointer(code, jdts.offset() + jdts.token().length() - 1),
-                JavadocCompletionUtils.isLineBreak(jdts.token(), jdts.token().length() - 1));
+                JavadocCompletionUtils.isLineBreak(jdts, jdts.token().length() - 1));
     }
     
     public void testIsWhiteSpace() throws Exception {
diff --git a/java/java.editor.base/test/unit/src/org/netbeans/modules/java/editor/base/javadoc/JavadocImportsTest.java b/java/java.editor.base/test/unit/src/org/netbeans/modules/java/editor/base/javadoc/JavadocImportsTest.java
index e64ec4698b52..a880930c5850 100644
--- a/java/java.editor.base/test/unit/src/org/netbeans/modules/java/editor/base/javadoc/JavadocImportsTest.java
+++ b/java/java.editor.base/test/unit/src/org/netbeans/modules/java/editor/base/javadoc/JavadocImportsTest.java
@@ -207,6 +207,124 @@ public void testComputeReferencedElements() throws Exception {
         assertEquals(exp, sortedResult);
     }
     
+    public void testComputeReferencedElementsMarkdown() throws Exception {
+        String code =
+                """
+                package p;
+                import java.io.IOException;
+                import java.util.Collections;
+                import java.util.List;
+                class C {
+                   ///link1 {@link Runnable}
+                   ///link3 {@linkplain Collections#binarySearch(java.util.List, Object) search}
+                   ///{@link java. uncomplete reference}
+                   ///unclosed link {@value Math#PI}
+                   ///@see List
+                   ///@throws IOException
+                   void m() throws java.io.IOException {
+                   }
+                   ///
+                   ///{@link Collections}
+                   ///
+                   int field;
+                   /// {@link IOException
+                   interface InnerInterface {}
+                   /// {@link Collections}
+                   @interface InnerAnnotationType {}
+                }
+                /// {@link Collections}
+                enum TopLevelEnum {
+                   /** {@link Collections} */   E1
+                }
+                """;
+                //TODO: does not work:
+                //unclosed link {@value Math#PI\n
+        prepareTest(code);
+
+        // C.m()
+        TreePath member = findPath(code, "m() throws");
+        assertNotNull(member);
+        List <TypeElement> exp = Arrays.asList(
+                info.getElements().getTypeElement("java.lang.Runnable"),
+                info.getElements().getTypeElement("java.lang.Math"),
+                info.getElements().getTypeElement("java.lang.Object"),
+                info.getElements().getTypeElement("java.util.Collections"),
+                info.getElements().getTypeElement("java.util.List"),
+                info.getElements().getTypeElement("java.io.IOException")
+                );
+        Collections.<TypeElement>sort(exp, new ElementComparator());
+        Set<TypeElement> result = JavadocImports.computeReferencedElements(info, member);
+        assertNotNull(result);
+        List<TypeElement> sortedResult = new ArrayList<TypeElement>(result);
+        sortedResult.sort(new ElementComparator());
+        assertEquals(exp, sortedResult);
+
+        // C.field
+        member = findPath(code, "field;");
+        assertNotNull(member);
+        exp = Arrays.asList(
+                info.getElements().getTypeElement("java.util.Collections")
+                );
+        Collections.<TypeElement>sort(exp, new ElementComparator());
+        result = JavadocImports.computeReferencedElements(info, member);
+        assertNotNull(result);
+        sortedResult = new ArrayList<TypeElement>(result);
+        sortedResult.sort(new ElementComparator());
+        assertEquals(exp, sortedResult);
+
+        // C.InnerInterface
+        member = findPath(code, "InnerInterface {");
+        assertNotNull(member);
+        exp = Arrays.asList(
+                info.getElements().getTypeElement("java.io.IOException")
+                );
+        Collections.<TypeElement>sort(exp, new ElementComparator());
+        result = JavadocImports.computeReferencedElements(info, member);
+        assertNotNull(result);
+        sortedResult = new ArrayList<TypeElement>(result);
+        sortedResult.sort(new ElementComparator());
+        assertEquals(exp, sortedResult);
+
+        // C.InnerAnnotationType
+        member = findPath(code, "InnerAnnotationType {");
+        assertNotNull(member);
+        exp = Arrays.asList(
+                info.getElements().getTypeElement("java.util.Collections")
+                );
+        Collections.<TypeElement>sort(exp, new ElementComparator());
+        result = JavadocImports.computeReferencedElements(info, member);
+        assertNotNull(result);
+        sortedResult = new ArrayList<TypeElement>(result);
+        sortedResult.sort(new ElementComparator());
+        assertEquals(exp, sortedResult);
+
+        // TopLevelEnum
+        member = findPath(code, "TopLevelEnum {");
+        assertNotNull(member);
+        exp = Arrays.asList(
+                info.getElements().getTypeElement("java.util.Collections")
+                );
+        Collections.<TypeElement>sort(exp, new ElementComparator());
+        result = JavadocImports.computeReferencedElements(info, member);
+        assertNotNull(result);
+        sortedResult = new ArrayList<TypeElement>(result);
+        sortedResult.sort(new ElementComparator());
+        assertEquals(exp, sortedResult);
+
+        // TopLevelEnum.E1
+        member = findPath(code, "E1\n");
+        assertNotNull(member);
+        exp = Arrays.asList(
+                info.getElements().getTypeElement("java.util.Collections")
+                );
+        Collections.<TypeElement>sort(exp, new ElementComparator());
+        result = JavadocImports.computeReferencedElements(info, member);
+        assertNotNull(result);
+        sortedResult = new ArrayList<TypeElement>(result);
+        sortedResult.sort(new ElementComparator());
+        assertEquals(exp, sortedResult);
+    }
+
     public void testComputeTokensOfReferencedElements() throws Exception {
         String code = 
                 "package p;\n" +
@@ -286,6 +404,87 @@ public void testComputeTokensOfReferencedElements() throws Exception {
 //        assertEquals(toFind.toString(), exp, tokens);
     }
 
+    public void testComputeTokensOfReferencedElementsMarkdown() throws Exception {
+        String code =
+                """
+                package p;
+                import java.util.Collections;
+                class C {
+                   ///link1 {@link Runnable}
+                   ///link2 {@link Collections#binarySearch(java.util.List, java.lang.Object) search}
+                   ///{@link java. uncomplete reference}   ///unclosed link {@value Math#PI}
+                   ///@see java.util.Collections
+                   ///@throws ThrowsUnresolved
+                   ///
+                   void m() throws java.io.IOException {
+                       Collections.<String>binarySearch(Collections.<String>emptyList(), "");
+                       double pi = Math.PI;
+                   }
+                }
+                """;
+                //TODO: does not work:
+                //unclosed link {@value Math#PI\n
+        prepareTest(code);
+
+        TreePath where = findPath(code, "m() throws");
+        assertNotNull(where);
+        TokenSequence<JavadocTokenId> jdts = JavadocCompletionUtils.findJavadocTokenSequence(info, null, info.getTrees().getElement(where));
+        assertNotNull(jdts);
+        List<Token> exp;
+
+        // toFind java.lang.Runnable
+        Element toFind = info.getElements().getTypeElement("java.lang.Runnable");
+        assertNotNull(toFind);
+        List<Token> tokens = JavadocImports.computeTokensOfReferencedElements(info, where, toFind);
+        assertNotNull(toFind.toString(), tokens);
+        jdts.move(code.indexOf("Runnable", code.indexOf("link1")));
+        assertTrue(jdts.moveNext());
+        exp = Arrays.<Token>asList(jdts.token());
+        assertEquals(toFind.toString(), exp, tokens);
+
+        // toFind java.util.Collections
+        toFind = info.getElements().getTypeElement("java.util.Collections");
+        assertNotNull(toFind);
+        tokens = JavadocImports.computeTokensOfReferencedElements(info, where, toFind);
+        assertNotNull(toFind.toString(), tokens);
+        exp = new ArrayList<Token>();
+        jdts.move(code.indexOf("Collections", code.indexOf("link2")));
+        assertTrue(jdts.moveNext());
+        exp.add(jdts.token());
+        jdts.move(code.indexOf("Collections", code.indexOf("///@see")));
+        assertTrue(jdts.moveNext());
+        exp.add(jdts.token());
+        System.err.println("exp:");
+        for (Token e : exp) {
+            System.err.println(e.text());
+        }
+        System.err.println("tokens:");
+        for (Token e : tokens) {
+            System.err.println(e.text());
+        }
+        assertEquals(toFind.toString(), exp, tokens);
+
+        // toFind Math#PI
+        toFind = findElement(code, "PI;\n");
+        assertNotNull(toFind);
+        tokens = JavadocImports.computeTokensOfReferencedElements(info, where, toFind);
+        assertNotNull(toFind.toString(), tokens);
+        jdts.move(code.indexOf("PI", code.indexOf("unclosed link")));
+        assertTrue(jdts.moveNext());
+        exp = Arrays.<Token>asList(jdts.token());
+        assertEquals(toFind.toString(), exp, tokens);
+
+        // toFind Collections#binarySearch
+        toFind = findElement(code, "binarySearch(Collections.<String>emptyList()");
+        assertNotNull(toFind);
+        tokens = JavadocImports.computeTokensOfReferencedElements(info, where, toFind);
+        assertNotNull(toFind.toString(), tokens);
+        jdts.move(code.indexOf("binarySearch", code.indexOf("link2")));
+        assertTrue(jdts.moveNext());
+        exp = Arrays.<Token>asList(jdts.token());
+//        assertEquals(toFind.toString(), exp, tokens);
+    }
+
     public void testComputeTokensOfReferencedElementsForParams() throws Exception {
         String code =
                 "package p;\n" +
diff --git a/java/java.editor.base/test/unit/src/org/netbeans/modules/java/editor/base/javadoc/JavadocTestSupport.java b/java/java.editor.base/test/unit/src/org/netbeans/modules/java/editor/base/javadoc/JavadocTestSupport.java
index 7c153124956a..8770a3906721 100644
--- a/java/java.editor.base/test/unit/src/org/netbeans/modules/java/editor/base/javadoc/JavadocTestSupport.java
+++ b/java/java.editor.base/test/unit/src/org/netbeans/modules/java/editor/base/javadoc/JavadocTestSupport.java
@@ -20,7 +20,9 @@
 package org.netbeans.modules.java.editor.base.javadoc;
 
 import java.io.File;
+import java.util.ArrayList;
 import java.util.Enumeration;
+import java.util.List;
 import javax.swing.text.StyledDocument;
 import org.netbeans.api.editor.mimelookup.MimePath;
 import org.netbeans.api.editor.mimelookup.test.MockMimeLookup;
@@ -62,10 +64,10 @@ protected void setUp() throws Exception {
         super.setUp();
         
         MockMimeLookup.setInstances(MimePath.parse("text/x-java"), new JavaKit());
-        SourceUtilsTestUtil.prepareTest(new String[0], new Object[] {
-            new Pool(),
-            new MockMimeLookup(),
-        });
+        List<Object> services = new ArrayList<>();
+        services.add(new Pool());
+        services.add(new MockMimeLookup());
+        SourceUtilsTestUtil.prepareTest(new String[0], services.toArray());
         FileUtil.setMIMEType("java", "text/x-java");
         
         if (cache == null) {
@@ -115,7 +117,11 @@ protected void prepareTest(String code) throws Exception {
         assertNotNull(info);
         assertTrue(info.getDiagnostics().toString(), info.getDiagnostics().isEmpty());
     }
-    
+
+    protected Object[] additionalServices() {
+        return new Object[0];
+    }
+
     /**
      * Inserts a marker '|' to string {@code s} on position {@code pos}. Useful
      * for assert's debug messages
diff --git a/java/java.editor/nbproject/project.properties b/java/java.editor/nbproject/project.properties
index 914e09646b80..9c667f21de38 100644
--- a/java/java.editor/nbproject/project.properties
+++ b/java/java.editor/nbproject/project.properties
@@ -19,7 +19,7 @@ javadoc.title=Java Editor
 
 spec.version.base=2.93.0
 test.qa-functional.cp.extra=${editor.dir}/modules/org-netbeans-modules-editor-fold.jar
-javac.source=1.8
+javac.release=17
 #test.unit.cp.extra=
 #test.unit.run.cp.extra=${o.n.core.dir}/core/core.jar:${o.n.core.dir}/lib/boot.jar:${libs.xerces.dir}/modules/ext/xerces-2.6.2.jar:${libs.xerces.dir}/modules/ext/xml-commons-dom-ranges-1.0.b2.jar:${retouche/javacimpl.dir}/modules/ext/javac-impl.jar
 
diff --git a/java/java.editor/src/org/netbeans/modules/editor/java/GoToSupport.java b/java/java.editor/src/org/netbeans/modules/editor/java/GoToSupport.java
index 8a60126a7266..3e8b08e4e7a2 100644
--- a/java/java.editor/src/org/netbeans/modules/editor/java/GoToSupport.java
+++ b/java/java.editor/src/org/netbeans/modules/editor/java/GoToSupport.java
@@ -408,7 +408,7 @@ public static Context resolveContext(CompilationInfo controller, Document doc, i
         boolean insideImportStmt = false;
         TreePath path = controller.getTreeUtilities().pathFor(exactOffset);
 
-        if (token[0] != null && token[0].id() == JavaTokenId.JAVADOC_COMMENT) {
+        if (token[0] != null && (token[0].id() == JavaTokenId.JAVADOC_COMMENT || token[0].id() == JavaTokenId.JAVADOC_COMMENT_LINE_RUN)) {
             el = JavadocImports.findReferencedElement(controller, offset);
         } else {
             path = adjustPathForModuleName(path);
@@ -662,7 +662,7 @@ public void run() {
 
                 Token<JavaTokenId> t = ts.token();
 
-                if (JavaTokenId.JAVADOC_COMMENT == t.id()) {
+                if (JavaTokenId.JAVADOC_COMMENT == t.id() || JavaTokenId.JAVADOC_COMMENT_LINE_RUN == t.id()) {
                     // javadoc hyperlinking (references + param names)
                     TokenSequence<JavadocTokenId> jdts = ts.embedded(JavadocTokenId.language());
                     if (JavadocImports.isInsideReference(jdts, offset) || JavadocImports.isInsideParamName(jdts, offset)) {
diff --git a/java/java.editor/src/org/netbeans/modules/editor/java/JavaCompletionCollector.java b/java/java.editor/src/org/netbeans/modules/editor/java/JavaCompletionCollector.java
index cd61d9094104..a68dc91894fa 100644
--- a/java/java.editor/src/org/netbeans/modules/editor/java/JavaCompletionCollector.java
+++ b/java/java.editor/src/org/netbeans/modules/editor/java/JavaCompletionCollector.java
@@ -1319,6 +1319,7 @@ private static TokenSequence<JavaTokenId> findLastNonWhitespaceToken(TokenSequen
                     case LINE_COMMENT:
                     case BLOCK_COMMENT:
                     case JAVADOC_COMMENT:
+                    case JAVADOC_COMMENT_LINE_RUN:
                         break;
                     default:
                         return ts;
diff --git a/java/java.editor/src/org/netbeans/modules/editor/java/JavaCompletionItem.java b/java/java.editor/src/org/netbeans/modules/editor/java/JavaCompletionItem.java
index 733ba9ad3226..47fbd2803f85 100644
--- a/java/java.editor/src/org/netbeans/modules/editor/java/JavaCompletionItem.java
+++ b/java/java.editor/src/org/netbeans/modules/editor/java/JavaCompletionItem.java
@@ -4617,6 +4617,7 @@ private static TokenSequence<JavaTokenId> findLastNonWhitespaceToken(TokenSequen
                 case LINE_COMMENT:
                 case BLOCK_COMMENT:
                 case JAVADOC_COMMENT:
+                case JAVADOC_COMMENT_LINE_RUN:
                     break;
                 default:
                     return ts;
diff --git a/java/java.editor/src/org/netbeans/modules/editor/java/JavaKit.java b/java/java.editor/src/org/netbeans/modules/editor/java/JavaKit.java
index 5ac389c224c5..adefaee33d02 100644
--- a/java/java.editor/src/org/netbeans/modules/editor/java/JavaKit.java
+++ b/java/java.editor/src/org/netbeans/modules/editor/java/JavaKit.java
@@ -458,6 +458,7 @@ public void insert(MutableContext context) throws BadLocationException {
                 if (isJavadocTouched) {
                     blockCommentComplete(doc, dotPos, context);
                 }
+                TypingCompletion.javadocLineRunCompletion(context);
             }
         }
 
diff --git a/java/java.editor/src/org/netbeans/modules/editor/java/TypingCompletion.java b/java/java.editor/src/org/netbeans/modules/editor/java/TypingCompletion.java
index 5f2172b49d88..0682f52f5f6f 100644
--- a/java/java.editor/src/org/netbeans/modules/editor/java/TypingCompletion.java
+++ b/java/java.editor/src/org/netbeans/modules/editor/java/TypingCompletion.java
@@ -563,6 +563,21 @@ private static boolean isClosedBlockComment(CharSequence txt, int pos) {
         return false;
     }
 
+    static boolean javadocLineRunCompletion(TypedBreakInterceptor.MutableContext context) {
+        TokenSequence<JavaTokenId> ts = javaTokenSequence(context, false);
+        if (ts == null) {
+            return false;
+        }
+        int dotPosition = context.getCaretOffset();
+        ts.move(dotPosition);
+        if (!((ts.moveNext() || ts.movePrevious()) && ts.token().id() == JavaTokenId.JAVADOC_COMMENT_LINE_RUN)) {
+            return false;
+        }
+        context.setText("\n///", -1, 4, 0, 4);
+
+        return false;
+    }
+
     private static boolean isAtRowEnd(CharSequence txt, int pos) {
         int length = txt.length();
         for (int i = pos; i < length; i++) {
diff --git a/java/java.editor/src/org/netbeans/modules/editor/java/Utilities.java b/java/java.editor/src/org/netbeans/modules/editor/java/Utilities.java
index da31e094c582..6ccb51a51e3a 100644
--- a/java/java.editor/src/org/netbeans/modules/editor/java/Utilities.java
+++ b/java/java.editor/src/org/netbeans/modules/editor/java/Utilities.java
@@ -288,6 +288,7 @@ public static boolean isJavaContext(final Document doc, final int offset, final
             case INVALID_COMMENT_END:
             case JAVADOC_COMMENT:
             case LINE_COMMENT:
+            case JAVADOC_COMMENT_LINE_RUN:
             case BLOCK_COMMENT:
                 return false;
             case STRING_LITERAL:
diff --git a/java/java.editor/src/org/netbeans/modules/java/editor/javadoc/JavadocCompletionTask.java b/java/java.editor/src/org/netbeans/modules/java/editor/javadoc/JavadocCompletionTask.java
index eac6a5607c25..c328d4ae418d 100644
--- a/java/java.editor/src/org/netbeans/modules/java/editor/javadoc/JavadocCompletionTask.java
+++ b/java/java.editor/src/org/netbeans/modules/java/editor/javadoc/JavadocCompletionTask.java
@@ -64,6 +64,7 @@
 import javax.swing.text.Document;
 import org.netbeans.api.annotations.common.NonNull;
 import org.netbeans.api.annotations.common.NullAllowed;
+import org.netbeans.api.java.lexer.JavaTokenId;
 import org.netbeans.api.java.lexer.JavadocTokenId;
 import org.netbeans.api.java.source.ClassIndex;
 import org.netbeans.api.java.source.ClasspathInfo;
@@ -84,6 +85,7 @@
 import org.netbeans.modules.parsing.api.Source;
 import org.netbeans.modules.parsing.api.UserTask;
 import org.netbeans.modules.parsing.spi.Parser;
+import org.openide.util.Pair;
 
 public class JavadocCompletionTask<T> extends UserTask {
 
@@ -188,16 +190,20 @@ private void analyzeContext(JavadocContext jdctx) {
             return;
         }
         jdts.move(this.caretOffset);
+        JavadocTokenId javadocId;
         if (!jdts.moveNext() && !jdts.movePrevious()) {
             // XXX solve /***/
             // provide block tags, inline tags, html
-            return;
-        }
-        if (this.caretOffset - jdts.offset() == 0) {
-            // if position in token == 0 resolve CC according to previous token
-            jdts.movePrevious();
+            // XXX: for Markdown, continuing
+            javadocId = JavadocTokenId.OTHER_TEXT;
+        } else {
+            if (this.caretOffset - jdts.offset() == 0) {
+                // if position in token == 0 resolve CC according to previous token
+                jdts.movePrevious();
+            }
+            javadocId = jdts.token().id();
         }
-        switch (jdts.token().id()) {
+        switch (javadocId) {
             case TAG:
                 resolveTagToken(jdctx);
                 break;
@@ -265,7 +271,9 @@ void resolveInlineTag(DocTreePath tag, JavadocContext jdctx) {
 
     private int skipWhitespacesBackwards(final JavadocContext jdctx, final int offset) {
         if (jdctx.jdts.move(offset) == 0 || !jdctx.jdts.moveNext()) {
-            jdctx.jdts.movePrevious();
+            if (!jdctx.jdts.movePrevious()) {
+                return offset;
+            }
         }
         do {
             Token t = jdctx.jdts.token();
@@ -415,13 +423,13 @@ private void insideSeeTag(DocTreePath tag, JavadocContext jdctx) {
             int pos = caretOffset - jdts.offset();
             CharSequence cs = jdts.token().text();
             cs = pos < cs.length() ? cs.subSequence(0, pos) : cs;
-            if (JavadocCompletionUtils.isWhiteSpace(cs) || JavadocCompletionUtils.isLineBreak(jdts.token(), pos)) {
+            if (JavadocCompletionUtils.isWhiteSpace(cs) || JavadocCompletionUtils.isLineBreak(jdts, pos)) {
                 noPrefix = true;
             } else {
                 // broken syntax
                 return;
             }
-        } else if (!(JavadocCompletionUtils.isWhiteSpace(jdts.token()) || JavadocCompletionUtils.isLineBreak(jdts.token()))) {
+        } else if (!(JavadocCompletionUtils.isWhiteSpace(jdts.token()) || JavadocCompletionUtils.isLineBreak(jdts))) {
             // not java reference
             return;
         } else if (jdts.moveNext()) {
@@ -519,7 +527,7 @@ private void insideParamTag(DocTreePath tag, JavadocContext jdctx) {
             int pos = caretOffset - jdts.offset();
             CharSequence cs = jdts.token().text();
             cs = pos < cs.length() ? cs.subSequence(0, pos) : cs;
-            if (JavadocCompletionUtils.isWhiteSpace(cs) || JavadocCompletionUtils.isLineBreak(jdts.token(), pos)) {
+            if (JavadocCompletionUtils.isWhiteSpace(cs) || JavadocCompletionUtils.isLineBreak(jdts, pos)) {
                 // none prefix
                 anchorOffset = caretOffset;
                 completeParamName(tag, "", caretOffset, jdctx); // NOI18N
@@ -1226,11 +1234,10 @@ private boolean startsWith(String theString, String prefix) {
 
     void resolveOtherText(JavadocContext jdctx, TokenSequence<JavadocTokenId> jdts) {
         Token<JavadocTokenId> token = jdts.token();
-        assert token != null;
-        assert token.id() == JavadocTokenId.OTHER_TEXT;
-        CharSequence text = token.text();
-        int pos = caretOffset - jdts.offset();
-        DocTreePath tag = getTag(jdctx, caretOffset);
+        assert token == null || token.id() == JavadocTokenId.OTHER_TEXT;
+        CharSequence text = token == null ? "" : token.text();
+        int pos = token == null ? 0 : caretOffset - jdts.offset();
+        DocTreePath tag = token == null ? null : getTag(jdctx, caretOffset);
 
         if (pos > 0 && pos <= text.length() && text.charAt(pos - 1) == '{') {
             if (tag != null && !JavadocCompletionUtils.isBlockTag(tag)) {
@@ -1244,10 +1251,10 @@ void resolveOtherText(JavadocContext jdctx, TokenSequence<JavadocTokenId> jdts)
         }
         if (tag != null) {
             insideTag(tag, jdctx);
-            if (JavadocCompletionUtils.isBlockTag(tag) && JavadocCompletionUtils.isLineBreak(token, pos)) {
+            if (JavadocCompletionUtils.isBlockTag(tag) && JavadocCompletionUtils.isLineBreak(jdts, pos)) {
                 resolveBlockTag(null, jdctx);
             }
-        } else if (JavadocCompletionUtils.isLineBreak(token, pos)) {
+        } else if (JavadocCompletionUtils.isLineBreak(jdts, pos)) {
             resolveBlockTag(null, jdctx);
         }
     }
@@ -1336,6 +1343,7 @@ private static class JavadocContext {
         private DocCommentTree comment;
         private DocSourcePositions positions;
         private TokenSequence<JavadocTokenId> jdts;
+        private TokenSequence<JavaTokenId> javats;
         private Document doc;
         private ReferencesCount count;
         private TreePath javadocFor;
diff --git a/java/java.editor/test/unit/src/org/netbeans/modules/editor/java/GoToSupportTest.java b/java/java.editor/test/unit/src/org/netbeans/modules/editor/java/GoToSupportTest.java
index 8deac6817b8f..a506190feb74 100644
--- a/java/java.editor/test/unit/src/org/netbeans/modules/editor/java/GoToSupportTest.java
+++ b/java/java.editor/test/unit/src/org/netbeans/modules/editor/java/GoToSupportTest.java
@@ -1145,6 +1145,71 @@ public void testBindingVarToolTip() throws Exception {
         assertEquals("<html><body>java.lang.String <b>str</b>", tooltip);
     }
 
+    public void testJavadoc() throws Exception {
+        final boolean[] wasCalled = new boolean[1];
+        final String code = """
+                            package test;
+                            /**
+                             * @see Obj|ect
+                             */
+                            public class Test {
+                            }
+                            """;
+
+        performTest(code, new UiUtilsCaller() {
+            @Override public boolean open(FileObject fo, int pos) {
+                fail("Should not be called.");
+                return true;
+            }
+
+            @Override public void beep(boolean goToSource, boolean goToJavadoc) {
+                fail("Should not be called.");
+            }
+            @Override public boolean open(ClasspathInfo info, ElementHandle<?> el, String fileName) {
+                assertEquals("java.lang.Object", el.getBinaryName());
+                wasCalled[0] = true;
+                return true;
+            }
+            @Override public void warnCannotOpen(String displayName) {
+                fail("Should not be called.");
+            }
+        }, false, false);
+
+        assertTrue(wasCalled[0]);
+    }
+
+    public void testMarkdownJavadoc() throws Exception {
+        final boolean[] wasCalled = new boolean[1];
+        this.sourceLevel = "23";
+        final String code = """
+                            package test;
+                            ///@see Obj|ect
+                            public class Test {
+                            }
+                            """;
+
+        performTest(code, new UiUtilsCaller() {
+            @Override public boolean open(FileObject fo, int pos) {
+                fail("Should not be called.");
+                return true;
+            }
+
+            @Override public void beep(boolean goToSource, boolean goToJavadoc) {
+                fail("Should not be called.");
+            }
+            @Override public boolean open(ClasspathInfo info, ElementHandle<?> el, String fileName) {
+                assertEquals("java.lang.Object", el.getBinaryName());
+                wasCalled[0] = true;
+                return true;
+            }
+            @Override public void warnCannotOpen(String displayName) {
+                fail("Should not be called.");
+            }
+        }, false, false);
+
+        assertTrue(wasCalled[0]);
+    }
+
     private String sourceLevel = "1.5";
     private FileObject source;
 
diff --git a/java/java.editor/test/unit/src/org/netbeans/modules/editor/java/TypingCompletionUnitTest.java b/java/java.editor/test/unit/src/org/netbeans/modules/editor/java/TypingCompletionUnitTest.java
index a0713d608f6c..99efb7f02484 100644
--- a/java/java.editor/test/unit/src/org/netbeans/modules/editor/java/TypingCompletionUnitTest.java
+++ b/java/java.editor/test/unit/src/org/netbeans/modules/editor/java/TypingCompletionUnitTest.java
@@ -1419,6 +1419,22 @@ public void testX() throws Exception {
         ctx.assertDocumentTextEquals("{");
     }
 
+    public void testJavadocLineRun() {
+        Context ctx = new Context(new JavaKit(),
+                                  """
+                                  class Test {
+                                      ///|
+                                  }
+                                  """);
+        ctx.typeChar('\n');
+        ctx.assertDocumentTextEquals("""
+                                     class Test {
+                                         ///
+                                         ///|
+                                     }
+                                     """);
+    }
+
     private boolean isInsideString(String code) throws BadLocationException {
         int pos = code.indexOf('|');
 
diff --git a/java/java.editor/test/unit/src/org/netbeans/modules/java/editor/javadoc/JavadocCompletionQueryTest.java b/java/java.editor/test/unit/src/org/netbeans/modules/java/editor/javadoc/JavadocCompletionQueryTest.java
index 8bf90d619fab..48f00daca355 100644
--- a/java/java.editor/test/unit/src/org/netbeans/modules/java/editor/javadoc/JavadocCompletionQueryTest.java
+++ b/java/java.editor/test/unit/src/org/netbeans/modules/java/editor/javadoc/JavadocCompletionQueryTest.java
@@ -23,10 +23,14 @@
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
+import javax.swing.event.ChangeListener;
 import org.netbeans.junit.NbTestSuite;
 import org.netbeans.spi.editor.completion.CompletionItem;
 import org.netbeans.spi.editor.completion.CompletionProvider;
 import org.netbeans.modules.java.editor.base.javadoc.JavadocTestSupport;
+import org.netbeans.spi.java.queries.SourceLevelQueryImplementation2;
+import org.openide.filesystems.FileObject;
+import org.openide.util.lookup.ServiceProvider;
 
 /**
  *
@@ -492,7 +496,7 @@ public void testValue2() throws Exception {
                 "package p;\n" +
                 "class Clazz {\n" +
                 "    /**\n" +
-                "     * {@value Mat|\n" +
+                "     * {@value Math|\n" +
                 "     */\n" +
                 "    Clazz() {\n" +
                 "    }\n" +
@@ -601,8 +605,244 @@ public void testSummaryCompletionForMethod() throws Exception {
                 "}\n";
         performCompletionTest(code, "@summary:");
     }    
-    
-    
+
+    public void testBlockTagsCompletionInMarkdown() throws Exception {
+        String code =
+                """
+                package p;
+                class Clazz {
+                    ///
+                    /// |
+                    ///
+                    void method(int p1, int p2) {
+                    }
+                }
+                """;
+
+        performCompletionTest(code, "@deprecated:", "@exception:", "@hidden:", "@param:", "@return:", "@see:", "@serialData:", "@since:", "@throws:");
+    }
+
+    public void testBlockTagsCompletionInMarkdown2() throws Exception {
+        String code =
+                """
+                package p;
+                class Clazz {
+                    ///
+                    ///|
+                    ///
+                    void method(int p1, int p2) {
+                    }
+                }
+                """;
+
+        performCompletionTest(code, "@deprecated:", "@exception:", "@hidden:", "@param:", "@return:", "@see:", "@serialData:", "@since:", "@throws:");
+    }
+
+    public void testBlockTagsCompletionInMarkdown3() throws Exception {
+        String code =
+                """
+                package p;
+                class Clazz {
+                    ///
+                    ///|\s
+                    ///
+                    void method(int p1, int p2) {
+                    }
+                }
+                """;
+
+        performCompletionTest(code, "@deprecated:", "@exception:", "@hidden:", "@param:", "@return:", "@see:", "@serialData:", "@since:", "@throws:");
+    }
+
+    public void testBlockTagsCompletionInMarkdownStart() throws Exception {
+        String code =
+                """
+                package p;
+                class Clazz {
+                    ///|
+                    void method(int p1, int p2) {
+                    }
+                }
+                """;
+
+        performCompletionTest(code, "@deprecated:", "@exception:", "@hidden:", "@param:", "@return:", "@see:", "@serialData:", "@since:", "@throws:");
+    }
+
+    public void testSeeMarkdown1() throws Exception {
+        String code =
+                """
+                package p;
+                class Clazz {
+                    ///
+                    /// @see CharSequence#le|
+                    ///
+                    Clazz() {
+                    }
+                }
+                """;
+
+        performCompletionTest(code, "public abstract int length()");
+    }
+
+    public void testSeeMarkdown2() throws Exception {
+        String code =
+                """
+                package p;
+                class Clazz {
+                    ///
+                    /// @see |
+                    ///
+                    Clazz() {
+                    }
+                }
+                """;
+
+        performCompletionTest(code, null, "String", "Clazz");
+    }
+
+    public void testSeeMarkdown3() throws Exception {
+        String code =
+                """
+                package p;
+                class Clazz {
+                    ///@param i i
+                    ///@see |
+                    ///
+                    Clazz(int i) {
+                    }
+                }
+                """;
+
+        performCompletionTest(code, null, "String", "Clazz");
+    }
+
+    public void testParamMarkdown() throws Exception {
+        String code =
+                """
+                package p;
+                class Clazz {
+                    ///
+                    /// @param |
+                    ///
+                    void method(int p1, int p2) {
+                    }
+                }
+                """;
+
+        performCompletionTest(code, "p1:", "p2:");
+    }
+
+    public void testJavadocOldStart1() throws Exception {
+        String code =
+                """
+                package p;
+                class Clazz {
+                    /**| */
+                    void method(int p1, int p2) {
+                    }
+                }
+                """;
+
+        performCompletionTest(code, "@deprecated:", "@exception:", "@hidden:", "@param:", "@return:", "@see:", "@serialData:", "@since:", "@throws:");
+    }
+
+    public void testJavadocOldStart2() throws Exception {
+        String code =
+                """
+                package p;
+                class Clazz {
+                    /**@s| */
+                    void method(int p1, int p2) {
+                    }
+                }
+                """;
+
+        performCompletionTest(code, "@see:", "@serialData:", "@since:");
+    }
+
+    public void testJavadocOldStart3() throws Exception {
+        String code =
+                """
+                package p;
+                class Clazz {
+                    /**@param | */
+                    void method(int p1, int p2) {
+                    }
+                }
+                """;
+
+        performCompletionTest(code, "p1:", "p2:");
+    }
+
+    public void testJavadocOldStart4() throws Exception {
+        String code =
+                """
+                package p;
+                class Clazz {
+                    /**@see | */
+                    void method(int p1, int p2) {
+                    }
+                }
+                """;
+
+        performCompletionTest(code, null, "String", "Clazz");
+    }
+
+    public void testJavadocMarkdownStart1() throws Exception {
+        String code =
+                """
+                package p;
+                class Clazz {
+                    ///|
+                    void method(int p1, int p2) {
+                    }
+                }
+                """;
+
+        performCompletionTest(code, "@deprecated:", "@exception:", "@hidden:", "@param:", "@return:", "@see:", "@serialData:", "@since:", "@throws:");
+    }
+
+    public void testJavadocMarkdownStart2() throws Exception {
+        String code =
+                """
+                package p;
+                class Clazz {
+                    ///@s|
+                    void method(int p1, int p2) {
+                    }
+                }
+                """;
+
+        performCompletionTest(code, "@see:", "@serialData:", "@since:");
+    }
+
+    public void testJavadocMarkdownStart3() throws Exception {
+        String code =
+                """
+                package p;
+                class Clazz {
+                    ///@param |
+                    void method(int p1, int p2) {
+                    }
+                }
+                """;
+
+        performCompletionTest(code, "p1:", "p2:");
+    }
+
+    public void testJavadocMarkdownStart4() throws Exception {
+        String code =
+                """
+                package p;
+                class Clazz {
+                    ///@see |
+                    void method(int p1, int p2) {
+                    }
+                }
+                """;
+
+        performCompletionTest(code, null, "String", "Clazz");
+    }
 
     private static String stripHTML(String from) {
         StringBuilder result = new StringBuilder();
@@ -647,4 +887,30 @@ private void performCompletionTest(String code, String... golden) throws Excepti
             assertEquals(goldenList, resultStrings);
         }
     }
+
+    @Override
+    protected Object[] additionalServices() {
+        return new Object[] {
+            new SourceLevelQueryImplementation2() {
+
+                @Override
+                public Result getSourceLevel(FileObject javaFile) {
+                    return new Result() {
+                        @Override
+                        public String getSourceLevel() {
+                            return "23";
+                        }
+
+                        @Override
+                        public void addChangeListener(ChangeListener listener) {
+                        }
+
+                        @Override
+                        public void removeChangeListener(ChangeListener listener) {
+                        }
+                    };
+                }
+            }
+        };
+    }
 }
diff --git a/java/java.lexer/nbproject/project.properties b/java/java.lexer/nbproject/project.properties
index 4ea9ce2e2612..36e48fd27c57 100644
--- a/java/java.lexer/nbproject/project.properties
+++ b/java/java.lexer/nbproject/project.properties
@@ -17,7 +17,7 @@
 
 is.autoload=true
 javac.compilerargs=-Xlint:unchecked
-javac.source=1.8
+javac.release=17
 javadoc.title=Java Lexer API
 javadoc.apichanges=${basedir}/apichanges.xml
 
diff --git a/java/java.lexer/src/org/netbeans/api/java/lexer/JavaTokenId.java b/java/java.lexer/src/org/netbeans/api/java/lexer/JavaTokenId.java
index 17602a5e400a..25738a8da1ae 100644
--- a/java/java.lexer/src/org/netbeans/api/java/lexer/JavaTokenId.java
+++ b/java/java.lexer/src/org/netbeans/api/java/lexer/JavaTokenId.java
@@ -193,6 +193,7 @@ public enum JavaTokenId implements TokenId {
     LINE_COMMENT(null, "comment"), // Token includes ending new-line
     BLOCK_COMMENT(null, "comment"),
     JAVADOC_COMMENT(null, "comment"),
+    JAVADOC_COMMENT_LINE_RUN(null, "comment"), // A run of "markdown" javadoc comments, includes ending new-line
     
     // Errors
     INVALID_COMMENT_END("*/", "error"),
@@ -262,6 +263,9 @@ protected LanguageEmbedding<?> embedding(
                 case JAVADOC_COMMENT:
                     return LanguageEmbedding.create(JavadocTokenId.language(), 3,
                             (token.partType() == PartType.COMPLETE) ? 2 : 0);
+                case JAVADOC_COMMENT_LINE_RUN:
+                    return LanguageEmbedding.create(JavadocTokenId.language(), 3,
+                            (token.partType() == PartType.COMPLETE) ? 1 : 0);
                 case STRING_LITERAL:
                     return LanguageEmbedding.create(JavaStringTokenId.language(), 1,
                             (token.partType() == PartType.COMPLETE) ? 1 : 0);
diff --git a/java/java.lexer/src/org/netbeans/lib/java/lexer/JavaLexer.java b/java/java.lexer/src/org/netbeans/lib/java/lexer/JavaLexer.java
index 49c32619b467..438b8b84ffb3 100644
--- a/java/java.lexer/src/org/netbeans/lib/java/lexer/JavaLexer.java
+++ b/java/java.lexer/src/org/netbeans/lib/java/lexer/JavaLexer.java
@@ -321,6 +321,13 @@ public Token<JavaTokenId> nextToken() {
                 case '/':
                     switch (nextChar()) {
                         case '/': // in single-line comment
+                            switch (nextChar()) {
+                                case '/': return finishJavadocLineRun();
+                                case '\r': consumeNewline();
+                                case '\n':
+                                case EOF:
+                                    return token(JavaTokenId.LINE_COMMENT);
+                            }
                             while (true)
                                 switch (nextChar()) {
                                     case '\r': consumeNewline();
@@ -1428,6 +1435,34 @@ private Token<JavaTokenId> finishFloatExponent() {
                 return token(JavaTokenId.DOUBLE_LITERAL);
         }
     }
+
+    private Token<JavaTokenId> finishJavadocLineRun() {
+        while (true) {
+            //finish current line:
+            LINE: while (true) {
+                switch (nextChar()) {
+                    case '\r': consumeNewline();
+                    case '\n': break LINE;
+                    case EOF:
+                        return token(JavaTokenId.JAVADOC_COMMENT_LINE_RUN);
+                }
+            }
+
+            //at the next line, if it starts with "<whitespace>///", include it in the run,
+            //otherwise finish the run:
+            int mark = input.readLength();
+            int c;
+
+            while (Character.isWhitespace(c = nextChar()) && c != '\r' && c != '\n' && c != EOF)
+                ;
+
+            if (c != '/' || nextChar() != '/' || nextChar() != '/') {
+                input.backup(input.readLengthEOF()- mark);
+
+                return token(JavaTokenId.JAVADOC_COMMENT_LINE_RUN);
+            }
+        }
+    }
     
     private Token<JavaTokenId> token(JavaTokenId id) {
         return token(id, PartType.COMPLETE);
diff --git a/java/java.lexer/src/org/netbeans/lib/java/lexer/JavadocLexer.java b/java/java.lexer/src/org/netbeans/lib/java/lexer/JavadocLexer.java
index fa7189b48331..c6ab507fee3f 100644
--- a/java/java.lexer/src/org/netbeans/lib/java/lexer/JavadocLexer.java
+++ b/java/java.lexer/src/org/netbeans/lib/java/lexer/JavadocLexer.java
@@ -194,6 +194,20 @@ private Token<JavadocTokenId> otherText(int ch) {
                     leftbr = false;
                     newline = false;
                     break;
+                case '/':
+                    //TODO: check comment type?
+                    if (newline) {
+                        if (input.read() == '/') {
+                            if (input.read() == '/') {
+                                break;
+                            } else {
+                                input.backup(1);
+                            }
+                        } else {
+                            input.backup(1);
+                        }
+                        newline = false; //for fall-through:
+                    }
                 case '*':
                     if (newline) {
                         break;
diff --git a/java/java.lexer/test/unit/src/org/netbeans/lib/java/lexer/JavaLexerBatchTest.java b/java/java.lexer/test/unit/src/org/netbeans/lib/java/lexer/JavaLexerBatchTest.java
index 6402fc5c348f..bf4e0b71a8c2 100644
--- a/java/java.lexer/test/unit/src/org/netbeans/lib/java/lexer/JavaLexerBatchTest.java
+++ b/java/java.lexer/test/unit/src/org/netbeans/lib/java/lexer/JavaLexerBatchTest.java
@@ -812,4 +812,83 @@ public void testTemplates2() {
         assertFalse(ts.moveNext());
     }
 
+    public void testMarkdown1() {
+        String text = """
+                      ///test
+                      ///@see second line
+                      ///third
+
+                      ///another run
+                      ///another line
+
+                      """;
+        InputAttributes attr = new InputAttributes();
+        TokenHierarchy<?> hi = TokenHierarchy.create(text, false, JavaTokenId.language(), EnumSet.noneOf(JavaTokenId.class), attr);
+        TokenSequence<?> ts = hi.tokenSequence();
+
+        LexerTestUtilities.assertNextTokenEquals(ts,
+                                                 JavaTokenId.JAVADOC_COMMENT_LINE_RUN,
+                                                 "///test\n" +
+                                                 "///@see second line\n" +
+                                                 "///third\n");
+        LexerTestUtilities.assertNextTokenEquals(ts, JavaTokenId.WHITESPACE, "\n");
+        LexerTestUtilities.assertNextTokenEquals(ts,
+                                                 JavaTokenId.JAVADOC_COMMENT_LINE_RUN,
+                                                 "///another run\n" +
+                                                 "///another line\n");
+        LexerTestUtilities.assertNextTokenEquals(ts, JavaTokenId.WHITESPACE, "\n");
+        assertFalse(ts.moveNext());
+    }
+
+    public void testMarkdown2() {
+        String text = """
+                      ///test
+                      ///@see second line
+                      ///third
+
+                      ///another run
+                      ///another line
+                      """;
+        InputAttributes attr = new InputAttributes();
+        TokenHierarchy<?> hi = TokenHierarchy.create(text, false, JavaTokenId.language(), EnumSet.noneOf(JavaTokenId.class), attr);
+        TokenSequence<?> ts = hi.tokenSequence();
+
+        LexerTestUtilities.assertNextTokenEquals(ts,
+                                                 JavaTokenId.JAVADOC_COMMENT_LINE_RUN,
+                                                 "///test\n" +
+                                                 "///@see second line\n" +
+                                                 "///third\n");
+        LexerTestUtilities.assertNextTokenEquals(ts, JavaTokenId.WHITESPACE, "\n");
+        LexerTestUtilities.assertNextTokenEquals(ts,
+                                                 JavaTokenId.JAVADOC_COMMENT_LINE_RUN,
+                                                 "///another run\n" +
+                                                 "///another line\n");
+        assertFalse(ts.moveNext());
+    }
+
+    public void testMarkdown3() {
+        String text = """
+                      ///test
+                      ///@see second line
+                      ///third
+
+                      ///another run
+                      ///another line""";
+        InputAttributes attr = new InputAttributes();
+        TokenHierarchy<?> hi = TokenHierarchy.create(text, false, JavaTokenId.language(), EnumSet.noneOf(JavaTokenId.class), attr);
+        TokenSequence<?> ts = hi.tokenSequence();
+
+        LexerTestUtilities.assertNextTokenEquals(ts,
+                                                 JavaTokenId.JAVADOC_COMMENT_LINE_RUN,
+                                                 "///test\n" +
+                                                 "///@see second line\n" +
+                                                 "///third\n");
+        LexerTestUtilities.assertNextTokenEquals(ts, JavaTokenId.WHITESPACE, "\n");
+        LexerTestUtilities.assertNextTokenEquals(ts,
+                                                 JavaTokenId.JAVADOC_COMMENT_LINE_RUN,
+                                                 "///another run\n" +
+                                                 "///another line");
+        assertFalse(ts.moveNext());
+    }
+
 }
diff --git a/java/java.lexer/test/unit/src/org/netbeans/lib/java/lexer/JavadocLexerTest.java b/java/java.lexer/test/unit/src/org/netbeans/lib/java/lexer/JavadocLexerTest.java
index 72668f24a651..c0859ba2f826 100644
--- a/java/java.lexer/test/unit/src/org/netbeans/lib/java/lexer/JavadocLexerTest.java
+++ b/java/java.lexer/test/unit/src/org/netbeans/lib/java/lexer/JavadocLexerTest.java
@@ -143,6 +143,20 @@ public void test233097b() {
         LexerTestUtilities.assertNextTokenEquals(ts, JavadocTokenId.OTHER_TEXT, "}");
     }
 
+    public void testMarkdown() {
+        String text = "///@see\n/// @see";
+
+        TokenHierarchy<?> hi = TokenHierarchy.create(text, JavadocTokenId.language());
+        TokenSequence<?> ts = hi.tokenSequence();
+
+        LexerTestUtilities.assertNextTokenEquals(ts, JavadocTokenId.OTHER_TEXT, "///");
+        LexerTestUtilities.assertNextTokenEquals(ts, JavadocTokenId.TAG, "@see");
+        LexerTestUtilities.assertNextTokenEquals(ts, JavadocTokenId.OTHER_TEXT, "\n/// ");
+        LexerTestUtilities.assertNextTokenEquals(ts, JavadocTokenId.TAG, "@see");
+
+        assertFalse(ts.moveNext());
+    }
+
 //    public void testModification1() throws Exception {
 //        PlainDocument doc = new PlainDocument();
 //        doc.putProperty(Language.class, JavadocTokenId.language());
diff --git a/java/java.lsp.server/licenseinfo.xml b/java/java.lsp.server/licenseinfo.xml
index fc390b64bbc9..001c83187ebd 100644
--- a/java/java.lsp.server/licenseinfo.xml
+++ b/java/java.lsp.server/licenseinfo.xml
@@ -50,4 +50,9 @@
         <license ref="MIT-java-grammar" />
         <comment type="COMMENT_UNSUPPORTED" />
     </fileset>
+    <fileset>
+        <file>vscode/language-configuration.json</file>
+        <license ref="MIT-vscode" />
+        <comment type="COMMENT_UNSUPPORTED" />
+    </fileset>
 </licenseinfo>
diff --git a/java/java.lsp.server/vscode/language-configuration.json b/java/java.lsp.server/vscode/language-configuration.json
new file mode 100644
index 000000000000..c6b69e53360e
--- /dev/null
+++ b/java/java.lsp.server/vscode/language-configuration.json
@@ -0,0 +1,111 @@
+{
+	"comments": {
+		"lineComment": "//",
+		"blockComment": [ "/*", "*/" ]
+	},
+	"brackets": [
+		["{", "}"],
+		["[", "]"],
+		["(", ")"]
+	],
+	"autoClosingPairs": [
+		["{", "}"],
+		["[", "]"],
+		["(", ")"],
+		{ "open": "\"", "close": "\"", "notIn": ["string"] },
+		{ "open": "'", "close": "'", "notIn": ["string"] },
+		{ "open": "/**", "close": " */", "notIn": ["string"] }
+	],
+	"surroundingPairs": [
+		["{", "}"],
+		["[", "]"],
+		["(", ")"],
+		["\"", "\""],
+		["'", "'"],
+		["<", ">"]
+	],
+	"folding": {
+		"markers": {
+			"start": "^\\s*//\\s*(?:(?:#?region\\b)|(?:<editor-fold\\b))",
+			"end": "^\\s*//\\s*(?:(?:#?endregion\\b)|(?:</editor-fold>))"
+		}
+	},
+	"onEnterRules": [
+		{
+			// e.g. /** | */
+			"beforeText": {
+				"pattern": "^\\s*/\\*\\*(?!/)([^\\*]|\\*(?!/))*$"
+			},
+			"afterText": {
+				"pattern": "^\\s*\\*/$"
+			},
+			"action": {
+				"indent": "indentOutdent",
+				"appendText": " * "
+			}
+		},
+		{
+			// e.g. /** ...|
+			"beforeText": {
+				"pattern": "^\\s*/\\*\\*(?!/)([^\\*]|\\*(?!/))*$"
+			},
+			"action": {
+				"indent": "none",
+				"appendText": " * "
+			}
+		},
+		{
+			// e.g.  * ...|
+			"beforeText": {
+				"pattern": "^(\\t|[ ])*[ ]\\*([ ]([^\\*]|\\*(?!/))*)?$"
+			},
+			"previousLineText": {
+				"pattern": "(?=^(\\s*(/\\*\\*|\\*)).*)(?=(?!(\\s*\\*/)))"
+			},
+			"action": {
+				"indent": "none",
+				"appendText": "* "
+			}
+		},
+		{
+			// e.g.  */|
+			"beforeText": {
+				"pattern": "^(\\t|[ ])*[ ]\\*/\\s*$"
+			},
+			"action": {
+				"indent": "none",
+				"removeText": 1
+			}
+		},
+		{
+			// e.g.  *-----*/|
+			"beforeText": {
+				"pattern": "^(\\t|[ ])*[ ]\\*[^/]*\\*/\\s*$"
+			},
+			"action": {
+				"indent": "none",
+				"removeText": 1
+			}
+		},
+		{
+			"beforeText": {
+				"pattern": "^\\s*(\\bcase\\s.+:|\\bdefault:)$"
+			},
+			"afterText": {
+				"pattern": "^(?!\\s*(\\bcase\\b|\\bdefault\\b))"
+			},
+			"action": {
+				"indent": "indent"
+			}
+		},
+		{
+			"beforeText": {
+				"pattern": "^\\s*///.*$"
+			},
+			"action": {
+				"indent": "none",
+				"appendText": "///"
+			}
+		}
+	]
+}
diff --git a/java/java.lsp.server/vscode/package.json b/java/java.lsp.server/vscode/package.json
index cad97381ef73..60795163b16a 100644
--- a/java/java.lsp.server/vscode/package.json
+++ b/java/java.lsp.server/vscode/package.json
@@ -35,6 +35,18 @@
 	"main": "./out/extension.js",
 	"contributes": {
 		"languages": [
+			{
+				"id": "java",
+				"extensions": [
+					".java",
+					".jav"
+				],
+				"aliases": [
+					"Java",
+					"java"
+				],
+				"configuration": "./language-configuration.json"
+			},
 			{
 				"id": "javascript",
 				"mimetypes": [
diff --git a/java/java.lsp.server/vscode/syntaxes/java.tmLanguage.json b/java/java.lsp.server/vscode/syntaxes/java.tmLanguage.json
index 1357aff68d5f..d990bf88fd93 100644
--- a/java/java.lsp.server/vscode/syntaxes/java.tmLanguage.json
+++ b/java/java.lsp.server/vscode/syntaxes/java.tmLanguage.json
@@ -655,6 +655,63 @@
 							}
 						}
 					]
+				},
+				{
+					"begin": "^\\s*(///)",
+					"beginCaptures": {
+						"1": {
+							"name": "punctuation.definition.comment.java"
+						}
+					},
+					"end": "\n",
+					"endCaptures": {
+						"0": {
+							"name": "punctuation.definition.comment.java"
+						}
+					},
+					"name": "comment.block.javadoc.markdown.java",
+					"patterns": [
+						{
+							"match": "@(author|deprecated|return|see|serial|since|version)\\b",
+							"name": "keyword.other.documentation.javadoc.java"
+						},
+						{
+							"match": "(@param)\\s+(\\S+)",
+							"captures": {
+								"1": {
+									"name": "keyword.other.documentation.javadoc.java"
+								},
+								"2": {
+									"name": "variable.parameter.java"
+								}
+							}
+						},
+						{
+							"match": "(@(?:exception|throws))\\s+(\\S+)",
+							"captures": {
+								"1": {
+									"name": "keyword.other.documentation.javadoc.java"
+								},
+								"2": {
+									"name": "entity.name.type.class.java"
+								}
+							}
+						},
+						{
+							"match": "{(@link)\\s+(\\S+)?#([\\w$]+\\s*\\([^\\(\\)]*\\)).*?}",
+							"captures": {
+								"1": {
+									"name": "keyword.other.documentation.javadoc.java"
+								},
+								"2": {
+									"name": "entity.name.type.class.java"
+								},
+								"3": {
+									"name": "variable.parameter.java"
+								}
+							}
+						}
+					]
 				}
 			]
 		},
diff --git a/java/java.source.base/src/org/netbeans/api/java/source/TreeUtilities.java b/java/java.source.base/src/org/netbeans/api/java/source/TreeUtilities.java
index a7453c44778e..bca4cbd46ae0 100644
--- a/java/java.source.base/src/org/netbeans/api/java/source/TreeUtilities.java
+++ b/java/java.source.base/src/org/netbeans/api/java/source/TreeUtilities.java
@@ -1302,7 +1302,11 @@ public int[] findNameSpan(DocCommentTree docTree, ReferenceTree ref) {
         
         tokenSequence.move(pos);
         
-        if (!tokenSequence.moveNext() || tokenSequence.token().id() != JavaTokenId.JAVADOC_COMMENT) return null;
+        if (!tokenSequence.moveNext() ||
+            (tokenSequence.token().id() != JavaTokenId.JAVADOC_COMMENT &&
+             tokenSequence.token().id() != JavaTokenId.JAVADOC_COMMENT_LINE_RUN)) {
+            return null;
+        }
         
         TokenSequence<JavadocTokenId> jdocTS = tokenSequence.embedded(JavadocTokenId.language());
         
diff --git a/java/java.sourceui/nbproject/project.xml b/java/java.sourceui/nbproject/project.xml
index 9ac80a3c0929..f1bb6375971b 100644
--- a/java/java.sourceui/nbproject/project.xml
+++ b/java/java.sourceui/nbproject/project.xml
@@ -86,6 +86,14 @@
                         <implementation-version/>
                     </run-dependency>
                 </dependency>
+                <dependency>
+                    <code-name-base>org.netbeans.libs.flexmark</code-name-base>
+                    <build-prerequisite/>
+                    <compile-dependency/>
+                    <run-dependency>
+                        <specification-version>1.18</specification-version>
+                    </run-dependency>
+                </dependency>
                 <dependency>
                     <code-name-base>org.netbeans.libs.javacapi</code-name-base>
                     <build-prerequisite/>
diff --git a/java/java.sourceui/src/org/netbeans/api/java/source/ui/ElementJavadoc.java b/java/java.sourceui/src/org/netbeans/api/java/source/ui/ElementJavadoc.java
index fdabe504448e..832e599852c2 100644
--- a/java/java.sourceui/src/org/netbeans/api/java/source/ui/ElementJavadoc.java
+++ b/java/java.sourceui/src/org/netbeans/api/java/source/ui/ElementJavadoc.java
@@ -32,6 +32,7 @@
 import com.sun.source.doctree.LinkTree;
 import com.sun.source.doctree.LiteralTree;
 import com.sun.source.doctree.ParamTree;
+import com.sun.source.doctree.RawTextTree;
 import com.sun.source.doctree.ReferenceTree;
 import com.sun.source.doctree.ReturnTree;
 import com.sun.source.doctree.SeeTree;
@@ -119,6 +120,11 @@
 import com.sun.source.tree.ImportTree;
 import com.sun.source.tree.Tree;
 import com.sun.source.util.JavacTask;
+import com.vladsch.flexmark.ext.tables.TablesExtension;
+import com.vladsch.flexmark.html.HtmlRenderer;
+import com.vladsch.flexmark.parser.Parser;
+import com.vladsch.flexmark.util.data.DataHolder;
+import com.vladsch.flexmark.util.data.MutableDataSet;
 import javax.lang.model.element.RecordComponentElement;
 import org.netbeans.api.java.queries.SourceLevelQuery;
 import org.netbeans.api.java.queries.SourceLevelQuery.Profile;
@@ -1275,7 +1281,7 @@ private String noJavadocFound() {
     private StringBuilder inlineTags(List<? extends DocTree> tags, TreePath docPath, DocCommentTree doc, DocTrees trees, CharSequence inherited) {
         StringBuilder sb = new StringBuilder();
         Integer snippetCount=0;
-        for (DocTree tag : tags) {
+        for (DocTree tag : resolveMarkdown(trees, tags)) {
             switch (tag.getKind()) {
                 case REFERENCE:
                     ReferenceTree refTag = (ReferenceTree)tag;
@@ -1287,6 +1293,9 @@ private StringBuilder inlineTags(List<? extends DocTree> tags, TreePath docPath,
                     break;
                 case LINK:
                     linkTag = (LinkTree)tag;
+                    if (linkTag.getReference() == null) {
+                        break;
+                    }
                     sb.append("<code>"); //NOI18N
                     appendReference(sb, linkTag.getReference(), linkTag.getLabel(), docPath, doc, trees);
                     sb.append("</code>"); //NOI18N
@@ -1395,6 +1404,53 @@ private StringBuilder inlineTags(List<? extends DocTree> tags, TreePath docPath,
         return sb;
     }
 
+    private static final char REPLACEMENT = '\uFFFD';
+    private List<? extends DocTree> resolveMarkdown(DocTrees trees, List<? extends DocTree> tags) {
+        if (tags.stream().noneMatch(t -> t.getKind() == DocTree.Kind.MARKDOWN)) {
+            return tags;
+        }
+
+        StringBuilder markdownSource = new StringBuilder();
+        List<DocTree> replacements = new ArrayList<>();
+
+        for (DocTree t : tags) {
+            if (t.getKind() == DocTree.Kind.MARKDOWN) {
+                markdownSource.append(((RawTextTree) t).getContent());
+            } else {
+                markdownSource.append(REPLACEMENT);
+                replacements.add(t);
+            }
+        }
+
+        TablesExtension tablesExtension = TablesExtension.create();
+
+        Parser.Builder parserBuilder = Parser.builder();
+        tablesExtension.extend(parserBuilder);
+
+        HtmlRenderer.Builder rendererBuilder = HtmlRenderer.builder();
+        tablesExtension.extend(rendererBuilder, "HTML");
+
+        String html = rendererBuilder.build()
+                                     .render(parserBuilder.build()
+                                                          .parse(markdownSource.toString()));
+
+        if (html.startsWith("<p>")) {
+            html = html.substring("<p>".length());
+        }
+        html = html.replace("</p>", "");
+        List<DocTree> result = new ArrayList<>();
+        String[] parts = html.split(Pattern.quote("" + REPLACEMENT));
+
+        result.add(trees.getDocTreeFactory().newTextTree(parts[0]));
+
+        for (int i = 1; i < parts.length; i++) {
+            result.add(replacements.get(i - 1));
+            result.add(trees.getDocTreeFactory().newTextTree(parts[i]));
+        }
+
+        return result;
+    }
+
     private void processDocSnippet(StringBuilder sb, SnippetTree javadocSnippet, Integer snippetCount, TreePath docPath,DocCommentTree doc, DocTrees trees) {
         sb.append("<div id=\"snippet").append(snippetCount).append("\" style=\"font-size: 10px; border: 1px solid black; margin-top: 2px; margin-bottom: 2px\">"); //NOI18N
         sb.append("<div align=right>" //NOI18N
diff --git a/java/java.sourceui/test/unit/src/org/netbeans/api/java/source/ui/ElementJavadocTest.java b/java/java.sourceui/test/unit/src/org/netbeans/api/java/source/ui/ElementJavadocTest.java
new file mode 100644
index 000000000000..13bee62039d3
--- /dev/null
+++ b/java/java.sourceui/test/unit/src/org/netbeans/api/java/source/ui/ElementJavadocTest.java
@@ -0,0 +1,164 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.netbeans.api.java.source.ui;
+
+import com.sun.source.util.TreePath;
+import java.io.File;
+import java.util.ArrayList;
+import java.util.List;
+import javax.lang.model.element.Element;
+import javax.swing.text.Document;
+import org.netbeans.api.java.lexer.JavaTokenId;
+import org.netbeans.api.java.source.CompilationInfo;
+import org.netbeans.api.java.source.JavaSource;
+import org.netbeans.api.java.source.JavaSource.Phase;
+import org.netbeans.api.java.source.SourceUtilsTestUtil;
+import org.netbeans.api.java.source.TestUtilities;
+import org.netbeans.api.lexer.Language;
+import org.netbeans.junit.NbTestCase;
+import org.netbeans.modules.java.JavaDataLoader;
+import org.openide.cookies.EditorCookie;
+import org.openide.filesystems.FileObject;
+import org.openide.filesystems.FileUtil;
+import org.openide.loaders.DataObject;
+
+public class ElementJavadocTest extends NbTestCase {
+
+    private static final String CARET_MARK = "<caret>";
+
+    public ElementJavadocTest(String testName) {
+        super(testName);
+    }
+
+    private void prepareTest(String fileName, String code) throws Exception {
+        int pos = code.indexOf(CARET_MARK);
+
+        if (pos == (-1)) {
+            throw new AssertionError("Does not have caret position!");
+        }
+
+        code = code.substring(0, pos) + code.substring(pos + CARET_MARK.length());
+
+        List<Object> extras = new ArrayList<>();
+        extras.add(JavaDataLoader.class);
+        SourceUtilsTestUtil.prepareTest(new String[] {
+                    "org/netbeans/modules/java/platform/resources/layer.xml",
+                    "org/netbeans/modules/java/j2seplatform/resources/layer.xml"
+                },
+                extras.toArray(new Object[0])
+        );
+
+        clearWorkDir();
+
+        FileUtil.refreshAll();
+
+        FileObject workFO = FileUtil.toFileObject(getWorkDir());
+
+        assertNotNull(workFO);
+
+        sourceRoot = workFO.createFolder("src");
+
+        FileObject buildRoot  = workFO.createFolder("build");
+        FileObject cache = workFO.createFolder("cache");
+
+        FileObject data = FileUtil.createData(sourceRoot, fileName);
+        File dataFile = FileUtil.toFile(data);
+
+        assertNotNull(dataFile);
+
+        TestUtilities.copyStringToFile(dataFile, code);
+
+        SourceUtilsTestUtil.prepareTest(sourceRoot, buildRoot, cache, new FileObject[0]);
+
+        DataObject od = DataObject.find(data);
+        EditorCookie ec = od.getCookie(EditorCookie.class);
+
+        assertNotNull(ec);
+
+        doc = ec.openDocument();
+        doc.putProperty(Language.class, JavaTokenId.language());
+
+        JavaSource js = JavaSource.forFileObject(data);
+
+        assertNotNull(js);
+
+        info = SourceUtilsTestUtil.getCompilationInfo(js, Phase.RESOLVED);
+
+        assertNotNull(info);
+
+        selectedPath = info.getTreeUtilities().pathFor(pos);
+        selectedElement = info.getTrees().getElement(selectedPath);
+
+        assertNotNull(selectedElement);
+    }
+
+    private FileObject sourceRoot;
+    private CompilationInfo info;
+    private Document doc;
+    private TreePath selectedPath;
+    private Element selectedElement;
+
+    protected void performTest(String fileName, String code, int pos, String format, String golden) throws Exception {
+        prepareTest(fileName, code);
+
+        TreePath path = info.getTreeUtilities().pathFor(pos);
+
+        assertEquals(golden, ElementHeaders.getHeader(path, info, format));
+    }
+
+    public void testMarkdownTables() throws Exception {
+        prepareTest("test/Test.java",
+                    "///| header1 | header2 |\n" +
+                    "///|---------|---------|\n" +
+                    "///| cr11    | cr12    |\n" +
+                    "///| cr21    | cr22    |\n" +
+                    "public class T<caret>est {\n" +
+                    "}\n");
+
+        String actualJavadoc = ElementJavadoc.create(info, selectedElement).getText();
+        String expectedJavadoc = "<pre>public class <b>Test</b><br>extends <a href='*0'>Object</a></pre><p><table>\n" +
+                                 "<thead>\n" +
+                                 "<tr><th>header1</th><th>header2</th></tr>\n" +
+                                 "</thead>\n" +
+                                 "<tbody>\n" +
+                                 "<tr><td>cr11</td><td>cr12</td></tr>\n" +
+                                 "<tr><td>cr21</td><td>cr22</td></tr>\n" +
+                                 "</tbody>\n" +
+                                 "</table>\n" +
+                                 "<p>";
+
+        assertEquals(expectedJavadoc, actualJavadoc);
+    }
+
+    public void testLinkNoRef() throws Exception {
+        prepareTest("test/Test.java",
+                    "///Hello!\n" +
+                    "///{@link }\n" +
+                    "public class T<caret>est {\n" +
+                    "}\n");
+
+        String actualJavadoc = ElementJavadoc.create(info, selectedElement).getText();
+        String expectedJavadoc = "<pre>public class <b>Test</b><br>extends <a href='*0'>Object</a></pre><p>Hello!\n" +
+                                 "\n" +
+                                 "<p>";
+
+        assertEquals(expectedJavadoc, actualJavadoc);
+    }
+
+}
